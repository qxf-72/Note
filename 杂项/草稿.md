

# 小码哥的抽卡之旅-题解（C++）

### 题目大意
单抽出金的概率是0.6%，如果前89发都不出金，则90发必出金。有 n 抽，求出金概率。

### 思路
如果直接求出金概率，那么需要讨论出了几发金，是哪几抽出的金，这样计算将会很繁琐，**正难则反**，所以可以从不出金的角度切入：

设 n 抽不出金的概率为  $P_{not}$ ，有

$$
P_{not}=(1-0.006)^n
$$

最终出金概率就为 $1-P_{not}$ ，这里需要注意边界，90 发必出金，所以当 n 大于等于 90 时，出金概率必然 100%。

### 代码
```cpp
// #include<bits/stdc++.h> //少用万能头(手动狗头)
#include<iostream>
#include <iomanip>

#define ll long long
using namespace std;

void solve()
{
    ll n;
    cin>>n;
    if(n>=90){
        cout<<"100.000000%\n";
        return;
    }
    long double no=0.994;
    for(int i=1;i<n;i++)
        no*=0.994;
    
    long double ans=1-no;
    cout<<fixed<<setprecision(6)<<ans*100<<"%\n";
}

int main() 
{
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    cout.tie(nullptr);
    solve( );  
    return 0;

}
```


---

# [抽奖概率](https://www.matiji.net/exam/dohomework/4825/2) -题解（Cpp）
### 题意
箱子里有**一红一白两小球**，每次摸出一个球——
- 摸到红球中奖，如果中奖，就停止；
- 如来摸到白球，则往箱子里补充一个白球（摸出的白球不放回)，继续抽奖，直到中奖，或者达到最大抽奖次数。

**至多能抽奖 M 次**，求当停止抽奖时，（中奖球数/摸出总球数）的期望。

### 思路
说到数学期望，学过概率论（或者高中数学）的同学肯定不会陌生，其计算公式为：

$$
\sum{\text{可能的取值}\times \text{取到该值的概率}}
$$

回到本题，需要求（中奖球数/摸出总球数）的期望，**设 K=中奖球数/摸出总球数**，所以需要枚举 K 的取值情况，由于摸到白球就停止，所以中奖球数必定为 1 或者 0，当其为 0 时，无需考虑，因为此时 K 等于 0，不会影响到期望了。

故，需要枚举的是——当取到 1 个白球时总的球数和对应的概率。设 p_i 为一共抽了 i 个球才中奖（第 i 次抽到白球），有：

$$
p_i=\left( \frac{1}{2} \right) ^i
$$

此时，有：

$$
K=\frac{1}{i}
$$

编写代码从 i=1 开始进行枚举累加到 i=m 即可。

### 代码
```cpp
// #include<bits/stdc++.h>  //少用万能头
#include<iostream>
#include <iomanip>


void solve()
{
    long long m;
    std::cin>>m;
    long double ans=0,p=1;
    for(int i=1;i<=m;i++){
        p/=2;       //概率
        ans+=p/i;   //加入期望
    }
    std::cout<<std::fixed<<std::setprecision(6)<<ans<<std::endl;
    
}

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    solve( );  
    return 0;
}
```

---

# [赌石](https://www.matiji.net/exam/dohomework/4825/3) -题解（C++）
### 题意
有 2 n 个球，n 个红球和 n 个蓝球，每次摸球的概率摸到红球和蓝球的概率都是 1/2 。求出一个桶里没球而另一个桶里还剩两个球的概率。

---

### 思路

**策略一**
根据题意，会有两种情况——红球剩两个或者蓝球剩两个。由于两种情况概率是一样的，不妨先讨论一种情况，最优再乘以二即可。根据二项分布，可得：


$$
p=\left( \begin{array}{c}
	2n-2\\
	n\\
\end{array} \right) \times \left( \frac{1}{2} \right) ^n\times \left( 1-\frac{1}{2} \right) ^{n-2}=\left( \begin{array}{c}
	2n-2\\
	n\\
\end{array} \right) \times \left( \frac{1}{2} \right) ^{2n-2}
$$


最后将 2*p 返回即可。

**策略二**
也可以从对立事件角度出发，求 1-p 的概率，此时每个桶都只剩下一个球，根据二项分布，得：


$$
1-p=\left( \begin{array}{c}
	2n-2\\
	n-1\\
\end{array} \right) \times \left( \frac{1}{2} \right) ^{n-1}\times \left( 1-\frac{1}{2} \right) ^{n-1}\ \ =\ \ \ \ \left( \begin{array}{c}
	2n-2\\
	n-1\\
\end{array} \right) \times \left( \frac{1}{2} \right) ^{2n-2}
$$


使用这种方法的好处是，计算组合数和计算计算概率（即，1/2 那部分）可以结合在一起，简化代码。

---

### 代码
```cpp
// #include<bits/stdc++.h>
#include <iostream>
#include <iomanip>

#define ll long long
using namespace std;

void solve()
{
    ll n;
    cin >> n;
    n /= 2;
    long double ans = 1.0;
    for (int i = 1; i < n; i++)
    {
        ans *= (long double)(n - 1 + i) / (4 * i);  //这里除以4是在计算概率的那部分
    }
    ans = 1.0 - ans;
    cout << fixed << setprecision(4) << ans << endl;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    cout.tie(nullptr);
    solve();
    return 0;
}
```

---

# 快速傅里叶变换

FFT 算法可以在 $nlog(n)$ 计算两个 $n$ 度多项式的乘法，比朴素算法 $O(n^2)$ 更高效。

## 前提概念
$n-1$ 次多项式，最高次项次数为 $n-1$ 次：

$$
A(x)=a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1}
$$

也可以写成这样的形式：

$$
\sum_{j=0}^{n-1}{a_jx^j}
$$

$n-1$ 次多项式，可以用一个长度为 $n$ 的系数向量来表示——**系数表示法**。

$n-1$ 次多项式 $A(x)$ 和 $m-1$ 次多项式 $B(x)$ 相乘可以得到一个 $n+m-2$ 次的多项式 $C(x)$，这里需要求的是 $C(x)$ 的系数向量。

## DFT 和 IDFT
FFT 主要使用了两种数学方法，离散傅里叶变换（DFT）以及离散傅里叶变换逆变换（IDFT）。

- ==**离散傅里叶变换 DFT**：已知 $x_0,x_1,x_2,...x_{n-1}$ 和 $k$ 求 $X_k$== ，公式如下：

$$
X_k=\sum_{j=0}^{n-1}{x_je^{\frac{2\pi i}{n}kj}}
$$

- ==**离散傅里叶逆变换 IDFT**：已知 $X_0,X_1,X_2,...,X_{n-1}$ 和 $j$ ，可以求出 $x_j$==  ，公式如下：

$$
x_j=\frac{1}{n}\ \sum_{k=0}^{n-1}{X_ke^{-\frac{2\pi i}{n}jk}}
$$ 

DFT 和 IDFT 是在 $k$ 确定的情况下， $X_k$ 和 $x_j(j=0,1,2,...,n-1)$ 相互转化的桥梁。

此时，令 $\omega _N=e^{\frac{2\pi i}{N}}$ ，

C:\Users\qiuxiaofeng\AppData\Roaming\obsidian\obsidian.json