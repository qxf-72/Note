
# 计算机系统概述

## 操作系统基本概念

### 操作系统概念

操作系统管理计算机硬件资源，为应用程序提供基础，充当计算机硬件与用户之间的中介。

操作系统是**程序集合**，是计算机系统中**最基本的系统软件**。

> 系统软件是指直接控制和管理计算机硬件资源、提供用户与计算机交互界面以及为应用软件提供运行环境的软件。它包括操作系统、设备驱动程序、诊断工具、服务器软件、窗口系统和实用程序等。


---


<br/>

### 操作系统特征

**并发和共享是最基本的特征**
- 共享以并发为基础
- 若不能对资源共享进行有效管理，会影响程序的并发执行

<br/>


**并发**

多个事件在同一时间间隔内发生。

<br/>


**共享**
- 互斥共享：**一段时间**只允许一个进程访问。打印机、磁带机。
- 同时共享：磁盘设备。

<br/>


**虚拟**
- 时分复用技术：例如多道程序设计技术
- 空分复用技术：虚拟存储器技术

<br/>


**异步**

进程的执行以不可预知的速度前进。

---

<br/>

### 操作系统目的与功能

**计算机系统资源的管理者**

- 处理机管理：处理机的分配和运行以进程（线程）为单位，可以归结为进程管理
- 存储器管理：内存的管理
- 文件管理
- 设备管理

<br/>


**用户与计算机硬件系统之间的接口**

- 命令接口：
	- 脱机命令接口：一条命令一条命令的输入，然后执行、反馈。交互性
	- 联机命令接口
- 程序接口：系统调用

<br/>


**计算机资源的扩充**

- 裸机
- 扩充机器（虚拟机）：覆盖了软件的机器

---

<br/>


<br/>



## 操作系统发展历程

**手工阶段**

无操作系统

<br/>


**批处理阶段（操作系统开始出现）**
- 单道批处理：**内存中仅存放一道作业**
- 多道批处理：内存中可以存放多道作业，在一道作业阻塞时，另一道作业执行。

<br/>


**分时操作系统**

按照时间片轮转执行

<br/>


**实时操作系统**
- 硬实时：动作必须在规定时间（或时间段）内**发生**
- 软实时：可以偶尔违反时间规定，而不引起永久性损害。

<br/>


**网络操作系统与分布系统操作系统**
- 网络操作系统：强调网络中各种资源的共享和各台计算机之间的通信。
- 分布式操作系统：**一个任务**可以分布在几台计算上，**并行工作**，协作完成。

---

<br/>


<br/>



## 操作系统运行环境

### 处理器运行模式

**特权指令与非特权指令**
- 特权指令：只能在内核态执行的指令，I/O 指令、关中断指令、内存清零指令、存取用于内存保护的寄存器、送 PSW 到程序状态字寄存器。
- 非特权指令：这类指令不会涉及对系统状态或资源的直接修改。

> 这里的指令通常指的是 汇编指令 或 机器指令。这些指令直接与处理器交互，控制硬件的操作。
> 
> 访存指令 load（加载指令）一般属于 非特权指令。虽然 load 指令本身是非特权指令，但用户程序只能访问自己拥有权限的内存区域。如果试图通过 load 指令访问未授权的内存地址（比如内核空间），处理器会触发异常，防止非法操作。


<br/>

**用户态与内核态**

- 用户态：应用程序需要请求操作系统服务时，通过**访管指令**（非特权指令）。
- 内核态：操作系统**内核程序运行在内核态**。由内核态返回用户态，一般通过**中断返回指令**。


> 
虽然用户态与核心态之间的切换在硬件层面只是通过设置寄存器标志来完成，但实际的开销远不止这一点。
> - 保存和恢复上下文：从用户态切换到核心态时，系统需要保存当前进程的上下文。
> - 缓存失效：访问不同的内存区域（如内核代码和用户代码、内核数据和用户数据），可能会导致 Cache 和快表失效。
> - 内存映射切换：内核态和用户态可能使用不同的页表（管理内存的映射）。在态切换时，可能需要调整页表，导致页表的更新或刷新。这也增加了系统的开销。


<br/>

**操作系统内核**

- 时钟管理
- 中断机制：只有一小部分属于内核，辅助保护和恢复中断现场的信息，转移控制权。
- 原语
- 系统控制的数据结构 以及 处理

---

<br/>

### 中断和异常的概念

当发生中断和异常时，CPU 会进入内核态（**通过硬件实现**，例如，通过一个特殊的寄存器了表示 CPU 所处的工作状态）。

<br/>

中断（外中断）：由与指令指令执行无关的外部事件引起，需要通过请求线来通知 CPU。
- 可屏蔽中断：通过 INTR 线发出请求。
- 不可屏蔽中断：通过 NMI 线发出请求，通常是紧急的硬件故障，如电源掉电。

异常（内中断）：由于指令的执行引起
- 故障：非法操作码、除零、缺页
- 自陷：条件陷阱、系统调用
- 终止：硬件故障，控制器出错、存储器校验错

---

<br/>

### 系统调用

凡是与**系统资源有关**的操作（存储分配、I/O 传输、文件管理）都必须通过系统调用方式向操作系统提出服务请求。系统调用的处理由于操作系统**内核程序**完成，在内核态。

<br/>


**系统调用的处理过程**
- 系统调用号和所需参数压入栈
- 陷入指令，用户态转为内核态
- 保护被中断进程的现场
- 转入相应的系统调用处理程序（根据系统调用号来找到入口地址）
- 恢复现场
- 返回被中断进程

---


<br/>


<br/>

## 操作系统结构

**分层法**

底层为硬件，顶层为用户接口。**每层只能调用紧挨其的低一层的服务**。

优点：
- 方便系统调试和验证。一层一层的调试，当某一层发生错误，不用检查底下的层。
- 易于扩充和维护，增加、修改、替换某一层时，只要不改变接口，就不会影响其他层。

缺点：
- 定义各层比较困难
- 效率较差：没执行一个功能要从上向下穿过多层


<br/>

**模块化**

按照功能划分为具有一定独立性的模块。

优点：
- 提高操作系统设计的准确性、可理解性、可维护性
- 增强操作系统的可适应性
- 操作操作系统开发过程

缺点：
- 模块间接口规定很难满足对接口的实际需求
- 各模块设计者齐头并进，决定无法建立在上一个已验证的正确基础之上


<br/>

**宏内核**

将系统**主要功能模块**作为一个紧密联系的整体运行在核心态。

目前主流的操作系统都是基于宏内核的架构（并非纯粹的宏内核，而是吸收了微内核优点的混合内核）。


<br/>

**微内核**

将内核中**最基本的功能**留在内核，其余移到用户态执行，移出内核的操作系统代码根据分层原则被划分为若干**服务程序**。**服务程序之间借助微内核进行通信**。

微内核包含：
- 与硬件密切相关的部分
- 较基本的功能
- 客户与服务器之间的通信。提供消息传递机制。

微内核功能：
- 进程管理。微内核之外有进程管理服务器，用于对用户进程进行分类，确定优先级。
- 低级存储器管理：最基本的管理机制，如实现逻辑地址到物理地址转换的页表机制和地址变换机制。
- 中断和陷入处理：捕获发生的中断或陷入事件，识别之后，交给对应的服务程序进行处理。

微内核特点：
- 拓展性与灵活性
- 可靠性与安全性
- 可移植性：与硬件有关的代码放在内核
- 分布式计算：采用消息传递机制，很好支持分布式和网络系统
- 存在性能问题：频繁在核心态和用户态之间进行切换

微内核在实时、工业、航空以及军事应用中特别流行。


<br/>

**外核**

外核程序运行在内核态，负责对硬件资源进行分配、回收、保护。

---


<br/>


<br/>


## 操作系统引导

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-08-26_111206.png" width="600" />
</center>


---

<br/>


<br/>

## 虚拟机

**第一类虚拟机管理程序**

虚拟管理程序就像是操作系统，而虚拟机像是一个进程。

当虚拟机操作系统执行了一条内核态才运行执行的指令，陷入虚拟机管理程序，在支持虚拟化的 CPU 上，检查指令是由系统执行还是用户执行：
- 系统执行：虚拟机管理程序安排指令的正确执行。
- 用户执行：模拟真实硬件面对用户态执行敏感指令的行为。

在不支持虚拟化的 CPU 上，不会直接执行虚拟机的敏感指令，而是转为对于虚拟机管理程序的调用，由虚拟机管理程序模拟指令的功能。


<br/>

**第二类虚拟机管理程序**

虚拟机管理程序本身像是一个进程， 依赖于 宿主操作系统分配和调度资源。

VMware Workstation 是 x 86 平台上收个第二类虚拟机管理程序。


---

<br/>


<br/>


<br/>

# 进程 与 线程

## 进程与线程介绍

### 进程概念与特征

**进程的概念**

在多道程序环境下，运行多个程序并发执行。程序失去封闭性，具有间断性和不可再现性。

> **封闭性**：执行结果只取决于进程本身，不受外界影响。

> **不可再现性**：并发进程存在相互竞争与制约，每次执行结果可能不一样。


因此引入了进程的概念，**进程实体**由三部分组成：
- 进程控制块 PCB：描述进程的基本情况和运行状态的数据结构
- 程序段
- 数据段

进程是进程实体的运行过程，是系统进行**资源分配**和**调度**的基本单位。


<br/>

**进程的特征**

- 动态性：进程是程序的一次执行
- 并发性
- 独立性
- 异步性

---

<br/>

### 进程的组成

**进程控制块 PCB**

PCB 在创建之后常驻于内存，是进程存在的唯一标志，系统通过 PCB 对进程进行控制（系统通过 PCB 才能感知到该进程的存在），PCB 的组成如下：
- 进程描述信息：PID，UID（用户标识符，主要为共享和保护提供服务）
- 进程控制与管理信息：进程当前状态、优先级、代码入口地址、程序外存地址、CPU 占用时间等
- 资源分配清单：代码段指针、数据段指针、堆栈段指针
- 处理机相关信息：CPU 各寄存器的值

各个进程 PCB 的组织方式：
- 链接方式：相同状态的 PCB 链接成一个列表
- 索引方式：相同状态的 PCB 组织在一个索引表里面


<br/>

**程序段**

即代码段。多个进程可以运行同一个程序。


<br/>

**数据段**

加工处理的原始数据；执行时产生的中间与最终结果。


> <center>
> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-08-30_095205.jpg" width="500" />
> </center>

> - **栈区（stack**）: 存放函数形参和局部变量（auto 类型），由编译器自动分配和释放。
> - **堆区（heap）**: 该区由程序员申请后使用，需要手动释放否则会造成内存泄漏。如果程序员没有手动释放，那么程序结束时可能由 OS 回收。
> - **全局/静态存储区**：存放全局变量和静态变量（包括静态全局变量与静态局部变量），初始化的全局变量和静态局部变量放在一块，未初始化的放在另一块。
> - **文字常量区**：常量在统一运行被创建，常量区的内存是只读的，程序结束后由系统释放。
> - **程序代码区**：存放程序的二进制代码，内存由系统管理

> text 段在内存中被映射为只读，但 date 段与 bss 段是可写的
> - **text 段**：代码段，就是放程序代码的，编译时确定，只读。
> - **date 段**：存放在编译阶段（而非运行时）就能确定的数据，可读可写。也就是通常所说的静态存储区，赋了初值的全局变量和赋初值的静态变量存放在这个区域，常量也存在这个区域。
> - **bss 段**：已经定义但**没赋初值**的全局变量和静态变量存放在这个区域。

---

<br/>

### 进程的状态 与 转换
通常有 5 种状态，运行、就绪、阻塞是 **基本状态**

- 运行态：进程正在 CPU 运行。
- 就绪态：获得了除了 CPU 时间片以外的一切所需资源，等待调度运行。
- 阻塞态：等待某个资源（不包括 CPU 时间片）可以用，或者 I/O 完成。
- 创建态：正在被创建，需要完成以下步骤
	- 申请空白 PCB
	- 向 PCB 写入信息
	- 分配运行时所需资源
	- 将进程转入就绪态，并插入队列
- 终止态


<br/>

进程状态转换：
- 就绪  ---> 运行：被调度，获得 CPU 资源
- 运行  ---> 就绪：时间片用完，或者时间片被跟高优先级进程抢占
- 运行  ---> 阻塞：这是**进程的主动行为**。进程执行 wait 操作，进入休眠，或者等待 I/O 
- 阻塞  ---> 就绪：**进程的被动行为**，需要其他进程协助。

---

<br/>

### 进程控制

一般将进程控制用的程序段称为**原语**。

**进程创建**

进程可以创建子进程，子进程继承父进程所拥有的资源，当子进程被撤销时，获得的资源归还给父进程，父进程撤销时，通常会撤销其所有子进程。

> 当一个进程（父进程）创建一个新的进程（子进程）时，子进程会继承父进程的以下资源：
> 
> - **文件描述符**：子进程会继承父进程打开的所有文件描述符。这意味着子进程可以访问父进程能够访问的所有文件和设备。
> - **环境变量**：子进程继承父进程的环境变量，这包括操作系统提供的各种环境设置，如语言环境、用户信息等。
> - **执行代码**：子进程继承父进程的程序代码，即它们执行的是相同的程序。
> - **堆和栈**：子进程会**复制**父进程的堆和栈的初始状态，但它们是**独立的**，子进程的任何修改都不会影响到父进程。
> - **全局变量**：如果父进程有全局变量，子进程也会继承这些变量的初始值，但它们在子进程中的修改**不会影响到父进程中的全局变量**。
> - **信号处理**：子进程会继承父进程的信号处理设置。
> - **进程 ID**：子进程会获得一个新的进程 ID，但其他一些标识符，如用户 ID 和组 ID，可能会继承自父进程。
> - **内存映射**：子进程会继承父进程的内存映射，包括共享库和动态内存分配。
> - **网络连接**：如果父进程有建立的网络连接，子进程可能会继承这些连接，这取决于具体的操作系统和网络 API。
> 
> 需要注意的是，虽然子进程继承了父进程的许多资源，但它们是两个独立的进程，拥有自己的地址空间和执行控制流。子进程的执行不会影响到父进程，除非它们通过某种方式进行进程间通信（IPC）。此外，操作系统通常提供了一些机制来控制子进程继承资源的行为，如在 Unix-like 系统中使用 fork 函数时配合 exec 系列函数来避免继承某些资源。

创建进程的原因：
- 终端用户登录：系统需要创建一个用户管理的进程
- 高级调度
- 系统处理用户程序的请求：运行处理进程
- 用户程序的应用请求

创建新进程时的操作：
- 分配 PID，申请一个空白的 PCB。**如果 PCB 申请失败，则创建失败**。
- 分配运行所需资源。**如果资源不足，则处于继续处于创建态**，等待资源，而不是创建失败。
- 初始化 PCB
- 插入就绪队列


<br/>

**进程终止**

引起进程终止的事件：
- 正常结束
- 异常结束
- 外界干预

终止进程操作：
- 根据 PCB 读取进程状态：
	- 如果处于运行态，这终止进程执行
	- 如果进程有子进程，则**通常将其所有子进程终止**
- 将进程所拥有的全部资源，归还给父进程或操作系统
- 将 PCB 从队列中删除


<br/>

**进程阻塞与唤醒**

调用**阻塞原语**进入阻塞态；使用**唤醒原语**将等待该事件的进程唤醒。


---

<br/>

### 进程通信

PV 操作时低级通信方式。高级通信方式是以**较高效率**传输**大量数据**的通信方式：

**共享存储**

通过一块可以直接访问的共享空间，进行数据交换，是三种方式中**速度最快**的一种。需要使用 PV 操作对共享空间的读写进行控制。
- 低级方式共享：基于数据结构
- 高级方式共享：基于存储区

通过系统调用实现。


<br/>

**消息传递**

进程之间数据交换的单位是**格式化**的消息。
- 直接通信方式：发送进程直接将消息发送给接收进程，将其挂在接收进程的消息缓冲队列上。
- 间接通信方式：发送到某个中间实体——信箱。广泛应用于计算机网络中。


<br/>

**管道通信**

管道是一个特殊类型的**文件**。
- 管道文件是一个固定大小的缓冲区。
- 数据在管道中**先进先出**。
- 一个管道只能进行**单向通信**，**管道中的数据一旦被读取，就释放空间**。
- 某个进程在对管道进行读写操作时，其他进程必须等待。
- **管道只能由创建进程所访问**， 子进程会继承父进程的管道，所以可以利用管道进行父子进程通信。

---


<br/>

### 线程与多线程模型

**线程基本概念**

在引入线程的计算机中，进程是资源分配的基本单位，线程是调度的基本单位。

同属一个进程的所有线程共享进程所拥有的所有资源。


<br/>

**进程线程比较**
- 同一进程的线程切换代价远低于进程切换。
- 同一个进程的所有线程可以并发执行。


<br/>

**线程属性**

 每一个线程有一个唯一的**标识符**和一个**线程控制块**，记录线程执行的寄存器和栈等现场。


<br/>

**线程组织与控制**

- 线程控制块
	- 线程标识符
	- 寄存器：程序计数器、状态寄存器、通用寄存器
	- 线程运行状态
	- 优先级
	- 专用存储区
	- 堆栈指针
- 线程创建
- 线程终止：**通常线程被终止后不立即释放占有的资源**。当进程中的其他线程执行力分离函数后，被终止线程才与资源分离，此时的资源可以被其他线程利用。


<br/>

**<span style="background:#fff88f">线程实现方式</span>**

- **用户级线程**：有关**线程管理的工作在用户态完成**，内核意识不到线程的存在，应用程序可以通过线程库设计多线程程序。
	- 调度依然是以进程为单位。
	- 进程中一个线程被阻塞，该进程所有线程都会被阻塞。
- **内核级线程**：有关**线程管理工作在内核态完成**。操作系统为每个内核级线程设置一个线程控制块。
	- 同一进程中的线程切换，需要从用户态转到核心态。
- 组合方式


<br/>

**多线程模型**
- 多对一模型：多个用户级线程映射到一个内核级线程。
- 一对一模型
- 多对多模型： $n$ 个用户级线程映射到 $m$ 个内核级线程 ( $n\ge m$ )。

---


<br/>


<br/>

## CPU 调度

### 调度的概念


**调度的层次**

- **高级调度**（作业调度）：从**外存**上处于后备队列的作业中挑选一个，分配必要的资源（内存、I/O 设备等），**建立相应的进程**。为进程活动做准备。
- **中级调度**（内存调度）：将暂时不能运行的进程调至外存等待（**挂起态**）；将具备运行条件的挂起进程重新调入内存。目的是为了**提高内存利用率**。
- **低级调度**（进程调度）：是进程正常活动起来。

---

<br/>

### 调度的实现

**调度程序**

- 排队器
- 分配器
- 上下文切换器

<br/>


**调度的时机**

不能进行进程的调度与切换到情况：
- 在处理中断的过程中
- 需要完全屏蔽中断的原子操作过程中


<br/>


**闲逛进程**

当系统中没有就绪的进程，就回调度闲逛进程，PID 为 0，优先级最低，不需要除 CPU 之外的资源（不会被阻塞）。


<br/>

**两种线程的调度**
- 用户级线程调度：线程切换在同一进程中进行，仅需少量机器指令
- 内核级线程调度：需要完整的上下文切换，导致若干数量级的延迟

---


<br/>

### 调度的目标

**CPU 利用率**

$$
CPU\text{利用率}=\frac{CPU\text{有效工作时间}}{CPU\text{有效工作时间}+CPU\text{空闲等待时间}}
$$


<br/>

**系统吞吐量**

单位时间内 CPU 完成的作业的数量。


<br/>

**周转时间**

$$
\text{周转时间}=\text{作业完成时间}-\text{作业提交时间}
$$
$$
\text{平均周转时间}=\frac{\text{周转时间之和}}{\text{作业数量}}
$$
$$
\text{带权周转时间}=\frac{\text{周转时间}}{\text{作业实际运行时间}}
$$


<br/>

**等待时间**

进程处于等待 CPU 的时间之和。


<br/>


**响应时间**

作业提交到系统首次响应所用的时间。

---

<br/>

### 典型调度算法

**先来先服务算法 FCFS**

每次从就绪队列中选择最先进入队列的进程。
- 不可剥夺算法
- 算法简单，但效率低
- 对于长作业有利，对短作业不利
- 有利于 CPU 繁忙型作业，不利于 I/O 繁忙型作业（不利于及时响应）

<br/>

**短作业优先调度算法 SJF**

从后辈队列中选择一个或几个估计运行时间最短的作业。对于长作业，存在饥饿现象。

区别于最短剩余时间优点调度算法，SJF 是基于进程预计的总执行时间来调度的，及时一个进程很快可以完成作业，但如果其总执行时间很长，优先级依然很低。


<br/>

**高响应比优先调度算法**

$$
\text{响应比}=\frac{\text{等待时间}+\text{要求服务时间}}{\text{要求服务时间}}
$$

克服了长作业的饥饿现象。


<br/>

**优先级调度算法**
- 静态优先级：优先级是在创建进程时就确定，在进程运行期间保持不变。
- 动态优先级

<br/>


**时间片轮转算法**

主要适用于分时系统。


<br/>

**多级反馈队列调度算法**
- 多个就绪队列，每个队列赋予不同优先级
- **在优先级越高的队列中，进程的时间片越小**。
- 在队列中采用 FCFS 算法。进程用完时间片就降级，放入优先级低一级的队列。
- 按队列优先级调度。


---


<br/>


<br/>


## 同步与互斥


### 同步与互斥的基本概念

**临界资源**

一次仅允许一个进程使用的资源称为临界资源。访问临界资源的代码称为**临界区**。

<br/>

**同步**

直接制约关系，作用是协调进程之间的**运行次序**。


<br/>

**互斥**

间接制约关系。实现临界区互斥必须遵循的准则：
- 空闲让进
- 忙则等待
- 有限等待
- 让权等待：**非必须**。当进程不能进入临界区，立即释放处理器。

---


<br/>

### 实现互斥的方法

**软件实现**

> **Peterson 算法**是一种经典的进程同步算法，它能够在没有额外硬件支持的情况下，通过软件逻辑保证**两个进程**之间的互斥访问共享资源。该算法的核心思想是利用两个标志位（flag 数组）和一个转折点（turn 变量）来控制两个进程的执行顺序，从而确保在任何时刻只有一个进程能够进入临界区。

- **flag 数组**：解决互斥访问问题。标识一个进程是否想要进入临界区。
- **turn 变量**：解决饥饿问题。当两个进程同时想要进入临界区时，turn 标识哪一个进程先进入临界区——先执行 turn 赋值语句的进程，先进入临界区（先赋值会被另一个进程覆盖，所以赋值赋的是另一个进程的编号）。

<br/>

**硬件实现**

- 中断屏蔽方法
	- 将关中断的权限交给用户不明智
	- 不适用于多处理器系统，将一个 CPU 关中断并不能阻止进程在其他 CPU 访问临界区
- TestAndSet
- Swap

两种硬件指令实现互斥方法都是**自旋锁**
- 不能实现让权等待，会一直执行 while 循环
- 调度选择的进程不一定拥有锁，可能导致饥饿问题
- 通常用于多处理系统，一个线程空转，不会影响其他线程执行
- 进程在等待锁期间，没有上下文切换，在上锁时间较短的情况下，等待代价不高

---

<br/>

### 信号量

信号量可以用来解决**互斥**与**同步**问题。

**整型信号量**

用于表示资源数量的整型量 S。

在资源数量不够时，一直空转等待。


<br/>

**记录型信号量**

有一个进程链表，等资源数量不够时，进程插入等待队列中，并自我阻塞。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-08-30_232051.jpg" width="500" />
</center>

当进行了资源的释放操作之后（`S.value++`），此时如果没有别的进程在等待，则资源数必然是大于零的，当资源数**小于等于** 0 时，说明有别的进程在等待，则从进程队列中取出一个并唤醒。


<br/>

**信号量实现互斥**

临界区同一时间最多只能有一个进程访问，所以资源数为 1。

```cpp
semaphore S=1;  // 资源数量为1

P(S);
进入临界区
V(S);
```


<br/>

**信号量实现同步**

同步关系级进程的执行需要有一定的次序。进程的某条语句必须等另一个进程执行完一条特定语句后才能执行。

可以将同步信号量 S 初值设置为 0，即开始没有资源，需要先执行那个进程执行到特定地方，才能产生这种资源。

---

<br/>


### 经典同步问题

**生产者-消费者问题**

- 对于缓冲区的操作时互斥的，可以使用一个信号量 mutex 实现，初值为 1。
- 生产者和消费者是协作关系：
	- 生产者需要空的缓冲区，生成满的缓冲区
	- 消费者需要满的缓冲区，生程空的缓冲区
	- 所以，设置两个信号量， full 初值为 0，empty 初值为 n。


<br/>

**读者-写者问题**

该问题的限定条件：
- 多个读者可以同时读
- 只能有一个写者写
- 一个写者完成操作之前不允许其他读者写者操作
- 写者执行操作之前，已有读者写者需要全部退出

方法一

可以只用一个锁 rw 来保证读者/写者互斥访问，可以使用一个计数器 count 来记录读者数量，当读者获得锁 rw 时，count++（对 count 的更新也需要加锁），当读者退出时 count--，当 cout 计数器为 0 时，才释放 rw 锁。

该方法会造成写者的饥饿问题。

方法二

当有写者申请锁时，应该禁止后续读进程的请求。

可以增加一个写锁 w，申请 rw 锁之前，必须先申请 w，当读者完成申请 rw 后，立即释放 w 锁。



<br/>

**哲学家就餐问题**

解决方法：
- 限定同时进餐的哲学家数量，n 个哲学家至多 n-1 个同时就餐。
- 改变某些哲学家的去筷子顺序。
- 当一名哲学家左右的筷子都可用是，才允许抓起筷子。即在给取筷子动作加锁。

---


<br/>

### 管程

**管程定义**

将共享资源抽象成一个数据结构，以及由该数据结构实施操作的一组过程 构成的 资源管理程序 就是管程，组成如下：
- 管程名称
- 管程内部共享数据结构的说明
- 对数据结构进行操作的一组过程（函数）
- 对共享数据结构设置初值的语句

管程将共享资源的操作封装起来，进程只有通过调用管程定义的过程才能访问共享资源。每次仅允许一个进程进入管程，各个进程串行执行过程内的过程。


<br/>

**条件变量**

没有值，仅仅实现排队等待功能。

---

## 死锁

### 死锁的概念

**死锁的定义**

多个进程因竞争而造成的一种僵局，相互等待对方手中的资源，使得各个进程被阻塞。


<br/>

**死锁与饥饿**

饥饿极进程在信号量内无穷等待的情况。与死锁的区别：
- 发生饥饿的进程可以只有一个；发生死锁的进程至少有两个。
- 发生饥饿的进程可能处于就绪态；发生死锁的进程只能处于阻塞态。


<br/>

**死锁产生的原因**

- 系统资源的竞争：是指对于不可剥夺资源的竞争。
- 进程推进顺序非法

系统资源不足不是死锁产生的原因。**系统资源不足只会造成饥饿现象**。


<br/>

**死锁产生的必要条件**
- 互斥
- 不可剥夺：进程获得的资源，不能被其他进程强行夺走，只能主动释放
- 请求并保持：持有至少一个资源，但又提出新的资源请求
- 循环等待


<br/>

**死锁的处理**
- 预防：破坏四个必要条件之中至少一个。限制比较严格，但实现比较简单，往往导致系统效率低，资源利用率低。
- 避免：在资源分配过程中，防止系统进入不安全状态。限制条件相对宽松，但是实现较为复杂。
- 检测以及解除：无须采用限制性措施，允许发生死锁。

---

<br/>

### 死锁预防

**破坏互斥条件**

允许资源共享使用。一般不太可行。


<br/>

**破坏不可剥夺条件**

在**获取不到所有所需的锁时，不会一直持有锁，而是放弃所有已经获得锁**，重新阐释获取，这种方式可能会导致其他问题：
- 活锁，当两个线程同时开始获取锁，但是获取锁的顺序相反，两个线程可能会一直重复获取锁的工作，代码一直没有进展，所以称为活锁，解决方案——在循环结束的时候随机等待一个时间，之后再重复动作，降低线程之间的重复干扰。
- 封装，如果一个锁是封装在函数内部的，跳转回开头处的动作很难实现。

释放资源会造成前一阶段的工作失效，**常用于易于保存和恢复的资源**，如 CPU 的寄存器和内存资源。


<br/>

**破坏请求并保持条件**

核心思想是一次性申请全部资源，实现方法：
- 预先静态分配：在运行前一次性申请完所需要的全部资源，在资源未满足时，不投入运行。
- 只获得运行初期所需的资源，便开始运行，运行过程逐步释放持有的**所有**资源，才能请求新的资源。


<br/>

**破坏循环等待条件**

规定每个进行必须按照编号增大的顺序请求资源。

---

<br/>

### 死锁避免

在资源分配过程中，分析分配是否会带来死锁风险，只有在没有风险的情况下，才分配资源。

**系统安全状态**

系统按照某种进程推进顺序，为每个进程分配所有所需资源，让每个进程可以串行顺利完成。

系统处于安全状态**一定不会**发生死锁，系统处于不安全状态，**可能**发生死锁。


<br/>

**银行家算法**

- need=max-allocation
- work 工作向量初始值必须是当前可用的资源数。
- work 工作向量使用 allocation 矩阵中某行更新，而不是 need 矩阵。


---

<br/>

### 死锁检测与解除

**死锁检测**

使用**资源分配图**来检测死锁。检测过程：
- 找到一个不阻塞不孤立的进程。判断一个进程是否阻塞，主要是看能够满足其请求的资源。
- 释放找到的进程的所有资源：即消去图上与该进程相连的所有边。

如果图中所有边可以消去，则图**可完全化简**。

**死锁定理**：S 为死锁当且仅当 S 状态的资源分配图是不可完全化简的。


<br/>

**死锁解除**

- 资源剥夺：挂起某些死锁进程，抢占其资源。
- 撤销进程：撤销部分或全部死锁进程。
- 进程回退：一个或多个死锁进程回退到足以回避死锁的地步。该过程是进程**自愿**释放。需要系统保持进程历史信息，设置还原点。

---

<br/>


<br/>


<br/>


# 内存管理

