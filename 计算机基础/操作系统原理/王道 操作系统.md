
# 计算机系统概述

## 操作系统基本概念

### 操作系统概念

操作系统管理计算机硬件资源，为应用程序提供基础，充当计算机硬件与用户之间的中介。

操作系统是**程序集合**，是计算机系统中**最基本的系统软件**。

> 系统软件是指直接控制和管理计算机硬件资源、提供用户与计算机交互界面以及为应用软件提供运行环境的软件。它包括操作系统、设备驱动程序、诊断工具、服务器软件、窗口系统和实用程序等。


---


<br/>

### 操作系统特征

**并发和共享是最基本的特征**
- 共享以并发为基础
- 若不能对资源共享进行有效管理，会影响程序的并发执行

<br/>


**并发**

多个事件在同一时间间隔内发生。

<br/>


**共享**
- 互斥共享：**一段时间**只允许一个进程访问。打印机、磁带机。
- 同时共享：磁盘设备。

<br/>


**虚拟**
- 时分复用技术：例如多道程序设计技术
- 空分复用技术：虚拟存储器技术

<br/>


**异步**

进程的执行以不可预知的速度前进。

---

<br/>

### 操作系统目的与功能

**计算机系统资源的管理者**

- 处理机管理：处理机的分配和运行以进程（线程）为单位，可以归结为进程管理
- 存储器管理：内存的管理
- 文件管理
- 设备管理

<br/>


**用户与计算机硬件系统之间的接口**

- 命令接口：
	- 脱机命令接口：一条命令一条命令的输入，然后执行、反馈。交互性
	- 联机命令接口
- 程序接口：系统调用

<br/>


**计算机资源的扩充**

- 裸机
- 扩充机器（虚拟机）：覆盖了软件的机器

---

<br/>


<br/>



## 操作系统发展历程

**手工阶段**

无操作系统

<br/>


**批处理阶段（操作系统开始出现）**
- 单道批处理：**内存中仅存放一道作业**
- 多道批处理：内存中可以存放多道作业，在一道作业阻塞时，另一道作业执行。

<br/>


**分时操作系统**

按照时间片轮转执行

<br/>


**实时操作系统**
- 硬实时：动作必须在规定时间（或时间段）内**发生**
- 软实时：可以偶尔违反时间规定，而不引起永久性损害。

<br/>


**网络操作系统与分布系统操作系统**
- 网络操作系统：强调网络中各种资源的共享和各台计算机之间的通信。
- 分布式操作系统：**一个任务**可以分布在几台计算上，**并行工作**，协作完成。

---

<br/>


<br/>



## 操作系统运行环境

### 处理器运行模式

**特权指令与非特权指令**
- 特权指令：只能在内核态执行的指令，I/O 指令、关中断指令、内存清零指令、存取用于内存保护的寄存器、送 PSW 到程序状态字寄存器。
- 非特权指令：这类指令不会涉及对系统状态或资源的直接修改。

> 这里的指令通常指的是 汇编指令 或 机器指令。这些指令直接与处理器交互，控制硬件的操作。
> 
> 访存指令 load（加载指令）一般属于 非特权指令。虽然 load 指令本身是非特权指令，但用户程序只能访问自己拥有权限的内存区域。如果试图通过 load 指令访问未授权的内存地址（比如内核空间），处理器会触发异常，防止非法操作。


<br/>

**用户态与内核态**

- 用户态：应用程序需要请求操作系统服务时，通过**访管指令**（非特权指令）。
- 内核态：操作系统**内核程序运行在内核态**。由内核态返回用户态，一般通过**中断返回指令**。


> 
虽然用户态与核心态之间的切换在硬件层面只是通过设置寄存器标志来完成，但实际的开销远不止这一点。
> - 保存和恢复上下文：从用户态切换到核心态时，系统需要保存当前进程的上下文。
> - 缓存失效：访问不同的内存区域（如内核代码和用户代码、内核数据和用户数据），可能会导致 Cache 和快表失效。
> - 内存映射切换：内核态和用户态可能使用不同的页表（管理内存的映射）。在态切换时，可能需要调整页表，导致页表的更新或刷新。这也增加了系统的开销。


<br/>

**操作系统内核**

- 时钟管理
- 中断机制：只有一小部分属于内核，辅助保护和恢复中断现场的信息，转移控制权。
- 原语
- 系统控制的数据结构 以及 处理

---

<br/>

### 中断和异常的概念

当发生中断和异常时，CPU 会进入内核态（**通过硬件实现**，例如，通过一个特殊的寄存器了表示 CPU 所处的工作状态）。

<br/>

中断（外中断）：由与指令指令执行无关的外部事件引起，需要通过请求线来通知 CPU。
- 可屏蔽中断：通过 INTR 线发出请求。
- 不可屏蔽中断：通过 NMI 线发出请求，通常是紧急的硬件故障，如电源掉电。

异常（内中断）：由于指令的执行引起
- 故障：非法操作码、除零、缺页
- 自陷：条件陷阱、系统调用
- 终止：硬件故障，控制器出错、存储器校验错

---

<br/>

### 系统调用

凡是与**系统资源有关**的操作（存储分配、I/O 传输、文件管理）都必须通过系统调用方式向操作系统提出服务请求。系统调用的处理由于操作系统**内核程序**完成，在内核态。

<br/>


**系统调用的处理过程**
- 系统调用号和所需参数压入栈
- 陷入指令，用户态转为内核态
- 保护被中断进程的现场
- 转入相应的系统调用处理程序（根据系统调用号来找到入口地址）
- 恢复现场
- 返回被中断进程

---


<br/>


<br/>

## 操作系统结构

**分层法**

底层为硬件，顶层为用户接口。**每层只能调用紧挨其的低一层的服务**。

优点：
- 方便系统调试和验证。一层一层的调试，当某一层发生错误，不用检查底下的层。
- 易于扩充和维护，增加、修改、替换某一层时，只要不改变接口，就不会影响其他层。

缺点：
- 定义各层比较困难
- 效率较差：没执行一个功能要从上向下穿过多层


<br/>

**模块化**

按照功能划分为具有一定独立性的模块。

优点：
- 提高操作系统设计的准确性、可理解性、可维护性
- 增强操作系统的可适应性
- 操作操作系统开发过程

缺点：
- 模块间接口规定很难满足对接口的实际需求
- 各模块设计者齐头并进，决定无法建立在上一个已验证的正确基础之上


<br/>

**宏内核**

将系统**主要功能模块**作为一个紧密联系的整体运行在核心态。

目前主流的操作系统都是基于宏内核的架构（并非纯粹的宏内核，而是吸收了微内核优点的混合内核）。


<br/>

**微内核**

将内核中**最基本的功能**留在内核，其余移到用户态执行，移出内核的操作系统代码根据分层原则被划分为若干**服务程序**。**服务程序之间借助微内核进行通信**。

微内核包含：
- 与硬件密切相关的部分
- 较基本的功能
- 客户与服务器之间的通信。提供消息传递机制。

微内核功能：
- 进程管理。微内核之外有进程管理服务器，用于对用户进程进行分类，确定优先级。
- 低级存储器管理：最基本的管理机制，如实现逻辑地址到物理地址转换的页表机制和地址变换机制。
- 中断和陷入处理：捕获发生的中断或陷入事件，识别之后，交给对应的服务程序进行处理。

微内核特点：
- 拓展性与灵活性
- 可靠性与安全性
- 可移植性：与硬件有关的代码放在内核
- 分布式计算：采用消息传递机制，很好支持分布式和网络系统
- 存在性能问题：频繁在核心态和用户态之间进行切换

微内核在实时、工业、航空以及军事应用中特别流行。


<br/>

**外核**

外核程序运行在内核态，负责对硬件资源进行分配、回收、保护。

---


<br/>


<br/>


## 操作系统引导

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-08-26_111206.png" width="600" />
</center>


---

<br/>


<br/>

## 虚拟机

**第一类虚拟机管理程序**

虚拟管理程序就像是操作系统，而虚拟机像是一个进程。

当虚拟机操作系统执行了一条内核态才运行执行的指令，陷入虚拟机管理程序，在支持虚拟化的 CPU 上，检查指令是由系统执行还是用户执行：
- 系统执行：虚拟机管理程序安排指令的正确执行。
- 用户执行：模拟真实硬件面对用户态执行敏感指令的行为。

在不支持虚拟化的 CPU 上，不会直接执行虚拟机的敏感指令，而是转为对于虚拟机管理程序的调用，由虚拟机管理程序模拟指令的功能。


<br/>

**第二类虚拟机管理程序**

虚拟机管理程序本身像是一个进程， 依赖于 宿主操作系统分配和调度资源。

VMware Workstation 是 x 86 平台上收个第二类虚拟机管理程序。


---

<br/>


<br/>


<br/>

# 进程 与 线程

## 进程与线程介绍

### 进程概念与特征

**进程的概念**

在多道程序环境下，运行多个程序并发执行。程序失去封闭性，具有间断性和不可再现性。

> **封闭性**：执行结果只取决于进程本身，不受外界影响。

> **不可再现性**：并发进程存在相互竞争与制约，每次执行结果可能不一样。


因此引入了进程的概念，**进程实体**由三部分组成：
- 进程控制块 PCB：描述进程的基本情况和运行状态的数据结构
- 程序段
- 数据段

进程是进程实体的运行过程，是系统进行**资源分配**和**调度**的基本单位。


<br/>

**进程的特征**

- 动态性：进程是程序的一次执行
- 并发性
- 独立性
- 异步性

---

<br/>

### 进程的组成

**进程控制块 PCB**

PCB 在创建之后常驻于内存，是进程存在的唯一标志，系统通过 PCB 对进程进行控制（系统通过 PCB 才能感知到该进程的存在），PCB 的组成如下：
- 进程描述信息：PID，UID（用户标识符，主要为共享和保护提供服务）
- 进程控制与管理信息：进程当前状态、优先级、代码入口地址、程序外存地址、CPU 占用时间等
- 资源分配清单：代码段指针、数据段指针、堆栈段指针
- 处理机相关信息：CPU 各寄存器的值

各个进程 PCB 的组织方式：
- 链接方式：相同状态的 PCB 链接成一个列表
- 索引方式：相同状态的 PCB 组织在一个索引表里面


<br/>

**程序段**

即代码段。多个进程可以运行同一个程序。


<br/>

**数据段**

加工处理的原始数据；执行时产生的中间与最终结果。


> <center>
> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-08-30_095205.jpg" width="500" />
> </center>

> - **栈区（stack**）: 存放函数形参和局部变量（auto 类型），由编译器自动分配和释放。
> - **堆区（heap）**: 该区由程序员申请后使用，需要手动释放否则会造成内存泄漏。如果程序员没有手动释放，那么程序结束时可能由 OS 回收。
> - **全局/静态存储区**：存放全局变量和静态变量（包括静态全局变量与静态局部变量），初始化的全局变量和静态局部变量放在一块，未初始化的放在另一块。
> - **文字常量区**：常量在统一运行被创建，常量区的内存是只读的，程序结束后由系统释放。
> - **程序代码区**：存放程序的二进制代码，内存由系统管理

> text 段在内存中被映射为只读，但 date 段与 bss 段是可写的
> - **text 段**：代码段，就是放程序代码的，编译时确定，只读。
> - **date 段**：存放在编译阶段（而非运行时）就能确定的数据，可读可写。也就是通常所说的静态存储区，赋了初值的全局变量和赋初值的静态变量存放在这个区域，常量也存在这个区域。
> - **bss 段**：已经定义但**没赋初值**的全局变量和静态变量存放在这个区域。

---

<br/>

### 进程的状态 与 转换
通常有 5 种状态，运行、就绪、阻塞是 **基本状态**

- 运行态：进程正在 CPU 运行。
- 就绪态：获得了除了 CPU 时间片以外的一切所需资源，等待调度运行。
- 阻塞态：等待某个资源（不包括 CPU 时间片）可以用，或者 I/O 完成。
- 创建态：正在被创建，需要完成以下步骤
	- 申请空白 PCB
	- 向 PCB 写入信息
	- 分配运行时所需资源
	- 将进程转入就绪态，并插入队列
- 终止态


<br/>

进程状态转换：
- 就绪  ---> 运行：被调度，获得 CPU 资源
- 运行  ---> 就绪：时间片用完，或者时间片被跟高优先级进程抢占
- 运行  ---> 阻塞：这是**进程的主动行为**。进程执行 wait 操作，进入休眠，或者等待 I/O 
- 阻塞  ---> 就绪：**进程的被动行为**，需要其他进程协助。

---

<br/>

### 进程控制

一般将进程控制用的程序段称为**原语**。

**进程创建**

进程可以创建子进程，子进程继承父进程所拥有的资源，当子进程被撤销时，获得的资源归还给父进程，父进程撤销时，通常会撤销其所有子进程。

> 当一个进程（父进程）创建一个新的进程（子进程）时，子进程会继承父进程的以下资源：
> 
> - **文件描述符**：子进程会继承父进程打开的所有文件描述符。这意味着子进程可以访问父进程能够访问的所有文件和设备。
> - **环境变量**：子进程继承父进程的环境变量，这包括操作系统提供的各种环境设置，如语言环境、用户信息等。
> - **执行代码**：子进程继承父进程的程序代码，即它们执行的是相同的程序。
> - **堆和栈**：子进程会**复制**父进程的堆和栈的初始状态，但它们是**独立的**，子进程的任何修改都不会影响到父进程。
> - **全局变量**：如果父进程有全局变量，子进程也会继承这些变量的初始值，但它们在子进程中的修改**不会影响到父进程中的全局变量**。
> - **信号处理**：子进程会继承父进程的信号处理设置。
> - **进程 ID**：子进程会获得一个新的进程 ID，但其他一些标识符，如用户 ID 和组 ID，可能会继承自父进程。
> - **内存映射**：子进程会继承父进程的内存映射，包括共享库和动态内存分配。
> - **网络连接**：如果父进程有建立的网络连接，子进程可能会继承这些连接，这取决于具体的操作系统和网络 API。
> 
> 需要注意的是，虽然子进程继承了父进程的许多资源，但它们是两个独立的进程，拥有自己的地址空间和执行控制流。子进程的执行不会影响到父进程，除非它们通过某种方式进行进程间通信（IPC）。此外，操作系统通常提供了一些机制来控制子进程继承资源的行为，如在 Unix-like 系统中使用 fork 函数时配合 exec 系列函数来避免继承某些资源。

创建进程的原因：
- 终端用户登录：系统需要创建一个用户管理的进程
- 高级调度
- 系统处理用户程序的请求：运行处理进程
- 用户程序的应用请求

创建新进程时的操作：
- 分配 PID，申请一个空白的 PCB。**如果 PCB 申请失败，则创建失败**。
- 分配运行所需资源。**如果资源不足，则处于继续处于创建态**，等待资源，而不是创建失败。
- 初始化 PCB
- 插入就绪队列


<br/>

**进程终止**

引起进程终止的事件：
- 正常结束
- 异常结束
- 外界干预

终止进程操作：
- 根据 PCB 读取进程状态：
	- 如果处于运行态，这终止进程执行
	- 如果进程有子进程，则**通常将其所有子进程终止**
- 将进程所拥有的全部资源，归还给父进程或操作系统
- 将 PCB 从队列中删除


<br/>

**进程阻塞与唤醒**

调用**阻塞原语**进入阻塞态；使用**唤醒原语**将等待该事件的进程唤醒。


---

<br/>

### 进程通信

PV 操作时低级通信方式。高级通信方式是以**较高效率**传输**大量数据**的通信方式：

**共享存储**

通过一块可以直接访问的共享空间，进行数据交换，是三种方式中**速度最快**的一种。需要使用 PV 操作对共享空间的读写进行控制。
- 低级方式共享：基于数据结构
- 高级方式共享：基于存储区

通过系统调用实现。


<br/>

**消息传递**

进程之间数据交换的单位是**格式化**的消息。
- 直接通信方式：发送进程直接将消息发送给接收进程，将其挂在接收进程的消息缓冲队列上。
- 间接通信方式：发送到某个中间实体——信箱。广泛应用于计算机网络中。


<br/>

**管道通信**

管道是一个特殊类型的**文件**。
- 管道文件是一个固定大小的缓冲区。
- 数据在管道中**先进先出**。
- 一个管道只能进行**单向通信**，**管道中的数据一旦被读取，就释放空间**。
- 某个进程在对管道进行读写操作时，其他进程必须等待。
- **管道只能由创建进程所访问**， 子进程会继承父进程的管道，所以可以利用管道进行父子进程通信。

---


<br/>

### 线程与多线程模型

**线程基本概念**

在引入线程的计算机中，进程是资源分配的基本单位，线程是调度的基本单位。

同属一个进程的所有线程共享进程所拥有的所有资源。


<br/>

**进程线程比较**
- 同一进程的线程切换代价远低于进程切换。
- 同一个进程的所有线程可以并发执行。


<br/>

**线程属性**

 每一个线程有一个唯一的**标识符**和一个**线程控制块**，记录线程执行的寄存器和栈等现场。


<br/>

**线程组织与控制**

- 线程控制块
	- 线程标识符
	- 寄存器：程序计数器、状态寄存器、通用寄存器
	- 线程运行状态
	- 优先级
	- 专用存储区
	- 堆栈指针
- 线程创建
- 线程终止：**通常线程被终止后不立即释放占有的资源**。当进程中的其他线程执行力分离函数后，被终止线程才与资源分离，此时的资源可以被其他线程利用。


<br/>

**<span style="background:#fff88f">线程实现方式</span>**

- **用户级线程**：有关**线程管理的工作在用户态完成**，内核意识不到线程的存在，应用程序可以通过线程库设计多线程程序。
	- 调度依然是以进程为单位。
	- 进程中一个线程被阻塞，该进程所有线程都会被阻塞。
- **内核级线程**：有关**线程管理工作在内核态完成**。操作系统为每个内核级线程设置一个线程控制块。
	- 同一进程中的线程切换，需要从用户态转到核心态。
- 组合方式


<br/>

**多线程模型**
- 多对一模型：多个用户级线程映射到一个内核级线程。
- 一对一模型
- 多对多模型： $n$ 个用户级线程映射到 $m$ 个内核级线程 ( $n\ge m$ )。

---


<br/>


<br/>

## CPU 调度

### 调度的概念


**调度的层次**

- **高级调度**（作业调度）：从**外存**上处于后备队列的作业中挑选一个，分配必要的资源（内存、I/O 设备等），**建立相应的进程**。为进程活动做准备。
- **中级调度**（内存调度）：将暂时不能运行的进程调至外存等待（**挂起态**）；将具备运行条件的挂起进程重新调入内存。目的是为了**提高内存利用率**。
- **低级调度**（进程调度）：是进程正常活动起来。

---

<br/>

### 调度的实现

**调度程序**

- 排队器
- 分配器
- 上下文切换器

<br/>


**调度的时机**

不能进行进程的调度与切换到情况：
- 在处理中断的过程中
- 需要完全屏蔽中断的原子操作过程中


<br/>


**闲逛进程**

当系统中没有就绪的进程，就回调度闲逛进程，PID 为 0，优先级最低，不需要除 CPU 之外的资源（不会被阻塞）。


<br/>

**两种线程的调度**
- 用户级线程调度：线程切换在同一进程中进行，仅需少量机器指令
- 内核级线程调度：需要完整的上下文切换，导致若干数量级的延迟

---


<br/>

### 调度的目标

**CPU 利用率**

$$
CPU\text{利用率}=\frac{CPU\text{有效工作时间}}{CPU\text{有效工作时间}+CPU\text{空闲等待时间}}
$$


<br/>

**系统吞吐量**

单位时间内 CPU 完成的作业的数量。


<br/>

**周转时间**

$$
\text{周转时间}=\text{作业完成时间}-\text{作业提交时间}
$$
$$
\text{平均周转时间}=\frac{\text{周转时间之和}}{\text{作业数量}}
$$
$$
\text{带权周转时间}=\frac{\text{周转时间}}{\text{作业实际运行时间}}
$$


<br/>

**等待时间**

进程处于等待 CPU 的时间之和。


<br/>


**响应时间**

作业提交到系统首次响应所用的时间。

---

<br/>

### 典型调度算法

**先来先服务算法 FCFS**

每次从就绪队列中选择最先进入队列的进程。
- 不可剥夺算法
- 算法简单，但效率低
- 对于长作业有利，对短作业不利
- 有利于 CPU 繁忙型作业，不利于 I/O 繁忙型作业（不利于及时响应）

<br/>

**短作业优先调度算法 SJF**

从后辈队列中选择一个或几个估计运行时间最短的作业。对于长作业，存在饥饿现象。

区别于最短剩余时间优点调度算法，SJF 是基于进程预计的总执行时间来调度的，及时一个进程很快可以完成作业，但如果其总执行时间很长，优先级依然很低。


<br/>

**高响应比优先调度算法**

$$
\text{响应比}=\frac{\text{等待时间}+\text{要求服务时间}}{\text{要求服务时间}}
$$

克服了长作业的饥饿现象。


<br/>

**优先级调度算法**
- 静态优先级：优先级是在创建进程时就确定，在进程运行期间保持不变。
- 动态优先级

<br/>


**时间片轮转算法**

主要适用于分时系统。


<br/>

**多级反馈队列调度算法**
- 多个就绪队列，每个队列赋予不同优先级
- **在优先级越高的队列中，进程的时间片越小**。
- 在队列中采用 FCFS 算法。进程用完时间片就降级，放入优先级低一级的队列。
- 按队列优先级调度。


---


<br/>


<br/>


## 同步与互斥


### 同步与互斥的基本概念

**临界资源**

一次仅允许一个进程使用的资源称为临界资源。访问临界资源的代码称为**临界区**。

<br/>

**同步**

直接制约关系，作用是协调进程之间的**运行次序**。


<br/>

**互斥**

间接制约关系。实现临界区互斥必须遵循的准则：
- 空闲让进
- 忙则等待
- 有限等待
- 让权等待：**非必须**。当进程不能进入临界区，立即释放处理器。

---


<br/>

### 实现互斥的方法

**软件实现**

> **Peterson 算法**是一种经典的进程同步算法，它能够在没有额外硬件支持的情况下，通过软件逻辑保证**两个进程**之间的互斥访问共享资源。该算法的核心思想是利用两个标志位（flag 数组）和一个转折点（turn 变量）来控制两个进程的执行顺序，从而确保在任何时刻只有一个进程能够进入临界区。

- **flag 数组**：解决互斥访问问题。标识一个进程是否想要进入临界区。
- **turn 变量**：解决饥饿问题。当两个进程同时想要进入临界区时，turn 标识哪一个进程先进入临界区——先执行 turn 赋值语句的进程，先进入临界区（先赋值会被另一个进程覆盖，所以赋值赋的是另一个进程的编号）。

<br/>

**硬件实现**

- 中断屏蔽方法
	- 将关中断的权限交给用户不明智
	- 不适用于多处理器系统，将一个 CPU 关中断并不能阻止进程在其他 CPU 访问临界区
- TestAndSet
- Swap

两种硬件指令实现互斥方法都是**自旋锁**
- 不能实现让权等待，会一直执行 while 循环
- 调度选择的进程不一定拥有锁，可能导致饥饿问题
- 通常用于多处理系统，一个线程空转，不会影响其他线程执行
- 进程在等待锁期间，没有上下文切换，在上锁时间较短的情况下，等待代价不高

---

<br/>

### 信号量

信号量可以用来解决**互斥**与**同步**问题。

**整型信号量**

用于表示资源数量的整型量 S。

在资源数量不够时，一直空转等待。


<br/>

**记录型信号量**

有一个进程链表，等资源数量不够时，进程插入等待队列中，并自我阻塞。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-08-30_232051.jpg" width="500" />
</center>

当进行了资源的释放操作之后（`S.value++`），此时如果没有别的进程在等待，则资源数必然是大于零的，当资源数**小于等于** 0 时，说明有别的进程在等待，则从进程队列中取出一个并唤醒。


<br/>

**信号量实现互斥**

临界区同一时间最多只能有一个进程访问，所以资源数为 1。

```cpp
semaphore S=1;  // 资源数量为1

P(S);
进入临界区
V(S);
```


<br/>

**信号量实现同步**

同步关系级进程的执行需要有一定的次序。进程的某条语句必须等另一个进程执行完一条特定语句后才能执行。

可以将同步信号量 S 初值设置为 0，即开始没有资源，需要先执行那个进程执行到特定地方，才能产生这种资源。

---

<br/>


### 经典同步问题

**生产者-消费者问题**

- 对于缓冲区的操作时互斥的，可以使用一个信号量 mutex 实现，初值为 1。
- 生产者和消费者是协作关系：
	- 生产者需要空的缓冲区，生成满的缓冲区
	- 消费者需要满的缓冲区，生程空的缓冲区
	- 所以，设置两个信号量， full 初值为 0，empty 初值为 n。


<br/>

**读者-写者问题**

该问题的限定条件：
- 多个读者可以同时读
- 只能有一个写者写
- 一个写者完成操作之前不允许其他读者写者操作
- 写者执行操作之前，已有读者写者需要全部退出

方法一

可以只用一个锁 rw 来保证读者/写者互斥访问，可以使用一个计数器 count 来记录读者数量，当读者获得锁 rw 时，count++（对 count 的更新也需要加锁），当读者退出时 count--，当 cout 计数器为 0 时，才释放 rw 锁。

该方法会造成写者的饥饿问题。

方法二

当有写者申请锁时，应该禁止后续读进程的请求。

可以增加一个写锁 w，申请 rw 锁之前，必须先申请 w，当读者完成申请 rw 后，立即释放 w 锁。



<br/>

**哲学家就餐问题**

解决方法：
- 限定同时进餐的哲学家数量，n 个哲学家至多 n-1 个同时就餐。
- 改变某些哲学家的去筷子顺序。
- 当一名哲学家左右的筷子都可用是，才允许抓起筷子。即在给取筷子动作加锁。

---


<br/>

### 管程

**管程定义**

将共享资源抽象成一个数据结构，以及由该数据结构实施操作的一组过程 构成的 资源管理程序 就是管程，组成如下：
- 管程名称
- 管程内部共享数据结构的说明
- 对数据结构进行操作的一组过程（函数）
- 对共享数据结构设置初值的语句

管程将共享资源的操作封装起来，进程只有通过调用管程定义的过程才能访问共享资源。每次仅允许一个进程进入管程，各个进程串行执行过程内的过程。


<br/>

**条件变量**

没有值，仅仅实现排队等待功能。

---

## 死锁

### 死锁的概念

**死锁的定义**

多个进程因竞争而造成的一种僵局，相互等待对方手中的资源，使得各个进程被阻塞。


<br/>

**死锁与饥饿**

饥饿极进程在信号量内无穷等待的情况。与死锁的区别：
- 发生饥饿的进程可以只有一个；发生死锁的进程至少有两个。
- 发生饥饿的进程可能处于就绪态；发生死锁的进程只能处于阻塞态。


<br/>

**死锁产生的原因**

- 系统资源的竞争：是指对于不可剥夺资源的竞争。
- 进程推进顺序非法

系统资源不足不是死锁产生的原因。**系统资源不足只会造成饥饿现象**。


<br/>

**死锁产生的必要条件**
- 互斥
- 不可剥夺：进程获得的资源，不能被其他进程强行夺走，只能主动释放
- 请求并保持：持有至少一个资源，但又提出新的资源请求
- 循环等待


<br/>

**死锁的处理**
- 预防：破坏四个必要条件之中至少一个。限制比较严格，但实现比较简单，往往导致系统效率低，资源利用率低。
- 避免：在资源分配过程中，防止系统进入不安全状态。限制条件相对宽松，但是实现较为复杂。
- 检测以及解除：无须采用限制性措施，允许发生死锁。

---

<br/>

### 死锁预防

**破坏互斥条件**

允许资源共享使用。一般不太可行。


<br/>

**破坏不可剥夺条件**

在**获取不到所有所需的锁时，不会一直持有锁，而是放弃所有已经获得锁**，重新阐释获取，这种方式可能会导致其他问题：
- 活锁，当两个线程同时开始获取锁，但是获取锁的顺序相反，两个线程可能会一直重复获取锁的工作，代码一直没有进展，所以称为活锁，解决方案——在循环结束的时候随机等待一个时间，之后再重复动作，降低线程之间的重复干扰。
- 封装，如果一个锁是封装在函数内部的，跳转回开头处的动作很难实现。

释放资源会造成前一阶段的工作失效，**常用于易于保存和恢复的资源**，如 CPU 的寄存器和内存资源。


<br/>

**破坏请求并保持条件**

核心思想是一次性申请全部资源，实现方法：
- 预先静态分配：在运行前一次性申请完所需要的全部资源，在资源未满足时，不投入运行。
- 只获得运行初期所需的资源，便开始运行，运行过程逐步释放持有的**所有**资源，才能请求新的资源。


<br/>

**破坏循环等待条件**

规定每个进行必须按照编号增大的顺序请求资源。

---

<br/>

### 死锁避免

在资源分配过程中，分析分配是否会带来死锁风险，只有在没有风险的情况下，才分配资源。

**系统安全状态**

系统按照某种进程推进顺序，为每个进程分配所有所需资源，让每个进程可以串行顺利完成。

系统处于安全状态**一定不会**发生死锁，系统处于不安全状态，**可能**发生死锁。


<br/>

**银行家算法**

- need=max-allocation
- work 工作向量初始值必须是当前可用的资源数。
- work 工作向量使用 allocation 矩阵中某行更新，而不是 need 矩阵。


---

<br/>

### 死锁检测与解除

**死锁检测**

使用**资源分配图**来检测死锁。检测过程：
- 找到一个不阻塞不孤立的进程。判断一个进程是否阻塞，主要是看能够满足其请求的资源。
- 释放找到的进程的所有资源：即消去图上与该进程相连的所有边。

如果图中所有边可以消去，则图**可完全化简**。

**死锁定理**：S 为死锁当且仅当 S 状态的资源分配图是不可完全化简的。


<br/>

**死锁解除**

- 资源剥夺：挂起某些死锁进程，抢占其资源。
- 撤销进程：撤销部分或全部死锁进程。
- 进程回退：一个或多个死锁进程回退到足以回避死锁的地步。该过程是进程**自愿**释放。需要系统保持进程历史信息，设置还原点。

---

<br/>


<br/>


<br/>


# 内存管理

## 内存管理概念

### 内存管理啊基本原理与要求

内存管理功能
- 内存空间回收与分配
- 地址转换
- 内存空间扩充
- 内存共享
- 存储保护

**程序链接与装入**
- **编译**：将程序编译成若干目标文件，其中使用的地址是相对地址。
- **链接**：将目标文件和所需库函数链接成为一个可执行文件。链接过程会修改相对地址，或直接改成物理地址，或是改成逻辑地址。根据链接时间不同，分为：
	- **静态链接**：运行之前，将所有模块链接，该过程需要修改相对地址
	- **装入时动态链接**：边装入边链接
	- **运行时动态链接**：执行中需要某个模块，才链接，未用到的模块不调入内存
- **装入**：将程序装入内存运行。
	- **绝对装入**：只使用单道程序环境，在编译时知道将放到内存哪个位置，编译程序产生绝对地址的目标代码。
	- **可重定位装入（静态重定位**）：链接之后使用的地址是相对于始址（通常从 0 开始），装入时要根据装入位置修改相对地址（即 重定位）。**地址转换在装入时一次性完成**：
		- 运行期间程序不能再内存中移动
		- 程序的存储空间必须是连续的
		- 不能申请内存空间
	- **动态运行时装入（动态重定位）**：装入内存的程序的地址是相对地址，在程序执行过程中，每次访问内存之前进行地址转换。需要一个**重定位寄存器**，存放当前运行程序的起始物理位置。
		- 可以将程序分配到不连续存储空间
		- 可以动态申请分配内存
		- 便于程序段共享


<br/>

**逻辑地址和物理地址**

地址重定位，在相关硬件协助下（内存管理单元 MMU、页表寄存器）完成自动完成。


<br/>

**进程的内存映像**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-09-01_094552.jpg" width="500" />
</center>

- .init：程序初始化函数
- .text：程序机器代码
- .rodata：只读数据
- .data：已初始化全局/静态 变量
- .bss：为初始化或所有初始化为 0 的全局/静态 变量


<br/>


**内存保护**

两种方法：
- 上下限寄存器
- 从重定位寄存器（基地址，起始物理地址）和界地址寄存器（**最大逻辑地址**）：加载这两个寄存器必须使用特权指令。


<br/>

**内存共享**

**只读**区域才能共享。

**可重入代码**：允许多个进程同时访问，但是不允许修改的代码。


---

<br/>

### 连续分配管理

为一个用户程序分配一个**连续**的内存空间。

**单一连续分配**

内存分为系统区（通常在低地址）和用户区。用户区内存仅仅有一道程序独享。

<br/>

**固定分区分配**

- 分区大小相等
- 分区大小不相等

建立一张**分片区使用表**。通常按分区大小排队。

- 程序可能太大，放不进任何一个分区
- 程序小于给定分区，产生内部碎片
- 无外部碎片


<br/>

**动态分区分配**

空闲分区链的合并，合并之后需要根据情况决定是否排序：
- 有一个相邻空闲分区：修改已有的空闲分区
- 有两个（左右）相邻空闲分区：修改其中一个，并删除另一个

分配算法
- 顺序分配
	- 首次适应
	- 邻近使用（循环首次适应）
	- 最佳适应：**产生最多外部碎片（内存碎片）**
	- 最坏适应：导致没有大分区可用
- 索引搜索
	- 快速适应：分为若干种固定大小的分区，相同大小分区放入一个分区链表中
	- 伙伴系统
	- 哈希算法：分区大小-对应分区链表头指针

---

<br/>

### 基本分页存储管理

是否需要将作业所有页面都装入内存才能运行：
- 基本分页存储管理
- 请求分页

要点：
- **无外部碎片**，产生内部碎片对于进程来说也是相对较小。
- 在多级页表内存管理中，**最高级页表是第一级页表**。
- **分页通过硬件机制实现，对于用户完全透明**。

---

<br/>

### 基本分段存储管理

要点：
- 分段存储的**地址空间是二维的**。因为段可以不等长，无法通过一个地址就得到段号和段内偏移量。
- 段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，该工作有编译程序完成。
- 也是信息的物理单位，**段是信息的逻辑单位**。
- 更利于实现共享，一个共享段，无论多大，只需要一个段表项。
- **无内部碎片**：在分段式存储管理中，内部碎片通常不会产生。原因在于，分段式存储管理将内存划分为多个段，每个段对应程序的不同逻辑部分（如代码段、数据段、堆栈段等），每个段的大小可以与程序的实际需求相匹配。内存中的段是**根据程序实际所需的大小分配的**，而不是按固定大小的块分配，因此不会出现内部碎片。
- **段长是可变长的**：这种动态增长的方式通常称为“动态段”（Dynamic Segmentation）或“段扩展”（Segment Expansion）。这种机制允许一个段在程序运行时，根据需要动态地增加大小，而无需预先知道段的最大大小。

---

<br/>

### 段页式存储管理 

要点：
- 段页式地址空间也是二维的。
- 同时面临外部碎片和内部碎片。

---


<br/>


<br/>



## 虚拟内存管理

### 虚拟内存基本概念

**传统内存管理方式特征**
- 一次性：作业一次性全部装入内存，才能开始运行。
- 驻留型：作业被装进内存之后，就一直驻留在内存中。

<br/>

**虚拟存储器特征**
- 多次性：作业分成嗦粉调入内存
- 对换性：内存和外存对换区 进行数据的对换
- 虚拟性：从逻辑上扩充了内存容量


<br/>

**虚拟存储技术实现**
- 请求分页
- 请求分段
- 请求段页

----

<br/>

### 请求分页管理方式

操作系统必须提供一定的硬件支持：
- 内存、外层
- 页表机制：在页表项增加字段
	- 状态位：该页是否在内存中
	- 访问字段：一段时间内被访问的次数
	- 修改为
	- 外存地址：在调入该页时，需要用到
- 地址变换机构


---


<br/>

### 页框分配

**驻留集**

给进程分配的页框（内存物理页）的集合。


<br/>

**内存分配策略**
- 固定分配：每个进程分配固定数目的物理块
- 可变分配
- 局部置换：只能从分配给进程在内存的页面中选出一页换出
- 全局置换


<br/>

**物理块调入算法**
- 平均分配：物理块平均分给进程
- 比例分配：按进程大小分
- 优先权

**通常将物理块分为两部分：按比例、按优先级。**


<br/>

**调入页面的时机**

- 预调页策略：主要用于进程首次调入，由于程序员之处应先调入哪些页
- 请求调页


<br/>

**从何处调入页面**

外存分为两部分：
- **文件区**：存放文件，离散分配方式
- **对换区**：存放对换页面，连续分配方式，所以对换区 IO 速度更快

有如下情况：
- 对换区足够：进程运行前，将所有与进程有关的文件从文件区复制到对换区
- 对换区不足
	- 不会被修改的文件，直接从文件区调入（因为不会被修改，不需要写回，写的速度很慢）
	- 会被修改的文件必须放在对换区
- UNIX 方式：进程有关文件放在文件区，未运行过的进程会从文件区调入。**运行过但是被换出的页面，放在对换区**。

---

<br/>

### 页面置换算法

**最佳 OPT 置换算法**

淘汰以后**永不使用**，或**最长时间内不再访问**的页面。

由于无法预测未来的情况，所以无法实现，只用于评价其他算法。


<br/>

**FIFO**

只有该方法会发生 **Belady 异常**。

<br/>

**LRU**

淘汰最近最长时间未使用页面。LRU 需要记录页面最近一次使用的时间，然后排序，但是排序消耗很大，**排序方法只用于手算模拟来做题**。

计算机在页表项中增加 LRU 位，具体实现参考计组 Cache 替换的 LRU 策略。


<br/>

**CLOCK 算法**
- 简单 CLOCK：只看 **访问位**
- 改进 CLOCK：先考虑 访问 位，然后考虑 修改位。

---

<br/>

### 抖动与工作集

**抖动**

频繁的页面调度行为。不等于 belady 异常（进程分配物理块增加，缺页次数反而增加）。

**根本原因：分配给每个进程物理块太少**。


<br/>

**工作集**

某段时间间隔（窗口尺寸），进程要访问的页面集合。

实际应用中，工作集窗口会设置得很大。驻留集大小不能小于工作集，否则运行过程会频繁换页。

---

<br/>

### 内存映射文件

内存映射文件：是一个**系统调用**，将文件映射到虚拟地址空间某个区域，然后以访问内存的方式读写文件（对进程透明），访问页面时将文件**每次一页的读入**。

很多时候，**共享内存**通过映射相同文件到通信进程的虚拟地址空间实现。

---


<br/>


<br/>


<br/>

# 文件管理

## 文件系统基础


### 文件基本概念

文件是以**硬盘**为载体的存储在计算机的**信息集合**。

**文件结构**
- 数据项
- 记录：由若干数据项构成
- 文件
	- 有结构文件：由记录构成
	- 无结构文件：视为字符流


<br/>

**文件元数据**

即与文件有关的**附加信息**（文件属性）。
- 文件名：实现**按名存取**，在**同一目录中文件名唯一**。
- 类型
- 创造者
- 所有者
- 位置
- 大小
- 保护
- 其他时间信息

---

<br/>

### 文件控制块 FCB 与 索引节点 i node

**文件控制块**

存放控制文件需要的各种信息的数据结构。文件与 FCB 一一对应。FCB 的有序集合称为文件目录（也是一种文件）。

FCB 构成：
- 基本信息
- 存取控制信息
- 使用信息

<br/>

**索引节点 inode**

在**检索目录**时，FCB 中处理文件名字以外的其他信息不会被用到，不需要调入内存中。

将文件名 和 文件其他描述信息分离，分离出来的信息放在索引节点 inode 中，inode 与文件一一对应。目录项中仅仅存放 文件名和 inode 号（指向 inode 的位置）。

两种索引节点
- **磁盘索引节点**：存放在磁盘的索引节点
- **内存索引节点**：将磁盘索引节点复制到内存中，添加额外内容：
	- inode 号
	- 状态
	- 访问计数：有多少进程在访问
	- 逻辑设备号：所属文件系统的逻辑设备号
	- 链接指针
---


<br/>

### 文件操作

**文件打开与关闭**

打开与关闭不等价于读写，而是把目录项从外存复制到内存或写回外存。

**打开文件表**：**文件描述符 （进程）**-文件目录项
- 整个系统的**一个**打开文件表：与进程无关的信息，文件在磁盘位置，文件大小等
- **每个**进程的打开文件表：**读写指针**、文件访问权限

当一个进程打开一个文件，如果不是第一次打开，就进程的文件打开表新增一个条目，指向系统表的条目。

系统文件打开表为每个文件关联一个打开计数器，当计数器清零时，才会从系统表中删除条目。

**只要调用了文件打开 open 的系统调用，就不再使用文件名，而是使用文件描述符。**

---

<br/>

### 文件保护

几种实现方式：

**访问控制**

最常用的方法是根据用户身份进行控制，为每个文件（目录也是文件）增加一个**访问控制列表 ACL**：

- 访问控制列表：为**每个用户**，都标明其权限
- **精简访问列表**：将用户分类，拥有者、组、其他。


> <span style="background:#fff88f">ACL 是对于文件而言的，而不是用户，所以需要反映所有类别用户的所有权限情况。</span>
> 
> 例如，有 $n$ 类用户， $m$ 种权限，需要 $n\times m$ 位才能表示所有情况，而 $log_2^n + log_2^m$ 只能表示某一类用户具有某些权限。



<br/>

**口令保护**

在建立一个文件时提供一个口令，用户请求访问时必须提供相应的口令。

口令存在系统内部，不够安全，但是开销不多。

<br/>

**加密保护**

对文件进行加密，文件被访问时需要密钥。保密性强，但是编码和译码需要时间。

---

<br/>

### 文件逻辑结构

文件逻辑结构是数据在逻辑上如果组织起来的，与**存储介质特性无关**。

**无结构文件**

由**字符流**构成的文件，**流式文件**，长度以字节为单位。

源程序、可执行文件、库函数都是无结构文件，无结构文件没有结构，对记录的访问只能通过**穷举搜索**的方法。


<br/>

**有结构文件**

由**一个以上**的记录构成的文件。记录式文件。
- **顺序文件**：记录一个接一个的顺序排列。对记录进行批量操作时，效率最高，**只有顺序文件才能存储在顺序存储设备（磁带）中**。
	- 串结构：记录排列顺序与关键字无关
	- 顺序结构：记录按照关键顺序
- **索引文件**：对记录进行索引，形成一个索引表。
- **索引顺序文件**：将若干记录归为一组，组与组之间的关键字有序，组内可以无序。
- **直接文件（散列文件）**：键值（或通过散列函数转换）决定记录的物理地址。


<span style="background:#fff88f">**以上操作的对象都是记录**</span>，而不是磁盘块。


---

<br/>

### 文件物理结构

内存与瓷片之间数据交换都是以**块**（通常等于内存的页的大小）为单位进行的。

物理结构就是研究文件的实现，即文件数据物理设备上是如何分布和组织的。
- 文件的分配方式：对于非空闲块的管理
- 文件存储空间管理：对空闲块的管理

**连续分配**

每个文件在磁盘上占有一组连续的块。
- 支持顺序访问和直接访问（直接访问到文件中的某个块）。
- 会产生外部碎片。
- 需要实现知道文件长度，无法满足文件动态增长的要求。
- 插入和删除记录时，需要对相邻记录做物理上的移动。


<br/>

**链接分配**

消除了外部碎片；便于动态分配。
- 隐式链接：目录项中含有文件**第一块**的指针，和**最后一块**的指针。
	- 只支持顺序访问
	- 稳定性差，一块丢失，导致文件数据丢失
	- 为提升查找速度和减小指针所占存储空间，将一个块组成一个**簇**，按簇来分配。**只要题目提及了簇，那么一定是按簇分配的。**
- 显示链接：整个磁盘设置**一张 文件分配表 FAT**，目录项中只有记录**起始块号**。
	- FAT 在系统启动时就被读入内存，检索记录在内存中进行。


<br/>

**索引分配**

给**每个**文件分配**一个**索引块 。


---

<br/>


<br/>

## 目录




---