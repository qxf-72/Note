# 绪论

数据结构是一门研究非数值计算的程序设计中的计算机的操作对象以及他们之间的关系和操作的学科

## 数据

**数据**
- 是能输入计算机且能被计算机处理的各种符号的集合。包括数值型数据，如整数、实数，非数值型数据，如文字、图像、声音
- 信息的载体是对客观事物符号化的表示
- 能被计算机识别、存储、加工

**数据元素**：数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理
简称元素，或称为记录、节点、顶点

 一个数据元素可以有若干数据项组成

**数据项**：构成数据元素的不可分割的最小单位

**数据对象**：是性质相同的数据元素的集合，是数据的一个子集

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-08_202718.png" width="300" />
</center>


---

<br/>


<br/>


<br/>



## 数据结构

数据元素不是孤立存在的，他们之间存在某种关系。数据元素相互之间的关系成为结构，数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。数据结构是带结构的数据元素的集合

**三方面的内容**
- 逻辑结构：数据元素之间的逻辑关系
	- 描述数据元素之间的逻辑关系
	- 与数据的存储结构无关，独立于计算机
	 - 是从具体问题抽象出来的数学模型
- 物理结构（存储结构）：数据元素及其关系在计算机内存的表示（映像）
	- 数据元素及其关系在计算机中的存储方式
	- 是数据结构在计算机中的表示
- 运算与实现（算法）：对数据元素可以施加的操作以及这些操作在相应存储结构的实现

**逻辑结构与存储结构的关系**
1. 存储结构是逻辑关系及元素本身的映像
2. 逻辑结构是数据结构的抽象，存储结构是数据结构的实现

**逻辑结构分类**

1. 划分一
   1. 线性结构：仅有一个开始和终端结点，所有结点最多只有一个直接前趋和直接后继，线性表、栈、队列、串
   2. 非线性结构：一个结点可以有多个直接前趋和直接后继，树、图
2. 划分二
   1. 集合：除了同在一个集合，无关系
   2. 线性结构：一对一
   3. 树形结构：一对多
   4. 图状结构：多对多

**存储结构分类**

1. 顺序存储：用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示
2. 链式存储：用一组任意存储单元来存储数据元素
3. 索引存储：存储信息的同时建立附加索引表
4. 散列存储：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658368161088-87dfcb5e-eb17-467d-b1d9-f5bc2927ec43.png#averageHue=%23fcfcfc&height=312&id=Klj8y&originHeight=734&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=540" width="540" /> </div>


**数据类型和抽象数据类型**

1. 数据类型：是一组性质类似的值的集合以及定义于这个值集合上的一组操作的总称

高级语言的数据类型隐含规定了程序执行期间变量和表达的所有可能的取值范围，以及在这些数值范围上所允许的操作

1. 抽象数据类型：一个数学模型以及定义在此模型的一组操作
   1. 由用户定义
   2. 包括定义在数据模型上的一组抽象运算
   3. 不考虑计算机内具体的存储结构和运算的具体实现
   4. 抽象数据类型可以用$（D,S,P）$三元组表示
   5. D是数据对象，S是D上的关系集，P是对D的基本操作集

定义格式：
``` 
ADT 抽象数据类型名{
	数据对象：
	数据关系：
	基本操作：
		参数表
		初始条件
		操作结果
}ADT 抽象数据类型名
```

## 算法
算法是对特定问题求解的方法和步骤的一种描述，他是指令的有限序列，其中每个指令表示一个或多个操作。
**算法特征**

1. 有穷性：执行有穷步，每步执行有穷时间
2. 确定性：每一条指令有确定含义
3. 可行性
4. 输入：0个或多个输入
5. 输出：至少一个输出

**算法设计要求**

1. 正确性：（第三层：检验是否合格的标准）对于精心挑选，典型，苛刻带有刁难性的输入，得到满足要求的输出
2. 可读性：
3. 健壮性（鲁棒性）：对于非法输入，恰当做出反应，处理出错的方法：不是中断程序执行，而是返回表示错误或错误性质的值
4. 高效性：时间复杂度、空间复杂度

**算法分析**
一个好的算法首先要具备正确性，然后健壮性，可读性，最后考虑算法效率
时间效率的度量：**事后分析、事前分析**
主要是事前分析：渐进时间复杂度
主要考虑语句频度最大的语句
有的情况基本执行次数与输入数据集有关，此时主要考虑最坏时间复杂度和平均时间复杂度
对于复杂的算法可以分成几个容易估算的部分
加法规则
乘法规则
空间效率度量
算法要占据的空间，包括算法本身占据的空间，输入输出，指令，变量，算法要使用的辅助空间
# 线性表
线性表是具有相同特性的数据元素的有限序列，可以为空

1. 除第一个元素以外，其余元素有且只有一个直接前驱
2. 除最后一个元素，其余元素有且只有一个直接后继
3. 当元素个数为零时，线性表成为空表
## 顺序表
用一组地址连续的存储单元一次存储线性表的元素。线性表第一个元素的存储位置，成为线性表的起始位置或基地址。

1. 可随机存取
2. 插入和删除元素时间复杂度高
## 单链表
用一组任意的存储单元存储线性表的数据元素。结点包括数据域和指针域
单链表只包含一个指针域

1. 不要求逻辑上相邻的元素在物理位置上也相邻，插入、删除操作方便
2. 没有可随机存取的优点

头节点与头指针
在第一个结点之前附设一个结点，称为头节点，头节点的数据域可以不存储任何信息，也可以存储如线性表长度等类附加信息。指向头结点的指针就是头指针。
头结点的作用：
方便链表的特殊操作，保证链表操作的统一性
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658368161615-639b94ab-144e-4ebb-83c9-924babfc1f1b.png#averageHue=%23fffefe&height=159&id=viGM1&originHeight=287&originWidth=1056&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=586" width="586" /> </div>


当链表附设尾指针时，进行删除操作时要特别注意，当删除链表最后一个节点时，尾指针rear会指向NULL，此时应该rear=head，以表明链表为空
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1665561659480-bf1c4a81-54f5-4ce5-9016-25cfba945ac5.png#averageHue=%23fafaf9&clientId=ud907a85b-4cc6-4&from=ui&id=u7df1e416&originHeight=222&originWidth=1337&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73632&status=done&style=none&taskId=u6318bff9-c7ed-4675-9590-ba5bf392fd0&title=" width="600" /> </div>


## 静态链表
逻辑上相邻的数据，存放在同一块内存区域，数据元素允许在这块内存区域里随机存放，用游标来指示数据元素的逻辑结构。
兼具顺序表和链表的优点
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658368162109-d65cd3c6-9589-4f38-a2b5-860b3ac43f72.png#averageHue=%23fef4e7&height=349&id=IUIDq&originHeight=693&originWidth=707&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=356" width="356" /> </div>


## 循环链表
一种链式存储结构，表中最后一个结点指向头结点，整个链表形成一个环

1. 从表中任何一个结点出发均可找到其他结点
2. 通常在循环链表中设立尾指针，方便对链表首位进行操作

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658368162583-e694b75b-9612-44d9-b159-aecd6c4f0a4a.png#averageHue=%23fefefe&height=125&id=lTVHv&originHeight=248&originWidth=1272&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=641" width="641" /> </div>


## 双向链表
一种链式存储结构，每一个结点中有两个指针域，一个指向直接前驱，一个指向直接后继
克服单链表的单向性的缺点
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658368162810-46881a04-ab28-41f3-8e27-34e917c3416e.png#averageHue=%23f4f4f4&id=hylt2&originHeight=139&originWidth=491&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" width="600" /> </div>


# 栈和队列
**栈**
栈是一种操作受限的线性表结构，限定仅在表尾进行操作

1. 后进先出$LIFO$结构
2. 表尾称为栈顶，表头称为栈底
3. 数学性质：n个不同元素进栈，出栈元素的不同排列个数为$\frac{1}{n+1}C_{2n}^{n}$，该数也称为卡特兰数
## 顺序栈
用顺序存储结构实现栈

1. 附设top指针指示栈顶元素在栈中的位置，（为了操作方便，通常top指示真正的栈顶元素之上的地址）
2. 另设base指针，指示栈底元素在栈中位置
3. 用stacksize表示栈中可使用的最大容量

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658368163163-11747476-5852-4b5b-b687-e0470fe4b01f.png#averageHue=%23fefefe&height=182&id=opwVd&originHeight=285&originWidth=526&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=336" width="336" /> </div>


顺序栈的特点：简单，方便，但容易溢出
上溢：栈满，还要入栈
下溢：栈空，还要出栈
## 链栈
运算受限的单链表，只能在链表头部进行操作
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658368163673-dd875ec7-e1e9-4b68-b694-afd04dfd9161.png#averageHue=%23fefefe&height=278&id=BwNSS&originHeight=839&originWidth=938&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=311" width="311" /> </div>


## 栈与递归
**递归的定义**

   1. 若一个对象部分地包含自己，或用自己定义，则称这个过程是递归的
   2. 若一个过程直接或间接地调用自己，则称这个过程是递归的过程

**常用递归的情况**

   1. 递归定义的数学函数
   2. 具有递归性质的数据结构
   3. 可递归求解的问题

**分治法**
	对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题进行求解
**分治法应用的条件**

   1. 能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类似，不同的仅是处理的对象，且这些处理对象是变化有规律的
   2. 可以用过上述转化而使问题简化
   3. 必须有一个明确的递归出口，或称递归的边界

**分治法求解递归问题的一般形式**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658561061448-8ac436c7-969e-44f9-8bc6-a013c8dfcbc2.png#averageHue=%23fdfcfb&clientId=uc583c6db-d902-4&from=ui&height=87&id=ub9ac59e1&originHeight=154&originWidth=724&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29901&status=done&style=none&taskId=u636a1f97-8be1-40c7-8cee-80ae0384d69&title=&width=410" width="410" /> </div>


**函数调用的过程**
调用前：

   1. 将实参，返回地址等传递给调用函数
   2. 为被调函数的局部变量分配存储区
   3. 将控制转移到被调用函数的入口

调用之后：

   1. 保存被调函数的计算结果
   2. 释放被调函数的数据区
   3. 依照被调用函数保存的返回地址将控制转移到调用函数

**栈与递归之间的联系**

   1. “最后调用，最先返回”，递归函数是用系统的栈实现的
   2. 递归工作栈——递归程序运行期间使用的数据存储区
   3. 工作记录——实参，局部变量，返回地址

**递归优缺点**

   1. 优点：结构清晰，程序易读
   2. 缺点：每次调用要生成工作记录，保存状态信息，时间开销大
      1. 尾递归、单向递归用循环结构代替
      2. 自用栈模拟系统的运行时栈

**队列**
仅在表尾进行插入操作，在表头进行删除操作的线性表

   1. 表尾称为队尾，表头称为队头
   2. 先进先出结构(FIFO)
   3. 插入元素称为入队，删除元素称为出队
   4. 分为链队、顺序队（常用循环顺序队）
## 链队列
用链表实现队列，需要一个头指针和一个尾指针确定队列
特别注意的是，在进行删除操作时，当删除队列最后一个节点时，队列的尾指针丢失，需要重新赋值，指向头结点
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/anonymous/1658491585803-8886ada7-da77-4c09-9677-6e2e35fc248a.jpeg#averageHue=%23f6f6f6&from=url&height=354&id=X7nhR&originHeight=559&originWidth=509&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=322" width="322" /> </div>


## 循环队列
用一组地址连续的存储单元依次存储队列元素

   1. 附设两个指针front和rear分别指向队头元素和队尾元素
   2. 为方便操作，尾指针通常指向队尾元素的下一个位

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658491945152-78dbfe41-63ff-4c2f-ab86-05847ed1e00a.png#averageHue=%23f4f4f4&from=url&height=261&id=d6RLr&originHeight=365&originWidth=464&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33594&status=done&style=none&title=&width=332" width="332" /> </div>


当队列为循环队列时，Q.front==Q.rear无法判断队列空间是空还是满，解决方法：

   1. 另设一个标志位以区别空和满
   2. 少用一个空间，当尾指针指向头指针的上一个位置时，将队列设置为满

循环队列求长度方法
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1658493459259-e0023356-ee5a-498a-8c07-7befbf718097.jpeg#averageHue=%23f1f1e3&clientId=uf7bef20d-e762-4&from=ui&height=112&id=u9a37faca&originHeight=173&originWidth=647&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15753&status=done&style=none&taskId=u169b2692-7536-47bd-9fc9-7cf1f676a3d&title=&width=418" width="418" /> </div>


循环队列插入操作
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1658493526038-7c7ed6db-b7d2-4806-95c6-9ca6f6ff874d.jpeg#averageHue=%23f6f6f6&clientId=uf7bef20d-e762-4&from=ui&height=217&id=ub928386b&originHeight=352&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29685&status=done&style=none&taskId=uf8dee405-5fe7-4fe7-9db5-e325a395388&title=&width=567" width="567" /> </div>


# 串、数组和广义表
## 串
由零个或多个字符组成的有限序列

   1. 串中任意连续的字符组成的子序列称为该串的子串，包含子串的串相应的称为主串
   2. 符号$\phi$来表示空串

串的逻辑结构和线性表极为相似，串的数据对象约束为字符集；串的基本操作和线性表有很大差别，通常以“串作为整体”作为操作对象
## 串的定长顺序表示
用一组地址连续的的存储单元存储串值的字符序列，为每一个定义的串变量分配一个固定长度的存储区

   1. 超过预定长度的的串值会被舍弃，即“截断”
   2. 通常在下标为0的元素数组变量存放串的长度

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/anonymous/1658546923302-8e05e0f9-9f1c-4cce-bc5f-d39fa67eab21.jpeg#averageHue=%23f4f4f4&height=175&id=sfn4D&originHeight=256&originWidth=403&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=275" width="275" /> </div>


## 堆分配存储结构
存储空间由动态分配得到
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/anonymous/1658547271862-7602cade-1641-4747-a26a-4a9b05a69b58.jpeg#averageHue=%23f4f4f4&height=163&id=FC4DT&originHeight=226&originWidth=356&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=256" width="256" /> </div>


## 串的块链存储结构

   1. 每个结点可以存储一个或多个字符
   2. 最后一个结点不满时，补上“#”或其他的非串值字符（通常#不属于串的字符集，时一个特殊的符号）
   3. 通常设立尾指针，便于进行联结操作

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/anonymous/1658547698597-e4576d51-914b-4118-bc15-c4478d90fcad.jpeg#averageHue=%23f0f0f0&height=228&id=e2Jjh&originHeight=326&originWidth=761&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=532" width="532" /> </div>


## 串的模式匹配算法
子串的定位操作叫做串的模式匹配
### 暴力算法
简单匹配算法——当匹配失败时，指针回退重新进行匹配
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/anonymous/1658561420396-ef193ba3-8f0d-4d99-8586-916f307676df.jpeg#averageHue=%23f4f4f4&height=230&id=ltcSG&originHeight=444&originWidth=1058&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=549" width="549" /> </div>


### KMP算法
根据已经得到的部分匹配的结果，主串指针不回退，子串指针减少回退
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658563011969-796434d0-9614-4283-a6ad-16b9c5225b0b.png#averageHue=%23fdfdfc&clientId=uc583c6db-d902-4&from=ui&height=273&id=ufbe469d4&originHeight=761&originWidth=1002&originalType=binary&ratio=1&rotation=0&showTitle=true&size=88443&status=done&style=none&taskId=u1ee0ebd9-9ab2-450c-9803-88bf42ff0c0&title=KMP%E7%AE%97%E6%B3%95&width=359 "KMP算法"" width="359" /> </div>

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658563110841-318f5838-5b3b-4472-ad22-392e2af12a6f.png#averageHue=%23fdfdfc&clientId=uc583c6db-d902-4&from=ui&height=279&id=u9d2e13de&originHeight=803&originWidth=930&originalType=binary&ratio=1&rotation=0&showTitle=true&size=76199&status=done&style=none&taskId=u5e02ee98-dc8a-4ba8-aa75-921847f8b1c&title=%E6%B1%82next%E6%95%B0%E7%BB%84&width=323 "求next数组"" width="323" /> </div>


应当注意，严书中串的下标为0的元素存放串的长度，故可用空间下标从1开始，且严书中next数组对应元素存放的是上一个元素的最大公共前后缀
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1658564437337-5ec0b1d4-53a0-40ac-9ebd-74f198f67f56.png#averageHue=%23eeeded&clientId=uc583c6db-d902-4&from=ui&height=146&id=u1eb29533&originHeight=351&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100926&status=done&style=none&taskId=ud6747f19-6ff9-4b6b-8662-2bd079f74e2&title=&width=391" width="391" /> </div>


严书中求next数组
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/anonymous/1658584973838-7de653ad-335e-4770-ade8-8b4334a76da1.jpeg#averageHue=%23f6f6f6&height=209&id=SY66p&originHeight=332&originWidth=1029&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=648" width="648" /> </div>


对next数组进行优化得到nextval数组
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/anonymous/1658565882039-b723971f-f723-40de-9690-7682f459779c.jpeg#averageHue=%23f6f6f6&height=200&id=yloSi&originHeight=440&originWidth=931&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=423" width="423" /> </div>


## 数组
按一定格式排列起来的，具有相同类型数据元素的集合

   1. 数组结构是线性表结构的拓展：数组中数据元素本身也是一个数据结构
   2. 线性表结构是数组结构的一个特例
   3. 所有数据元素必须属于同一类型
## 数组的顺序表示
数组结构固定——维数和维界不变，一般不做插入和删除操作，一般用顺序存储结构表示数组
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1658908367314-b8b00d51-7cc6-4bed-9323-b762a60dedc1.jpeg#averageHue=%23fefefe&from=url&height=206&id=dmPJJ&originHeight=434&originWidth=1044&originalType=binary&ratio=1&rotation=0&showTitle=false&size=72699&status=done&style=none&title=&width=496" width="496" /> </div>



   1. base：数组起始地址
   2. dim：维数
   3. bounds：一个数组，里面存储各个维数的元素个数
   4. constants：没一维的偏移量，即在某个维度中，访问该维度下一个元素指针需要移动的位置

数据初始化时，由于维数不确定，需要用可变参数：stdarg.h实现
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1658909215176-5c00031f-bdbd-462e-b022-9cc6ad1dc6c7.jpeg#averageHue=%23fbfbfb&from=url&height=541&id=P0j99&originHeight=1281&originWidth=1168&originalType=binary&ratio=1&rotation=0&showTitle=false&size=200447&status=done&style=none&title=&width=493" width="493" /> </div>



## 矩阵的压缩存储
压缩存储——为多个值相同的元只分配一个空间，对零元不分配空间
### 特殊矩阵
 值相同的元素或者零元素在矩阵中的分布有着一定规律的矩阵
**对称矩阵**
$n^2$个元分配$n(n+1)/2$个空间
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1659011694218-05abf3a1-7d29-498c-b486-d9c25ebd812c.jpeg#averageHue=%23fbfbfb&from=url&height=97&id=faObA&originHeight=149&originWidth=502&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10999&status=done&style=none&title=&width=328" width="328" /> </div>


**三角矩阵**
上述方法同样适用于三角矩阵
需要另外加一个存储常数c的存储空间即可
**对角矩阵**
以对角线为顺序
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1659012975155-a6283d9f-e7f7-4f90-897c-27bd5a21be10.png#averageHue=%23eeeded&clientId=uc01851be-e5a5-4&from=ui&height=156&id=uee2e8efc&originHeight=396&originWidth=818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=137945&status=done&style=none&taskId=ua44be6a8-7b40-4783-8e37-839d1b2ebd7&title=&width=322" width="322" /> </div>


### 稀疏矩阵
稀疏因子$\delta =\frac{t}{m\times n}\le 0.05$的矩阵
**三元组顺序表**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1659014535195-650db116-3f31-4164-8fa7-60ef4675a396.jpeg#averageHue=%23f5f5ee&from=url&height=208&id=rdZAn&originHeight=335&originWidth=825&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73784&status=done&style=none&title=&width=513" width="513" /> </div>


**十字链表**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1659014646356-ab5773c5-8f0f-47b6-97d0-451507e1fc30.jpeg#averageHue=%23f5f5f5&from=url&height=290&id=Yqnky&originHeight=409&originWidth=586&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32752&status=done&style=none&title=&width=416" width="416" /> </div>


<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1659014669054-0163dcd9-b10a-4c40-a362-784ab22eb7bb.jpeg#averageHue=%23f9f9f9&from=url&height=200&id=op1RZ&originHeight=409&originWidth=1060&originalType=binary&ratio=1&rotation=0&showTitle=false&size=76300&status=done&style=none&title=&width=518" width="518" /> </div>


## 广义表
线性表的推广，也称为列表(lists)

   1. 广义表中的元素可以是单个元素，也可以是一个广义表
   2. 当广义表非空时，第一个元素为表头，其余元素组成的表为表尾
   3. 列表的元素可以是子表，而子表的元素还可以是子表
   4. 列表可以为其他列表共享
   5. 列表可以是一个递归的表
### 广义表的存储结构
采用链式存储结构，需要两种节点：表结点、原子结点
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1659019594299-55bdb26e-082e-4bdf-a33d-5688137854b3.jpeg#averageHue=%23f7f7f7&from=url&height=388&id=FFRm9&originHeight=776&originWidth=1092&originalType=binary&ratio=1&rotation=0&showTitle=false&size=131087&status=done&style=none&title=&width=546" width="546" /> </div>



   1. 除空表外，表头指针指向一个表结点
   2. 最高层的表结点数即为列表的长度
# 树和二叉树
## 树
树是n个结点的有限集

   1. 有且只有一个特定称为根的结点
   2. 当n大于1时，其余结点可分为m个互不相交的有限集，其中每一个集合本身也是一棵树，称为根的子树

树的结构定义是一个递归的定义，树的其他表示形式：

   1. 嵌套集合
   2. 广义表
   3. 凹入表示法

** 相关概念**

1. 树的结点拥有的子树数称为结点的度，结点的度为0的结点称为叶子或终端结点，度不为0的结点称为非终端结点或分支结点，树的度是树内各结点的度的最大值
2.  结点的子树的根称为该结点的孩子，该结点称为孩子的双亲，同一双亲的孩子之间互称为兄弟
3. 树中结点的最大层次称为树的深度或高度
4. 如果将树中结点的各子树看成从左到右是有次序的，则称该树为有序树，否则称为无序树
5. 森林是m颗互不相交的树的集合
## 二叉树
二叉树是另一种树形结构，并不是树的一种特例

   1. 二叉树结构最简单，规律性最强
   2. 可以证明，所有树都能转化为唯一对应的二叉树，不失一般性
   3. 普通树不转化为二叉树，运算很难实现

**二叉树特点**

   1. 每个结点最多有两个孩子
   2. 子树有左右之分，其次序不能颠倒
   3. 二叉树可以是空集合，根可以有空的左子树或空的右子树

**二叉树与树的区别**
二叉树的子树要区分左子树和右子树，即使只有一颗子树也要区分，而树的结点只有一个孩子时，就无需区分他是左还是右
### 二叉树性质

   1. 在二叉树的第$i$层上最多有$2^{i-1}$个结点
   2. 深度为$k$的二叉树至多有$2^k-1$个结点
   3. 对于任何一颗二叉树，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$

**满二叉树**
一颗深度为$k$且有$2^k-1$的结点的二叉树
**完全二叉树的特点**

   1. 终端结点只可能在层次最大的两层出现
   2. 对于任一结点，若其右分支下的子孙最大层次为$l$，则其左分支下的子孙最大层次为$l或者l+1$
### 完全二叉树性质

   1. 具有$n$个结点的完全二叉树的深度为$\lfloor \log _{2}^{n} \rfloor +1$
   2. 如果对于一颗有n个结点的完全二叉树的结点按层序从左到右编号，对于任一结点$i$
      1. 如果$i=1$，则结点是二叉树的根，没有双亲，如果$i>1$，则其双亲是结点$\lfloor \frac{i}{2} \rfloor$
      2. 如果$2i>n$，则结点$i$为叶子结点（终端结点），否则其左孩子结点为$2i$
      3. 如果$2i+1>n$，则结点无右孩子，否则其右孩子结点为$2i+1$
### 遍历二叉树
**定义**——按照某条搜索路径巡访数中每个结点，使得每个结点均被访问一次，且仅访问一次（又称周游）
**目的**——得到树中所有节点的一个线性排列
**用途**——他是树结构插入、删除、修改、查找和排序运算的基础，是二叉树一切运算的基础和核心
限定先左后右，有3种情况：先（根）序遍历、中（根）序遍历、后（根）序遍历
**根据遍历序列确定二叉树**
若二叉树中各结点的值均不相同，则二叉树结点的线序序列、中序序列和后序序列都是唯一的
又二叉树的先序序列和中序序列，或后序序列和中序序列可以确定唯一二叉树
关键：由先序序列或后序序列确定根，再由中序序列确定左子树和右子树，以此类推
**中序遍历的非递归算法**
利用**栈**后进先出的特点
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1660271576932-feb2c618-49e0-4d88-aa71-7332a7888ee5.png#averageHue=%23fefefc&from=url&height=375&id=A9D71&originHeight=750&originWidth=1152&originalType=binary&ratio=1&rotation=0&showTitle=false&size=226496&status=done&style=none&title=&width=576" width="576" /> </div>


**层序遍历算法**
利用**队列**先进先出的特点
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1660271805688-27914770-84d9-413d-a5d5-ab5b95309104.png#averageHue=%23fefefd&from=url&height=404&id=Nd1km&originHeight=807&originWidth=1209&originalType=binary&ratio=1&rotation=0&showTitle=false&size=235045&status=done&style=none&title=&width=605" width="605" /> </div>


**遍历算法的应用**

   1. 二叉树的建立

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1660272514513-d7046d70-05ba-480d-822c-8eb3216beff3.png#averageHue=%23fefefe&from=url&height=341&id=nJTa7&originHeight=623&originWidth=1146&originalType=binary&ratio=1&rotation=0&showTitle=false&size=180242&status=done&style=none&title=&width=627" width="627" /> </div>



   2. 二叉树的复制

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1660273030320-1ecce86c-e3ef-4024-9f92-f33d43c6b8b6.png#averageHue=%23efefef&clientId=uc7fb34cf-8027-4&from=ui&height=172&id=ue2922842&originHeight=564&originWidth=1421&originalType=binary&ratio=1&rotation=0&showTitle=false&size=218362&status=done&style=none&taskId=u2dc2e1d7-2b59-4ec2-944c-fa85f72b3c2&title=&width=434" width="434" /> </div>



   3. 求二叉树的深度

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1660273087818-fbba5a02-e21d-49eb-b134-3106e2295a6a.png#averageHue=%23fdfdf6&from=url&height=214&id=ugs2i&originHeight=400&originWidth=1099&originalType=binary&ratio=1&rotation=0&showTitle=false&size=140768&status=done&style=none&title=&width=588" width="588" /> </div>



   4. 计算二叉树的结点总数

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1660273197332-372c4d3b-b00d-483b-a05f-d0cd27ac22d2.png#averageHue=%23ededed&clientId=uc7fb34cf-8027-4&from=ui&height=158&id=ub0614d68&originHeight=433&originWidth=961&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105810&status=done&style=none&taskId=u069c1f1e-79eb-4724-8f4c-039c8990435&title=&width=351" width="351" /> </div>



   5. 计算二叉树的叶子结点数

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1660273264920-1e5e3119-1032-4b9a-a17c-ab33c94d4be0.png#averageHue=%23efefef&clientId=uc7fb34cf-8027-4&from=ui&height=163&id=u974de41a&originHeight=575&originWidth=1224&originalType=binary&ratio=1&rotation=0&showTitle=false&size=225498&status=done&style=none&taskId=u2313e817-6746-43ba-8fd9-9684ab2c8bc&title=&width=347" width="347" /> </div>


### 线索二叉树
$n$个结点的二叉链表中有$n+1$个空链域，可以增加标记，用空链域存储结点的前驱和后继信息
## 树和森林
### 树的存储结构

   1. **双亲表示法**——找双亲容易，找孩子难

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1660276062920-59f22fb5-3ef9-469d-a6f5-1ff45273cd02.png#averageHue=%23f2f2f2&from=url&height=213&id=nZmEo&originHeight=443&originWidth=514&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48111&status=done&style=none&title=&width=247" width="247" /> </div>



   2. **孩子表示法**—— 找孩子容易，找双亲困难

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1660276131269-071f4525-dae0-4be7-b7e6-096356140e69.png#averageHue=%23f3f3f3&from=url&height=224&id=yt0ln&originHeight=397&originWidth=503&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28441&status=done&style=none&title=&width=284" width="284" /> </div>



   3. **孩子兄弟表示法**

又称二叉树表示法，两个指针域分别指向第一个孩子结点，和下一个兄弟结点
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1660276178844-012d606e-276d-4323-8add-a9038cceebf0.png#averageHue=%23f2f2f2&from=url&height=220&id=Fn4OZ&originHeight=412&originWidth=532&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33653&status=done&style=none&title=&width=284" width="284" /> </div>


### 森林和二叉树的转换
由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表作为媒介可以导出树和二叉树之间的一个对应关系
**树转化为二叉树**

   1. 加线：在兄弟之间连线
   2. 抹线：对于每个结点，除第一个孩子以外，抹去其余其余孩子之间的关系
   3. 旋转，以根为核心，树顺时针旋转45°

**森林转化为二叉树**

   1. 将各棵树分别转化为二叉树
   2. 将每棵树的根节点相连
   3. 以第一棵树为二叉树的根，进行调整

二叉树转化为树或森林，反之即可
### 树和森林的遍历
**树的遍历**
先根遍历、后根遍历、按层次遍历
**森林的遍历**
将森林看作三部分构成：1、森林中第一颗树的根节点    2、森林中的第一棵树的子树森林    3、森林中其它树构成的森林

   1. 先序遍历：
      1. 访问第一棵树的根节点
      2. 先序遍历森林中第一棵树的子树森林
      3. 先序遍历森林中除第一颗树以外组成的森林
   2. 中序遍历
      1. 中序遍历森林中第一棵树的子树森林
      2. 访问第一棵树的根节点
      3. 中序遍历森林中除第一颗树以外组成的森林
## 赫夫曼树
**基本概念**

   1. 路径：从树中一个结点到另一个结点之间的分支构成两个结点之间的路径
   2. 路径长度：路径上的分支数目称作路径长度
   3. 树的路径长度：根到每一个结点的路径长度之和
   4. 树的带权路径长度：树中所有叶子结点的带权路径长度之和，记作$WPL$
   5. 最优二叉树：$WPL$最小的二叉树，也称赫夫曼树

具有相同带权结点的赫夫曼树不唯一
**赫夫曼树的构造算法**

   1. 构造森林全是根
   2. 选用两小造新树
   3. 删除小添新人
   4. 重估2、3剩单根

在赫夫曼算法中，初始时有$n$颗二叉树，经过$n-1$次合并形成赫夫曼树，每一次合并产生一个新的结点，因此最终会有$2n-1$个结点
**赫夫曼编码**
设计长度不等的编码，则必须使任一字符的编码都不是另一个字符编码的前缀，这种编码叫做前缀编码
为什么赫夫曼编码能够保证是前缀编码？——因为没有一片叶子是另一片叶子的祖先，所以每个叶子结点的编码不可能是其他叶结点编码的前缀
为什么赫夫曼编码能够保证字符编码总长最短？——因为赫夫曼树的带权路径最短
# 图
$G=(V,E)——(Graph=(Vertex,Edge))$
$V:$顶点（数据元素）的有穷非空集合
$E:$边的有穷集合
##  基本概念
无向图：每条边都是无方向的
有向图：每条边都是有方向的
完全图：任意两个顶点都有一条边相连

   1. 无向完全图——$\frac{n\left( n-1 \right)}{2}条边$
   2. 有向完全图——$n\left( n-1 \right)条边$

弧：有方向的边
稀疏图：有很少边或弧的图$(e<n logn)$
稠密图：有较多边或弧的图
网：边或弧带权的图
**邻接**：有边或弧相连的两个节点之间的关系

   1. 存在$(V_i,V_j)，则称V_i和V_j互为邻接点$
   2. $存在<V_i,V_j>,则称V_i邻接到V_j,V_ij邻接于V_i$

**关联（依附）**：边或弧于顶点之间的关系
**顶点的度**：与该顶点相关联的边的数目，记作$TD(v)$，在有向图中，顶点的度等于该顶点的入度和出度之和
**路径**：接续的（若干条）边构成的顶点序列
**路径长度**：路径上边或弧的数目之和/权值之和
**回路（环）**：第一个顶点和最后一个顶点相同的路径
**简单路径**：除了起点和终点可以相同外，其余顶点均不相同的路径
**简单回路（简单环）**：除了起点和终点相同外，其余顶点均不相同的路径
**连通图（强连通图）**：在无（有）向图中，若对任何两个顶点v、u，都存在从v到u的路径，则称G是连通图（强连通图）
**连通分量（强连通分量）**：无（有）向图的极大连通子图称为图的连通分量
极大连通子图：该子图是G连通子图，将G的任何不在该子图的孩子加入，子图不再连通
**生成树**：包含无向图所有顶点的极小连通图
极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通
**生成森林**：对于非连通图，由各个连通分量的生成树的集合
## 图的存储结构
### 数组表示法(邻接矩阵)
用两个数组，$vex[n]$存储数据元素（顶点），$arcs[n][n]$存储数据之间的关系（边或弧）的信息
**无向图**

- $arcs[i][j]$等于1,表示有边依附于i和j两个顶点，或从i到j的弧，等于0则没有
- 无向图的邻接矩阵时对称的，可以用压缩存储的方法只存入上（下）三角元素
- 顶点$i$的度=第$i$行（列）中1的个数
- 对于完全图，对角线元素为0，其余元素都为1

**有向图**

- 在有向图的邻接矩阵中，第i行含义为以$v_i$为尾的弧
- 有向图的邻接矩阵可能是不对称的

**网（有权图）**

- $$
arcs\left[ i \right] \left[ j \right] =\left\{ \begin{array}{l}
	W_{ij},<v_i,v_j>\text{或}\left( v_i,v_j \right) \in VR\\
	\infty ,\text{无边（弧）}\\
\end{array} \right.
$$

**邻接矩阵的优劣**

- **好处**
   - 直观、简单、好理解
   - 方便检查任意一对顶点之间是否存在边
   - 方便找任一顶点的所有邻接点
   - 方便计算顶点的度
- 缺点
   - （矩阵是固定的结构）不便于增加和删除顶点
   - 浪费空间——对于稀疏矩阵有大量无用元素，但对于稠密图还是很划算
   - 浪费时间——统计稀疏图边数时时间复杂度高$O(n)$
### 邻接表
按编号顺序将顶点数据存储在一维数组中，关联同一顶点的边（以顶点为尾的弧）用线性链表存储
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661171300492-c4ab5d6f-89ae-4ef4-8a97-010fc430ac76.png#averageHue=%23f3f3f3&from=url&height=174&id=MjWxX&originHeight=252&originWidth=429&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14418&status=done&style=none&title=&width=296" width="296" /> </div>


**无向图**

- 邻接表不唯一
- 若无向图中有$n$的顶点，$e$条边，则其邻接表需$n$个头结点和$2e$个表结点。适宜存储稀疏图
- 无向图中顶点$v_i$的度为第i个单链表中的结点数

**有向图**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661172307465-c68dfecf-239d-4f19-bc15-d397a4d77b3d.png#averageHue=%23f0e9e5&clientId=ud60df47b-ac6b-4&from=ui&height=126&id=u9cdfb994&originHeight=235&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68709&status=done&style=none&taskId=ubdc54c60-804e-424a-9c4a-69e10ce03ef&title=&width=360" width="360" /> </div>



- 寻找某个顶点的出度容易，求入度难
- 逆邻接表恰恰相反

**邻接表的优劣**

- 优点
   - 方便找任一顶点的所有邻接点
   - 节约稀疏图的空间
   - 便于计算无向图的某一结点的度 
- 缺点
   - 不方便判断任意两个顶点之间是否有边

---

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1661179126915-d45f7224-c170-4c6f-9c6c-092cfe39a92d.jpeg" width="600" /> </div>


### 十字链表
有向图的一种链式存储结构，可以看作是将有向图的邻接表和逆邻接表结合起来得到的一种链表
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661177676977-a538c7a3-6273-4684-93d6-dab04a93d688.png#averageHue=%23f8f8f8&from=url&height=87&id=BHtH2&originHeight=157&originWidth=925&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23900&status=done&style=none&title=&width=511" width="511" /> </div>


tailvtex：弧尾顶点	headvex：弧头结点	hlink：弧头相同的下一个弧	tlink：弧尾相同的下一条弧
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661178016965-b17b41d6-3aad-4dbe-abe4-35697c1b6f23.png#averageHue=%23f2f2f2&from=url&height=226&id=uXRZs&originHeight=461&originWidth=1136&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62844&status=done&style=none&title=&width=556" width="556" /> </div>


### 邻接多重表
无向图的一种链式存储结构，每条边只存储一次，便于某些操作（删除边）
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661178317566-58c8aa9f-edc0-457b-ae5c-00d07aa8341b.png#averageHue=%23fbfbfb&from=url&height=104&id=kjJZy&originHeight=127&originWidth=398&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5250&status=done&style=none&title=&width=326" width="326" /> </div>


<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661178296822-aaaa8801-92dc-493a-8052-23a5e4173aa3.png#averageHue=%23fafafa&from=url&height=75&id=FYIMX&originHeight=109&originWidth=718&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10427&status=done&style=none&title=&width=497" width="497" /> </div>


$mark$标记此边是否被搜索过	$ivex,jvex$该边依附的两个顶点在表头数组中的位置	$ilink$指向依附于$v_i$的下一条边	$jlink$指向依附于$v_j$的下一条边
## 图的遍历
从图中某一个顶点出发访遍图中其他结点，且是每个结点仅被访问一次。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础
由于图中可能存在回路，因此需要一个辅助数组$visted[n]$标记顶点是否被访问过
### 深度优先搜索
类似于二叉树的先序遍历
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661217590547-bc68e83d-c8c2-4f75-a1dd-87f97bb4efb0.png#averageHue=%23fefefe&from=url&height=362&id=Xx0OI&originHeight=946&originWidth=1369&originalType=binary&ratio=1&rotation=0&showTitle=false&size=386670&status=done&style=none&title=&width=524" width="524" /> </div>


遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取决于图的存储结构

- 采用邻接矩阵为存储结构时，时间复杂度为$O(n^2)$
- 邻接表，时间复杂度为$O(n+e)$
### 广度优先搜索
类似于二叉树的层序遍历
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1661218141475-101279c2-7d9a-43c1-b3eb-adcafdb8556b.jpeg#averageHue=%23fafafa&from=url&height=540&id=ClPyA&originHeight=1291&originWidth=1265&originalType=binary&ratio=1&rotation=0&showTitle=false&size=347496&status=done&style=none&title=&width=529" width="529" /> </div>


## 图的应用
### 最小生成树

- 给定一个无向网络，再该网的所有生成树中，使得各边权值之和最小的生成树称为该网的最小生成树，也叫最小代价生成树
- 典型问题：城市通信网等问题

**生成树的特点**

- 生成树的顶点数和图的顶点数相同
- 生成树是图的极小连通子图，去掉一条边则非连通
- 一个有n个顶点的连通图有n-1条边
- 在生成树中再加一条边必然形成回路
- 生成树中任意两顶点间的路径唯一
- 无向图的生成树利用遍历得到——深度优先生成树、广度优先生成树

**MST性质**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661238768014-d62cc009-2ea7-45c2-b62a-dda44b18efe2.png#averageHue=%23efefef&from=url&height=75&id=hNesF&originHeight=126&originWidth=1089&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43647&status=done&style=none&title=&width=644" width="644" /> </div>


**构造最小生成树的方法**

- 普里姆（Prim）算法
   - 选取顶点加入最小生成树的集合
   - 在生成树集合和非生成树的顶点集合之间选取代价最小的边
   - 重复上面两个步骤，直到网中所有顶点加入生成树

时间复杂度为$O(n^2)$，适用于稠密图

- 克鲁斯卡尔（Kruskal）算法
   - 将边按照权值排序
   - 抽出其中权值最小的边，若该边连接顶点后，不形成环，则加入，否则丢弃
   - 重复该步骤，直到所有顶点都在同一连通分量

时间复杂度为$O(eloge)$,适用于稀疏图
### 最短路径

- 在有向网中从源点到终点之间的路径中，各边权值最小的路径，即最短路径
- 典型用途：交通网络问题

**求最小路径的算法**

- 某个源点到其余各顶点的最短路径——Dijkstra(迪杰斯特拉)算法
   - 选定源点后，记录下源点直接到其他每个顶点的距离，没有直接到达的顶点，距离记作$\infty$
   - 选取其中距离最小的顶点记作最优顶点，并以此为起点，进行更新
   - 若该点到其余非最优顶点的距离+该点到源点距离<表中记录的距离，则更新，否则就不更新

时间复杂度为$O(n^2)$

- 每一对顶点之间最短路径——Floyd（弗洛伊德）算法
   - 选取一个顶点作为起始点，记录其到其他各顶点之间距离
   - 然后假设路径经过该顶点，路径变短则更新，否则不跟新
   - 依此类推，当每个顶点都进行这样的操作，后即得到每一对顶点之间最短路径

时间复杂度为$O(n^3)$
也可以对每一个顶点使用Dijkstra算法，时间复杂度不变
> **有向无环图**
> 无环的有向图，简称DAG（Directed Acycline Graph）图。
> 通常用于描述一个工程或系统的进行过程，表示一个工程各子工程及其相互制约的关系。（通常把计划、施工、生产、程序等当作是一个工程），一个工程可以分为若干子工程，只有完成子工程（活动），才能完成整个工程。
> - AOV网：顶点表示活动，弧表示活动之间的优先制约关系$\Longrightarrow$拓扑排序
> - AOE网：弧表示活动，以顶点表示一个活动的开始或接受时间$\Longrightarrow$关键路径

### 拓扑排序
直观来说，在AOV网没有回路的前提下，我们将全部活动排列称一个线性序列，使得AOV网中有弧<i,j>存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列叫做拓扑排序序列，排序的算法叫做拓扑排序
拓扑排序算法

   - 在有向图中选一个没有前驱的顶点且输出
   - 从图中删除该顶点和所有以它为尾巴的弧
   - 重复上面步骤，直到图中没有无前驱的顶点

检测AOV图是否有环：对网进行拓扑排序，若网中所有结点都在它的拓扑有序序列中，则该网不存在环，否则有环
### 关键路径
相关概念

- 源点：入度为0的点
- 汇点：出度为0的点
- $ve(vj)$：事件vj的最早发生时间
- $vl(vj)$：事件vj的最迟发生时间
- $e(i)$：活动i的最早开始时间
- $l(i)$：活动j的最迟开始时间

 AOE网关注的问题

- 完成工程至少需要多少时间？由于网中有些活动可以同时进行，所以完成工程的最短时间是从开始点到完成点的最长路径的长度，这条路径叫做关键路径
- 哪些活动是影响工程进度的关键？没有时间余量的活动是关键活动

求关键路径

- 寻找$l(i)=v(i)$的关键活动
- 设活动$ai$用弧$<j,k>$表示，其持续时间为$w_{i,j}$
   - $e(i)=ve(j)$
   - $l(i)=vl(k)-w_{j,k}$
- 求$ve(j)$和$vl(j)$
   - 从$ve(1)=0$开始从前向后推导，$ve(j)=\underset{i}{Max}\left\{ ve\left( i \right) +w_{i,j} \right\}$——$max$的含义是只有完成所有该事件前的事件完成，它才可以发生，关键在于前面耗时间最多的事件
   - 从$ve(n)=vl(n)$开始从最后一个顶点往前推导，$vl\left( i \right) =\underset{j}{Min}\left\{ el\left( j \right) -w_{i,j} \right\}$，$min$的含义是该事件的发生不能阻碍所有以它为前驱的事件的发生，故最迟发生时间往小取值

---


<br/>


<br/>


<br/>


<br/>




# 查找

## 基本概念

**查找**：在数据集合中寻找满足某种条件的数据元素的过程。

**查找表**：由**同一类型**的数据元素构成的集合。对查找表的操作：
- 查询
- 插入、删除元素

**关键字**：数据元素中某项数据项的值，用它来唯一标识一个数据元素
- 主关键字：可以**唯一识别**一个记录的关键字，说到关键字，一般指主关键字。
- 次关键字：反之，用以识别若干记录的关键字是次关键字

**静态查找表**：仅作“查询”操作的查找表。

**动态查找表**：将查询结果为不在查找表的数据元素插入查找表中，或者从查找表中删除其查找结果为在查找表的数据元素。

**平均查找长度 ASL（Average Search Length）**：关键字的平均比较次数

---


<br/>


<br/>


<br/>


## 线性表的查找 

### 顺序查找

**应用范围**：顺序表或线性链表表示的静态查找表


**哨兵**

把待查关键字 key 存入表头，起监视哨的作用，可免去每一步都要检测是否查找完毕（原来每一步要检测两次），加快速度，这个改进能使顺序查找在 $ST.length>=1000$ 时，进行一次查找所需平均时间几乎减少一半。

**性能分析**
- 在无序表中，每个元素概率查找概率时，顺序查找成功的平均查找长度 $ASL_{成功}=\frac{n+1}{2}$ 。
- 在有序表中，成功查找的 ASL 与 无序表顺序成功查找的 ASL 一样。但是对于不在序列中的元素，在等概率情况下，有 $ASL_{\text{不成功}}=\frac{1+2+...+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$ 。


**判定树**

二分查找的判定树是一颗平衡二叉树，并且是**唯一确定**的。判定树的形状与 $mid$ 的取法有关， $mid$ 取法确定，判定树也就确定 。
- $mid=\lfloor \frac{L+R}{2} \rfloor$ ，判定树上对于每个节点，左子树 $\ge$ 右子树。
- $mid=\lceil \frac{L+R}{2} \rceil$ ，判定树上对于每个节点，左子树 $\le$ 右子树。


**顺序查找优缺**
- 优点：算法简单，逻辑次序无要求，且不同存储结构均适用。
- 缺点：ASL 大，时间效率低。

---


<br/>


<br/>



### 折半查找

**应用对象**：有序表，并且只能用于顺序表。

**性能分析**

- 折半查找的过程实质是，在一颗判定树上从根节点到目标结点或空结点的过程，判定树虽然不是完全二叉树，但是它的叶子结点所在层次之差最大为1，故具有 $n$ 个结点的判定树的深度为 $\lceil \log _2\left ( n+1 \right) \rceil$ ，故进行比较的关键字的个数至多为 $\lceil \log _2\left ( n+1 \right) \rceil$ 。
- 查找概率相等时， $ASL_{成功}=\frac{n+1}{n}\log _2\left( n+1 \right) -1$ ,当 $n$ 取值较大的时候， $ASL_{bs}=\log _2\left( n+1 \right) -1$ 。

**折半查找优缺**

- 优点：效率比顺序查找高。
- 缺点：只适用于有序表，且限于顺序存储结构（对线性链表无效）。

---


<br/>


<br/>




### 分块查找

**条件**
- 将表分成几块，分块之间必须是有序的，块内可以有序，可以无序。
- 建立索引表，每个检点含有最大关键字域和指向本块的第一个结点的指针，且按照关键字有序。

块的查找可以用顺序查找或者折半查找，而在块中查找只能用顺序查找。

**性能分析**

- $ASL_{bs}=L_b+L_w$
- 将长度为$n$的表，均匀分成$b$块，每块含$s$个记录
- 若使用顺序查找找所在的块， $ASL_{bs}=\frac{1}{b}\sum_{j=1}^b{j}+\frac{1}{s}\sum_{i=1}^s{i=\frac{b+1}{2}+\frac{s+1}{2}=\frac{1}{2}\left( \frac{n}{s}+s \right) +1}$ ，在此情况下，<span style="background:#fff88f"> $s=\sqrt n$</span> 时 ASL 最小。
- 若使用折半查找找所在的块，$ASL_{bs}\approx \log _2\left( \frac{n}{s} \right) +\frac{s}{2}$

---

<br/>


<br/>


<br/>


## 树表的查找

当表插入、删除操作频繁时，为维护表的有序性，需要移动表中很多记录。可以改用动态查找表——树表。

### 二叉排序树

**定义**

二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树，可以为空，如果不为空，满足以下性质：
- 非空左子树的所有键值小于其根结点的键值
- 非空右子树的所有键值大于其根结点的键值
- 左、右子树都是二叉搜索树

中序遍历非空的二叉排序树得到的时一个按照关键字排列的递增有序序列。


<br/>

**BST查找**

- 思想类似于二分查找，可以用递归实现
- 含有 n 个结点的二叉树的 ASL 与树的形态有关：
   - 最好情况下，二叉排序树是一颗平衡二叉树，效率和折半查找相同。
   - 最坏情况下，二叉树退化为单支树，查找效率和顺序查找相同。

<br/>

**BST插入**

BST 是动态树表，数的结构在查找过程中，当树中不存在关键字值等于给定值的节点是再进行插入。

BST 的插入时一个递归的过程：
- BST 为空，直接插入。
- 关键字值 $<$ 根节点值，插入左子树。
- 关键字值 $>$ 根节点值，插入右子树。

最后插入的结果必定是新增一个叶子节点。**不同的插入次序的序列生成不同的形态的 BST**。


<br/>

**BST删除**

BST 需要保证删除结点后所得到的二叉树让然满足二叉排序树的性质。需要对被删除的节点分类讨论：
   - 叶子结点：直接删除该节点
   - 只有左子树或右子树：用左子树或右子树替换它
   - 既有左子树又有右子树：思路——先找到在有序序列中待删除结点的上一个（下一个）结点，进行结点替换，转化为前面两种情况，然后进行删除。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-09_105208.jpg" width="600" />
</center>

---


<br/>


<br/>



### 平衡二叉树

**定义**
> 平衡二叉树又称 AVL 树，平衡二叉树可以是空树，若不为空，则满足以下性质：
> - 左子树和右子树的高度之差的绝对值 $\le$ 1
> - 左子树和右子树也是平衡二叉树

平衡因子（BF）：为方便描述每个结点的左子树和右子树高度之差，给每个结点附加一个数字——左子树高度 - 右子树高度。平衡二叉树的所有结点的平衡因子只能是-1，0，1，当插入一个新节点后失衡，需要对树进行平衡化。


<br/>

**失衡二叉树的平衡化**

调整原则——降低高度、保持二叉树的性质。不平衡的类型有以下四种，有四种不同的平衡旋转操作，但是本质上都是将其高度减 1 ，只需要**找准三个节点的小中大对应关系**。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/Snipaste_2022-08-27_10-55-49.png" width="400" />
</center>


<br/>


**AVL 的插入**

先按照 BST 的插入规则进行插入，然后进行平衡性检查。

检查插入路径上的节点是否因为此次操作导致了失衡（平衡因子绝对值大于 1 ），找到**距离插入节点最近的失衡节点** ，对该节点进行平衡化。



<br/>


**AVL 的删除**

- 按照 BST 的删除规则对节点 w 进行删除。
- 如果出现了失衡，**从节点 w 开始向上回溯到根节点**，对于**每一个**不平衡的节点进行平衡化。


---


<br/>


<br/>


### 红黑树

**红黑树定义**
> 为了保持 AVL 树的平衡性，在插入和删除操作后，会非常敏感的调整全树的拓扑结构，代价较为大。红黑树在平衡的标准上放宽条件。红黑树是



<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-09_181235.png" width="500" />
</center>



---



<br/>


<br/>


<br/>


## B-树和 B+树

### B 树

又称B-树，是一种多路平衡的查找树
> 一颗m阶的B树，可以是空树，如果不为空则满足以下性质
> - 树中每个结点至多有m颗子树
> - 若根结点不是叶子结点，至少有两颗子树
> - 除根节点以外的非终端结点，至少有$\lceil \frac{m}{2} \rceil$颗子树
> - 所有结点皆包含以下信息$(n,A_0,K_1,A_2,K_2,...,K_n,A_n)$
>    - $n$为关键字的个数
>    - $K_i$表示第i个关键字
>    - $A$表示指向子树根节点的指针，$A_{i-1}$指向的子树的所有关键字均小于$K_i$，而$A_{i}$指向的子树的所有关键字均大于$K_i$
> - 所有叶子结点都存在同一层次，不带任何信息，作为查找失败的结点，（实际上这些结点并不存在）

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661685511060-4c7a89b9-4390-4784-9dc4-625cd47fce22.png#averageHue=%23f7f7f7&from=url&height=495&id=JT67e&originHeight=495&originWidth=1229&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66359&status=done&style=none&title=&width=1229" width="700" /> </div>



**B树的查找操作**

- B树通常存储在磁盘中，查找包含两种操作：（1）在B树种找到结点（2）在结点中找关键字。前一种操作在磁盘进行，后一种在内存中进行，因此待查关键字在树中的层次数是影响查找效率的首要因素
- 第$l+1$层至少有$2\left( \lceil \frac{m}{2} \rceil \right) ^{l-1}$个结点，具有N个关键字的B树有N+1个叶子结点，则有$l\le \log _{\lceil m/2 \rceil}\left( \frac{N+1}{2} \right) +1$

**B树的插入操作**

- 若插入的结点的关键字个数小于$m-1$，直接插入即可
- 若待插入的结点p已经有$m-1$个关键字，将p分裂长p和$p^{'}$两个结点
   - <div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661684197152-7ac62e38-eeef-437e-b52c-e02702755732.png#averageHue=%23f7f7f7&from=url&height=226&id=C5gYt&originHeight=226&originWidth=1114&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60724&status=done&style=none&title=&width=1114" width="600" /> </div>


   - 若双亲结点的关键字个数也到达$m$,则采用同样的方法进行分裂,分裂的是根结点时,B树的层次会加1

**B树的删除操作**

- 被删除关键字所在结点关键字数目不少于$\lceil \frac{m}{2} \rceil$,直接删除
- 被删除关键字所在接待你关键字数目等于$\lceil \frac{m}{2} \rceil -1$
   - 若其相邻的兄弟结点关键字数目不少于$\lceil \frac{m}{2} \rceil$,其右兄弟(左兄弟)的最小(最大)关键字插入双亲结点中,而双亲结点中小于(大于)并紧挨该关键字的关键字插入被删除关键字所在结点
   - 若其相邻的兄弟结点关键字数目等于$\lceil \frac{m}{2} \rceil -1$,将其右兄弟的所有关键字和双亲结点中对应的关键字合并到该结点,该过程双亲结点的关键字会减少1,如有需要重复以上过程
### B+树
B+树时应文件系统所需而出的一种B树的变形树
> 一颗m阶B+树和m阶B树的区别有以下几点
> - 子树数量和关键字数量相同
> - 所有的叶子结点包含了所有关键字信息,以及指向这些关键字记录的指针,叶子结点根据关键字自小而大连接
> - 所有的非终端节点可以看作是索引部分,其中仅包含其子树中的最大(最小)关键字

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661685709371-48b5786a-4649-4601-b544-1f21085975a4.png#averageHue=%23fbfbfb&from=url&id=wb9wE&originHeight=410&originWidth=1225&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43271&status=done&style=none&title=" width="600" /> </div>


<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661686171672-ae12de79-c6ec-4b0f-95e9-065365604c4c.png#averageHue=%23e8e8e8&clientId=u83feaa30-a534-4&from=ui&id=ua3602922&originHeight=829&originWidth=2220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=547071&status=done&style=none&taskId=ua71e9224-2046-4bbc-85ae-b8d7ee8173e&title=" width="600" /> </div>

---


<br/>


<br/>


<br/>


## 散列表的查找  
记录的存储位置和关键字之间存在对应关系，用空间效率换取时间效率，选取某个函数，依据该函数按关键字计算元素的存储位置，并按此存放。查找也是按照该函数进行查找
哈希函数：散列方法中使用的转换函数
冲突：不同的关键字映射到同一个地址
使用哈希表要注意的问题

- 构造好的哈希函数
   - 函数尽可能简单，以便提高转换速度
   - 哈希函数计算出的地址，应在散列地址集中致均匀分布，已减少空间浪费
- 制定好的冲突解决方案
   - 查找时，如果从哈希函数计算出的地址中查不到关键字，应该按照处理冲突的规则，有规律查询其他相关单元
### 散列函数的构造

- 直接定址法
   - $H(key)=key$或$H(key)=a\cdot key+b$
   - 不会产生冲突
   - 占用连续地址空间，空间效率低
- 除留余数法
   - $H(key)=key\ \mod\ p\ \,p<=m$(p为质数)
### 处理冲突的方法

- 开放地址法
   - $H_i=\left( H\left( key \right) +d_i \right) \ mod\ m\ ,i=1,2,....,k\left( k\le m-1 \right)$
   - $d_i$为增量序列，有以下3种取法
      - 线性探测法——$d_i=1,2,3,...,m-1$
      - 二次探测法——$d_i=1^2,-1^2,2^2,-2^2,...,\pm k^2\left( k\le \frac{m}{2} \right)$
      - 伪随机探测——$d_i$为伪随机序列
   - 有聚集现象，在处理同义词冲突时，增加了非同义词的冲突，对查找不利
- 链地址法（拉链法）
   - 把所有同义词存储在同一个线性链表中
   - <div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1661584644958-153985ba-38a9-4acb-af43-f6b8d6bfa507.png#averageHue=%23fafafa&from=url&height=719&id=ujXdX&originHeight=719&originWidth=1203&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59893&status=done&style=none&title=&width=1203" width="600" /> </div>


   - 非同义词不会冲突，无聚集现象
   - 链表表长动态分布，更适合表长不确定的情况
### 哈希表查找效率分析
ASL和哈希函数、处理冲突的方法和哈希表的装填因子有关

- 哈希函数：哈希函数的好坏首先影响出现冲突的频繁程度
- 装填因子：$\alpha =\frac{\text{表中填入记录数}}{\text{哈希表的长度}}$，直观的看装填因子越小，发生冲突的可能性越小
- 处理冲突的方法
   - 线性探测$ASL\approx \frac{1}{2}\left( 1+\frac{1}{1-\alpha} \right)$
   - 随机探测，二次探测$ASL\approx \frac{1}{\alpha}\ln \left( \alpha -1 \right)$
   - 链地址法$ASL\approx 1+\frac{\alpha}{2}$
# 排序
## 基本概念
排序：对于某个序列，使其对应的关键字满足非递减或非递增关系的操作。若排序的是主关键字，则排序结果唯一，若排序的关键字是次关键字，排序结果不唯一。假设$K_i=K_j(1\le i<j \le n)$，若排序后对应的元素仍然满足，$R_i$在$R_j$之前，则该排序算法是稳定的，否则则是不稳定的。
内部排序：待排序记录存放在存储器中进行排序的排序过程。
外部排序：待排序记录数量很大，以至于内存不能一次容纳全部记录，在排序过程中尚需要对外存进行访问的过程。
## 插入排序
### 直接插入排序
将一个记录插入到已经排序好的有序表中，从而得到一个新的，记录数增加1的有序表。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/gif/29674612/1662077050531-b32d4e4d-3c5a-40cc-8e23-4bec6b8d7f46.gif" width=700 /> </div>


当原序列是正序时，关键字比较次数$\sum_{i=2}^n{1}=n-1$，当原序列是倒序时，关键字比较次数最多，为$\sum_{i=2}^n{i}=\frac{\left( n+2 \right) \left( n-1 \right)}{2}$，直接插入排序时间复杂度为$O(n^2)$
### 折半插入排序
结合了二分查找的思想，减少了关键字比较次数，但记录移动的次数不变，时间复杂度依然为$O(n^2
)$
### 希尔排序(Shell Sort)
缩小增量排序。当待排记录基本有序时，直接插入排序的时间效率大大提高，因此希尔排序的基本思想：先将待排序记录分为若干子序列分别进行直接插入排序，当整个序列基本有序后，再对全体记录进行一次直接插入排序。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/gif/29674612/1662078404639-17c440c2-3a46-466a-afb8-cabaa5617313.gif" width="600" /> </div>


增量序列可以有多种取法，但是必须满足以下条件：

- 增量序列中的值，除了1以外没有别的公因子（其实不一定）
- 最后一个增量值必须为1

希尔排序的分析相当复杂，但增量序列为$dlta[k]=2^{k+1}-1$时，希尔排序时间复杂度为$O(n^{3/2})$
## 快速排序
借助交换来进行排序的方法
### 起泡排序（Bubble Sort）
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/gif/29674612/1662077744424-2bf54eca-00fc-4878-bc3b-9be06dac02fa.gif" width="600" /> </div>


若初始序列为正序，只需要进行一趟起泡排序，不需要交换元素，关键字比较次数为$n-1$，当初始序列为逆序时，关键字比较次数$\sum_{i=n}^2{i}=\frac{\left( n-1 \right) \left( n \right)}{2}$，并且要作同等数量级的交换，时间复杂度$O(n^2)$
### 快速排序(Quick Sort)
通过一趟排序，将序列分为两部分，其中部分的的记录都比另一部分的关键字小，再分别对这两个序列进行排序，直到整个序列有序。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/gif/29674612/1662079567565-c737d525-4838-4d9f-aeaf-4ce4d9c34b61.gif" width="600" /> </div>


快速排序的平均时间为$T_{avg}=knlnn$,$k$为某个常数，经验表明，再所有同数量级的此类排序算法中，快速排序的常数因子最小。
当关键字有序或基本有序的时候，固定选取一边作为关键字的做法会使快速排序退化为冒泡排序。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29674612/1662363605930-bf277322-8db4-493c-9564-bc11ebd1935b.jpeg" width="400" /> </div>


为避免时间复杂度退化为$O(n^2)$，可以采用“三者取中”的方法选取枢纽记录，即选取待排序列的左端记录、右端记录和中间记录，其中中值的记录作为枢纽记录。
## 选择排序
### 简单选择排序
在待排序列中选取最小的记录，并和待排序列的第一个记录交换。
### 堆排序（Heap Sort）
利用之前比较得出的信息，减少以后各趟排序比较的次数
堆：n个元素的序列$\left\{k_1,k_2,...,k_n\right\}$满足以下关系：$\left\{ \begin{array}{l}
	k_i\le k_{2i}\\
	k_i\le k_{2i+1}\\
\end{array} \right.$，（实质上使将完全二叉树存储在一维数组里面）
堆排序：输出堆顶元素，使得剩余的n-1个元素序列重新建成一个堆，则得到n个元素的次小值，如此反复执行，便能得到一个有序序列。
如何在输出堆顶元素后，将剩余元素调整成一个新的堆？

- 将最后一个元素放到堆顶
- 该元素不断与子结点进行比较，然后位置互换
- 重复上一步操作，直到该元素被调整到叶子
- 这个自堆顶到叶子的过程称为“筛选”

如何由一个无序序列建成一个堆？

- 从最后一个非叶子结点（第$\lfloor \frac{n}{2} \rfloor$个元素）开始往堆顶元素，每一个元素都进行筛选的过程
## 归并排序
将两个或两个以上的有序表组合成一个新的有序表
二路归并排序：

- 将有n个元素初始序列看作是n个有序序列
- 两两归并得到$\lceil \frac{n}{2} \rceil$个有序子序列
- 重复以上步骤，直到得到一个长度为n的有序序列

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1662377660259-9009fc2c-9674-4259-949f-5e611765fcd1.png" width="469" /> </div>


## 基数排序（Radic Sort）
基数排序不需要关键字之间的比较，是一种借助多关键字排序的思想对单逻辑进行排序的方法。
## 各种排序算法的比较
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2022/png/29674612/1662378904361-087335b5-59c2-4d4c-b6c5-49be2b989593.png" width="600" /> </div>

---