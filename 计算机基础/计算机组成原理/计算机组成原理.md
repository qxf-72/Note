<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-02-22_150051.png" width="500" />
</center>


# 概论

## 计算机系统简介

### 计算机系统软硬件概念

**计算机系统**由**硬件**和**软件**两大部分组成，计算机性能的好坏取决于软硬件功能的总和
- 硬件：计算机的实体部分
- 软件：事先编制好的具有各类特殊功能的程序组成
   - 系统软件：用来管理整个计算机系统，监视服务，使系统资源得到合理调度，高效运行。
   - 应用软件：用户根据任务需要所编制的各种程序。

---

<br/>


<br/>


### 计算机系统层次结构
**虚拟机器**：并不是实际存在的机器
- 高级语言机器M4：用编译程序翻译成汇编语言程序
-  汇编语言机器M3：将汇编语言翻译成机器语言
- 操作系统机器M2：由操作系统软件构成，用机器语言解释操作系统，提供了在汇编语言和高级语言的使用好的实现过程中所需的基本操作，控制并管理计算机系统的全部硬件和软件资源

**实际机器**：也就是实际存在的硬件层
- 传统机器M1：执行机器语言程序
- 微程序机器M0：将M1中的每一条机器指令翻译成一组微指令，即构成一个微程序，然后执行。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-01-03_181544.png" width="600" />
</center>

---


<br/>


<br/>



### 计算机组成和计算机体系结构

**计算机体系结构**

机器语言或汇编语言程序员所能看到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等。站在不同层次上编程的程序员所看见的计算机的属性各不相同。

<br/>

**计算机组成**

指如何实现计算机体系结构所体现的属性。其包含许多对于程序员来说透明的硬件细节。

例如，指令系统属于计算机体系结构的问题，但是指令的实现（如何取指令、分析指令、取操作数）属于计算机组成的问题。因此两台机器的指令系统相同时，只能认为具有相同的结构，至于两台机器如何实现其指令，可以不同（组成方式不同）。

---


<br/>


<br/>


<br/>


## 计算机的基本组成

### 冯诺依曼计算机

数学家冯诺依曼体现出来了“存储程序”的概念，以此概念设计的各类计算机通称冯诺依曼机，有以下特点：
- 由运算器、存储器、控制器、输入设备、输出设备**5部分构成**
- 指令和数据以同等地位存放在存储器内，并可以按地址寻访
- 指令和数据用二进制数表示
- 指令有操作码和地址码组成。操作码——表示操作性质，地址码——操作数存放在存储器的位置
- 指令在存储器内顺序存放
- 机器**以运算器为中心**，输入和输出设备之间的数据传输通过运算器完成

---

<br/>


<br/>



### 计算机结构

**经典的冯诺依曼计算机**：以运算为中心

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-01-03_203853.png" width="500" />
</center>


<br/>


**现代计算机**：以存储器为中心

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-01-03_204014.png" width="500" />
</center>



**计算器各部件功能**
   - 运算器：完成算术运算，并存放运算的中间结果
   - 存储器：存储数据和程序
   - 控制器：用来控制、指挥程序和数据的输入、运行以及处理运算结果
   - 输入设备：将人们熟知的信息形式转换为机器能识别的信息形式，如键盘、鼠标
   - 输出设备：将机器运算结果转换为人们熟悉的信息形式


<br/>


> 计算机以上五个部件都在控制器的统一指挥下，有条不紊的工作。由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，往往集成在同一芯片，合称**中央处理器 CPU**。
> 
> 现代计算机可以认为由三部分组成：CPU、I/O 设备及主存储器。其中 CPU 和主存可以合称**主机**，IO 设备称为外部设备。结构如如下：
> 
> <center>
> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-01-03_210603.png" width="600" />
> </center>

---


<br/>


<br/>



### 计算机组成部件

**主存储器**

- 存储器M：存储器由许多**存储单元**构成，每个存储单元包含若干**存储元件**，每个存储元件能存储一位二进制代码，故每个存储单元能存储一串二进制代码，这个二进制代码长度称为**存储字长**，给每个存储单元一个编号，称为地址号。
- 存储器地址寄存器**MAR**（Memory Address Resgister）：存放要访问的存储单元的地址，位数对应存储单元个数。
- 存储器数据寄存器**MDR**（Memory Data Resgister）：存放从存储单元取出的 或者 存入某存储单元的代码。

随着硬件技术发展，主存制成大规模集成电路芯片，**MAR 和 MDR 集成在 CPU 中**。


<br/>


**运算器**

包含一个**算术逻辑单元（ALU）** 和  **3个寄存器**：
- 累加器ACC（Accumulator）
- 乘商寄存器MQ（Multiplier-Quotient Resgister）
- 操作数寄存器 X

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-01-05_075228.png" width="700" />
</center>

还可以包含：变址寄存器 IX，基址寄存器 B，程序状态字寄存器 PSW（记录 ALU 运算得到的一些标志信息和 CPU 的状态信息）。



<br/>


**控制器**

工作过程分为 取指阶段、分析阶段、执行阶段。由以下部分组成：

- 程序计数器PC（Program Counter）：存放**将要执行**的指令的地址，和MAR之间存在通路。
- 指令寄存器 IR（Instruction Register）：存放当前指令，来自MDR。
- 控制单元CU：分析指令操作，发送微操作命令序列。


<br/>


**I/O**

包括 IO 设备和响应接口，IO 设备通过 IO 接口和主机联系，接收 CU 控制命令，完成对应操作。


---


<br/>


<br/>


<br/>


## 计算机性能指标

**机器字长**

计算机进行一次整数运算能处理的二进制位数。字长一般等于通用寄存器的位数或 ALU 宽度。

> 
**计算机位数**通常指的是计算机处理和存储数据的基本单位的大小，即机器字长。计算机的字长决定了它可以一次性处理的数据的位数。
> 
> **操作系统位数**是指操作系统设计时所支持的**最大地址空间大小**。32 位操作系统最大可以支持到 4 GB 的内存地址空间，而 64 位操作系统可以支持更大的地址空间，通常是 16 EB（即 16 * 10^18 Bytes）。

<br/>

**数据通路宽度**

数据总线（外部数据总线）一次能够并行传送到信息的位数。

<br/>

**主存容量**

即主存储器的容量，与 MAR、MDR 密切关联。


<br/>

**运算速度**

- 吞吐量：系统在单位时间处理的请求的数量。与主存储器密切相关，系统吞吐量主要取决于主存储器的存取周期。
- 响应时间：用户想计算机发送一个请求，到系统对该请求作出相应并获取到结果的等待时间。

> **CPU 时钟周期**：机器内部主时钟脉冲信号的宽度。是 CPU 工作的最小时间单位。
> 
> **主频**：机器内部主时钟频率，即，时钟周期的倒数。**每 1秒含有的时钟周期的数量**。

- **CPI**（Cycle Per Instruction）：执行一条指令需要的时钟周期数。不同指令的时钟周期可能不同，所以 CPI 指的该程序或该机器指令集中所有指令执行的**平均**时钟周期数。
- **CPU 执行时间**：运行一个程序花费的时间。

$$
CPU\text{执行时间}=\frac{\text{时钟周期数}}{\text{主频}}=\frac{\text{指令条数}\times CPI}{\text{主频}}
$$

- **MIPS**（Million Instructions Per Second）：每秒执行多少百万条指令。MIPS 对于不同机器进行性能比较是有缺陷的。不同机器的指令集不同，指令的功能也不同；不同机器的 CPI 和时钟周期也不同。

$$
MIPS=\frac{\text{指令条数}}{\text{执行时间}\times 10^6}=\frac{\text{主频}}{CPI\times 10^6}
$$

- **FLOPS** （Floating-point Operations Per Second）：每秒执行多少次浮点运算。
	- **M**FLOPS：每秒执行多少百万次浮点运算。
	- **G**FLOPS
	- **T**FLOPS
	- **P**FLOPS
	- **E**FLOPS
	- **Z**FLOPS


> <span style="background:#fff88f">在描述**存储容量、文件大小**时，K、M、G、T 通常用 **2 的幂次**表示。</span>
> 
> <span style="background:#fff88f">在描述**速率、频率**时，通常用 **10 的幂次**表示。</span>



---


<br/>


<br/>


<br/>


<br/>



# 总线

## 总线基本概念

**计算机系统部件之间互连方式**

- 分散连接：个部件之间采用单独的连线
- 总线连接：将各部件连到一组公共的信息传输线

总线是各部件共享的传输介质，在某一时刻只允许最多一个部件发送信息，而多个部件可以同时从总线接收信息。

<br/>

**现代计算机采用各类总线结构**

- 以 CPU 为中心的双总线结构：便于增删 IO 设备，但是 IO 设备和主存交换信息会占用 CPU。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-02-22_151928.png" width="500" />
</center>

- 单总线结构：IO设备和主存交换信息时，原则上不会占用CPU，但是只有一组总线，影响整机工作速度。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-02-22_152144.png" width="500" />
</center>

- 以存储器为中心双总线结构：在单总线的基础上，在 CPU 和主存之间开辟一条存储总线。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-02-22_152414.png" width="500" />
</center>

----

<br/>


<br/>


<br/>


## 总线分类

按照连接部件不同，可分为三类

- 片内总线：芯片内部的总线，如在 CPU 芯片内部，寄存器和寄存器、寄存器和 ALU 之间通过片内总线连接。
- 系统总线：系统总线是指 CPU、主存、IO 设备各部件之间的信息传输线，按照传输的信息不同有可以分为三类：
   - 数据总线：传输各部件之间的数据信息，是双向传输线。
   - 地址总线：由CPU输出，单向传输。
   - 控制总线：发出各种控制信号的传输线。
- 通信总线：用与计算机系统与计算机系统、其他系统之间的通信，并行通信适宜与近距离通信，串行通信适宜与远距离通信。

---

<br/>


<br/>


<br/>

## 总线结构

### 单总线结构

所有设备都挂在一组总线上。结构简单，易于扩充，但是所有传输都通过共享总线，极易形成计算机系统瓶颈，多被小型或微型计算机采用。

---

<br/>


<br/>


### 多总线结构

- **双总线结构**：将速度较低的 IO 设备从单总线上分离出来，形成主存总线和 IO 总线分开的结构。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-06_080831.png" width="500" />
</center>

- **三总线结构（1）**：将速率不同的 IO 设备进行分类，连接到不同通道上。**DMA 总线用于高速 IO 设备与主存直接交换信息**。任一时刻只能使用一种总线。

> DMA（Direct Memory Access，直接内存访问）是一种允许某些硬件子系统在不经过CPU的直接干预下，直接读写系统内存的技术。DMA主要用于高速数据传输，可以显著提高数据传输效率，减少CPU的负载。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-06_081235.png" width="500" />
</center>

- **三总线结构（2）**：**CPU 与 Cache 之间有一条局部总线**，将 CPU 与 Cache 或与更多设备连接。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-06_081603.png" width="450" />
</center>


- **四总线结构**：增加**高速总线**，在高速总线上接挂了一些高速 IO 设备

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-06_081818.png" width="500" />
</center>



---

<br/>


<br/>



### 总线结构举例

**传统微型计算机总线结构**

**高速和低速 IO 都挂接在 ISA 或 EISA 总线上**，并通过总线控制器与系统总线相连，势必出现总线数据传输瓶颈。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-06_082813.png" width="500" />
</center>

<br/>

**VL-BUS 局部总线结构**

为了消除以上总线结构瓶颈问题，将高速、高性能外设尽量靠近 CPU 本身总线，并**对 CPU 同步或准同步**；**局部总线 VL-BUS 相当于在 CPU 和高速 IO 之间架上了高速通道**。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-06_083214.png" width="500" />
</center>

<br/>

**PCI 总线结构**

VL-BUS 是一种早期总线技术，并且由于以上的总线结构中 CPU 和 VL-BUS 过于紧密（VL-BUS 是一种本地总线，直接连接到 CPU 的主板插槽上），**由于 VL-BUS 有工作频率限制，很难支持功能更强的 CPU（VL-BUS 需要和 CPU 同步**），由此出现了 PCI 总线结构；**CPU 总线与 PCI 总线相互隔离，具有更高灵活性**，可以支持更多高速设备，具有**即插即用**的特性。

> PCI（Peripheral Component Interconnect，外围组件互连）是一种计算机总线标准，用于计算机内部硬件设备之间的连接和通信。PCI 总线允许不同的硬件组件（如网络卡、声卡、图形卡等）与计算机的中央处理单元（CPU）和内存系统进行高速数据交换。6 

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-06_084716.png" width="500" />
</center>


---

<br/>


<br/>


<br/>


## 总线控制

### 总线判优控制

总线上连接的各类设备按照对总线的控制功能分为：主设备（有控制权）、从设备（只能响应主设备发来的总线命令）。

当多个设备同时使用总线时，就由总线控制器的判优逻辑按照一定优先等级确定哪个主设备能能使用总线。总线判优控制分为：

- **集中式**（将控制逻辑集中到某一处）
- **分布式**（控制逻辑分散在与总线相连的各个部件上）

常见的集中控制优先仲裁方式有以下三种：

- **链式查询**：3根线用于总线控制（BS 总线忙，BR 总线请求，BG 总线同意）。如果 BG 到达的接口有总线请求，就不再往下传，而是建立 BS 信号，离总线控制部件最近的部件具有最高优先级。只需很少几根线就能实现总线判优控制，易于扩充设备，但对电路故障很敏感，优先级低的设备很难获得请求 。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-06_180251.png" width="500" />
</center>

- **计数器定时查询**：少了总线同意线 BG，多了设备地址线。总线控制部件，在收到总线请求信号后（总线空闲），启动计数器（可以设定初始值，计数也可以从上次计数终点开始，此时各设备优先级相同），并通过设备地址线向各设备发送地址信号 （计数器的值），当地址信号和请求占用总线设备地址值一致时，获得总线控制权，停止计数。优先级次序可以改变，对电路故障不如链式查询方式敏感，但是增加了控制线数，控制也较复杂， $\lceil \log _{2}^{n} \rceil$ 条线确定总线使用权。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-06_181110.png" width="540" />
</center>


- **独立请求方式**：每一台设备都有一对总线请求线 BR 和总线同意线 BG，总线控制部件内有排队电路。响应速度快，优先次序控制灵活，但是控制线多，总线控制更复杂，2n 条线确定使用权

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-06_181456.png" width="500" />
</center>


---

<br/>


<br/>




### 总线通信控制

通常将完成一次总线操作的时间称为总线周期，可以分为以下四个阶段：
- 申请分配阶段：主设备发出请求，总线仲裁机构决定下一个传输周期的使用者
- 寻址阶段：主模块通过总线发出本次要访问的从模块的地址和有关命令，启动从模块
- 传数阶段：进行数据交换
- 结束阶段：主模块的有关信息从总线上撤除，让出总线使用权

<br/>


总线通信控制通常用以下四种方式：

**同步通信**

由统一时标（通常由 CPU 的总线控制部件发出；也可以由各个部件各自的时序发生器发出，但必须由总线控制部件发出的时钟信号进行同步）控制数据传送。总线上两个部件完成一次完整可靠的信息传输时间称为总线传输周期，包含 4 个总线时钟周期（不等同时钟信号的一个完整振荡周期）。

同步通信优点规定明确、统一，模块之间配合简单一致。缺点是所有模块采用同一时限，必须按照最慢速度部件设计公共时钟。适用于总线长度较短，个部件存取时间比较一致的场合。
	
> <center>
> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_085143.png" width="600" />
> </center>


<br/>


 **异步通信**
 
 允许个模块速度不一致性，给设计者充分灵活性和选择余地。应答方式可以分为以下三种类型：
   - **不互锁**：主模块发送请求信号后，一段时间后撤销信号，从模块发送回答信号后，一段时间后撤销信号。**CPU向主存写信息采用此方式**。
   - **半互锁**：主模块发送请求信号后，必须接受到从模块回答信号才能撤销请求信号，而从模块在发出回答信号后，一段时间后自动撤销信号。例如**CPU访问共享存储器**。
   - **全互锁**：在半互锁的基础上，从模块要的回答信号要等到主模块的请求信号撤销才能撤销。




<br/>



**半同步通信**

保留了同步通信基本特点，所有的地址、命令、数据信号的发出时间严格参照系统时钟的某个前沿，接收方采用系统时钟的后沿时间进行辨识；

同时增设 **等待线**  $\overline{WAIT}$ ，让不同速度模块和谐工作。若从模块无法在 T3 提供数据，就给出等待信号，主模块在 T3 到来之时检测等待信号，若 $\overline{WAIT}$ 为低电平就不立即在从数据线取数，在下一个时钟周期采取一样的行动。

<br/>


**分离式通信**

克服模块内部准备数据过程并无实际数据传输的消极等待。将一个传输周期分为两个子周期：第一个子周期，主模块在获得总线使用权后，将命令、地址和其他有关信息（主模块编号）发送到系统总线上，随后放弃总线使用权，第二个子周期，从模块在收到主模块信息，且准备好数据后，申请得到总线使用权，将主模块编号、从模块地址、数据发送出去，随后放弃总线使用权。




---


<br/>


<br/>


<br/>


<br/>


# 存储系统

## 概述

### 存储器分类

按照**存储介质**分类：
- 半导体存储器：优点是体积小、功耗小、存取时间短，缺点是电源消失时，存储信息会丢失
- 磁表面存储器：具有非易丢失的特点
- 光盘存储器：记录密度高，耐用性好，可靠性高，可互换性强

按照**存取方式**分类：

- 随机存储器RAM（Random Access Memory）：可读/写存储器，存取时间与存储单元的物理位置无关
- 只读存储器ROM（Read Only Memory）：只能将内部信息读出，不能随意重新写入新的信息去改变原始信息。早期只有**掩膜只读存储器MROM**，派生出**可编程只读存储器PROM**、**可擦除可编程只读存储器EPROM（紫外线擦除）**、**电擦除可编程只读存储器EEPROM**，**闪存存储器Flash Memory**（现代计算机的固态硬盘SSD）

> 闪存存储器 和  EEPROM（Electrically Erasable Programmable Read-Only Memory）的最大区别在于它们的工作方式和应用场景：
> - EEPROM一次只能编程或擦除一个字节或一个字，它通常用于存储小容量的数据，如设备设置、系统参数和加密密钥等。EEPROM的使用寿命较长，读取速度较慢，相对较为耗电。
> - 闪存存储器一次可以编程或擦除一个块，块的大小通常为128KB至4MB不等。闪存存储器通常用于存储大容量的数据，如操作系统、应用程序和多媒体文件等。闪存存储器的使用寿命相对较短，读取速度较快，功耗相对较低。

- 串行访问存储器：由于信息所在位置不同，读写时间不同


---


<br/>


<br/>



### 存储器层次结构

存储器由三个主要性能指标：**速度**、**容量**、**位价**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_093752.png" width="250" />
</center>



CPU 和 缓存、主存 都能直接交换信息。

缓存-主存层次解决 CPU 和主存速度不匹配的问题；

主存-辅存层次解决存储系统容量问题。在主存-辅存这一层次的不断发展中，逐渐形成**虚拟存储系统**。程序员编程的地址范围 与 虚拟存储器的地址空间相对应，物理地址是程序在执行过程中真正访问的地址，对于具有虚拟存储器的计算机而言，编程时可用的地址空间远大于主存地址。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_094008.png" width="400" />
</center>


---


<br/>


<br/>


<br/>



## 主存储器

### 概述

根据 MAR 的地址访问某个存储单元时，需要经过地址译码、驱动等电路，才能找到要访问的单元；读出时，需要进过读出放大器、才能将选中单元的存储字，送到 MDR。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_095035.png" width="500" />
</center>



驱动器、译码器和读写电路 集中在 **存储芯片**中，而 MAR 和 MDR 在 **CPU 芯片**中，两芯片通过总线连接，如下图：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_095233.png" width="300" />
</center>



<br/>

**主存中存储单元地址的分配**

存储字长都取 8 的整数倍，计算机系统既可以按照字寻址，也可以按照字节来寻址；大端方式计算机采用字节高位字节的地址来表示低地址，小端方式则采用低位。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_185506.png" width="500" />
</center>


<br/>


**主存技术指标**

存储容量和存储速度




<br/>

**主存储器的组成**

> CPU 的任务是到主存中取指令并执行指令，但是 RAM 的特性是断电后数据丢失，所以关机后，主存中的数据丢失，开机时，需要将操作系统和相关的指令数据调入主存，而操作系统安装在辅存中。
> 
> 开机时，由于主存中的数据全部丢失，CPU 需要从主板的 ROM 芯片中读取开机所需指令，也就是主板上的 BIOS 芯片 (ROM)存储了“ 自举装入程序”（CPU 在刚开始需要执行的程序），负责引导装入操作系统 (开机)。ROM 芯片是非易失性的，所以即使芯片没有通电，“ 自举装入程序”指令数据也不会丢失。
> 
> 虽然 ROM 芯片集成在主板上，但是逻辑上，应该把它看作主存的一部分，所以**逻辑上主存由 RAM（内存条）和 ROM（主存上的 BIOS 芯片）组成**，且二者常**统一编址**。
> 
> <center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-08-01_154829.png" width="300" />
</center>



---
<br/>


<br/>


### 半导体存储芯片简介

**基本结构**

芯片内集成 具有记忆功能的**存储矩阵**、**译码驱动电路**和**读/写电路**。

译码驱动电路能 **把地址信号翻译成对应存储单元的选择信号**，选择信号在读写电路的配合在完成对选中单元的读写操作，读写电路包括读出放大器和写入电路。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_183300.png" width="500" />
</center>



**地址线是单向输入的**，**数据线是双向的**，控制线主要有读写控制线和片选线（半导体存储器由许多芯片组成，需要用片选线选择存储芯片）：

> 片选线为$\overline{CE}$或$\overline{CS}$，读写控制线可以用一条$\overline{WE}$（低电平读，高电平写）也可以用两条$\overline{OE}$（读）$\overline{WE}$（写）。
> 
> 半导体存储器中，一个字通常是以位组（bit group）的形式存储在多个芯片中。每个芯片负责存储位组中的一个或几个二进制位（bit），而多个芯片则协同工作，将这些位组合成一个完整的字。
> 例如，在一个32位字的存储器中，可以使用4个8位芯片来存储每个字节。当计算机需要读取或写入一个字时，它会将存储地址解码为芯片地址和位组地址，然后使用读写控制信号将数据发送到正确的芯片和位组。最终，存储器会将多个位组合并成一个完整的字，然后将其返回给CPU或者写入存储器。
> <center>
> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_190951.png" width="500" />
> </center>




<br/>


**译码驱动方式**

- **线选法**：当地址线很多时，需要很多的译码输出线。**只适合容量很小的存储芯片**。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_192737.png" width="400" />
</center>




 - **重合法**：所需的线更少

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_192833.png" width="450" />
</center>

----

<br/>


<br/>



### RAM

**静态 RAM（Static RAM，SRAM）**

SRAM 基本单元电路：用**寄存器存储信息**，每一个基本单元电路有6个 MOS 管组成，如下图：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_202127.png" width="500" />
</center>


SRAM 的读写操作：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_202630.png" width="500" />

</center>


<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_202726.png" width="500" />

</center>



SRAM 举例分析：以 Intel2114 为例，下图为外部特性

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_203038.png" width="400" />
</center>



从上图可以看出，该芯片为1K 4位芯片，而每个基本单元只能存储一位信息，为了一次存取4位信息，将存储矩阵的**列分为4组**，列选择线可以同时控制4组中的一列，如下图：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_203206.png" width="600" />
</center>




<br/>


<br/>



**动态 RAM（Dynamic RAM，DRAM）**

DRAM 基本单元电路：有三管式和单管式两种，都是**靠电容存储电荷来存储信息**，电容上有足够电荷表示 1 ，无电荷表示 0 。

**三管式**：单元电路结构如下，**读出的数据和原来存储的数据相反**，但是在写入时写入信息与存放信息相同。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_204018.png" width="400" />
</center>



**单管式**：单元电路结构如下

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_204702.png" width="200" />
</center>



DRAM 芯片举例分析：三管 DRAM 芯片 Intel 1103

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_205155.png" width="600" />
</center>



单管 DRAM 4116（16K 1位），按理应该有 14 根地址线，但是为了减少芯片封装引脚数，只使用 7 根地址线，分两次将地址信息传送（先传送行地址到行地址缓存器，再送列地址到列地址缓存器）。

下图的芯片示意图中，有**读放大器（跷跷板电路，两边电平相反）**，所以 0 到 63 行要写入的数据和实际存储信息相反，读取时读取出来信息和存储的信息相反（**两次取反**，导致原来存入什么后面就可以读出什么）。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-07_205529.png" width="500" />
</center>



<br/>


<br/>



**DRAM 刷新**

**电容的电荷一般只能维持1~2ms**（毫秒 ms），信息会自动消失，必须在2ms 内对所有存储单元恢复一次原状态，也就是刷新；<span style="background:#fff88f">**刷新只与行地址有关，即一行一行地刷新**</span>，DRAM 的刷新有以下几种方式：

- **集中刷新**：刷新时存储器不能进行读写操作，这段时间称为“死区”。以存取周期为 $0.5\mu s$ 的 $128\times 128$ 为例：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-13_084235.png" width="500" />
</center>

- **分散刷新**：即每进行一次读写操作就刷新一行存储单元，没有死区，但是存储周期翻倍。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-13_084525.png" width="500" />
</center>




- **异步刷新**：将集中刷新和分散刷新结合。假设有 $n$ 行，只要在 $\frac{2ms}{n}$ 时间内对一行刷新，在 $2ms$ 之后即可以完成对所有单元的刷新 。如果将刷新安排在指令编译阶段（此时存储器无读写），不会出现“死区”。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-13_084936.png" width="500" />
</center>



<br/>


<br/>


**SRAM 与 DRAM 对比**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-13_085213.png" width="500" />
</center>



---


<br/>


<br/>



### ROM
按照 ROM 的原始定义，ROM 只能读不能写，但是随着用户的需求，出现了 PROM、EPROM、EEPROM 等可写的 ROM。


<br/>

**掩膜 ROM**

**出厂时就设置好了存储器内存储的数据**，行列相交处有MOS管存储“1”，没有MOS管存储“0”，用户无法改变原始状态。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-14_085205.png" width="500" />
</center>



<br/>


**PROM**

PROM 可以实现**一次性编程**，其基本单元中有一段熔丝，熔丝未断存储“1”，已断开存储“0”，由于断开的熔丝没办法再恢复，所以 PROM 只能一次编程。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-14_085707.png" width="400" />
</center>

<br/>



**EPROM**

EPROM 可擦除可编程，基本结构如下，当需要改变状态时，需要用**紫外写照射，将信息全部擦写**。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-14_085921.png" width="400" />
</center>



<br/>


**Flash Memory**

Flash Memory时在EPROM和EEPROM的工艺基础上产生的一种新型的、具有性能价格比更好、更可靠的可擦写非易失性存储器，具有**整片擦写**的特点，擦除重写速度快。

---


<br/>


<br/>


### 存储器与 CPU 的连接

**存储器容量扩展**

对于**位扩展**，以两片1K 4位芯片组成 1K 8位为例，其中两个芯片的数据线分别接到数据总线的四条上面（**不必按顺序**，保证不重合即可），地址总线同时接到两片芯片的地址线上（**不必按顺序**接），片选线和读写控制线同时连接到两片芯片。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-14_090846.png" width="400" />
</center>



对于**字扩展**，以两片1K8位组成 2K8位芯片为例，需要保证芯片不被同时选中，可以利用多出的一条地址线作为片选线。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-14_091320.png" width="500" />
</center>



<br/>


**存储器和CPU的连接**

- 地址线的连接：CPU的地址线往往比存储芯片的地址线多，所以通常**将CPU的地址线低位和存储器地址线相连**，高位在存储器扩充时用，或者作片选信号。
- 数据线的连接：必须使得**芯片位数等于数据线的数量**。
- 读/写命令线的连接
- 片选线的连接
- 合理选择存储芯片：通常选用ROM存放系统程序，RAM为用户编程设置。

对于存储器和 CPU 连接的设计问题，解决步骤为：
（1）进行地址分配，划定芯片的地址范围 
（2）选择合适芯片 
（3）分配 CPU 地址线 
（4）设计片选信号

CPU片选信号很灵活，可以利用多余的地址线结合译码器构成片选信号，同时注意不要忽略$\overline{MREQ}$（访存控制信号，该信号低电平有效时，才会访问存储器），具体例子可参考书本。

---

<br/>


<br/>


### 存储器的校验

任何一种编码是否具有检测能力和纠错能力都与编码的最小距离有关，编码最小距离为某种编码的任意两组合法码字的最小差异位数，根据纠错理论有：

$$L-1=D+C\  \  \   ,D>=C$$

其中 L 为最小距离，D 为检测位数，C 为纠正位数

汉明码的工作原理已经在计算机网络的数据链路层的纠错编码提及，这里仅作补充，汉明码可以按照奇校验或者偶校验配置，偶检验就是让检测位和其被检测的位具有偶数个“1”，奇校验同理。


> **海明码**
> - 确定海明码的位数： $n$ 为信息位, $k$ 为校验位的位数, 则满足 $n+k+1\le 2^k$
> - 检验位的分布：校验位 $P_1$ 分布在 $2^{i-1}$ 位，其余位依次放入信息位
> - 校验码校验的信息位：每个校验位的序号的二进制表示，必然只包含一个 1，校验位负责校验信息位序号对应位为 1 的所有信息位，如图所示：
> 
> <center>
> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-31_142617.png" width="500" />
> </center>
> 
> - 校验位的取值：校验位和对应要校验的数据位进行异或运算，使得结果为 0（即出现偶数个 1）
> - 海明码校验原理：接收方收到数据后，依次对各个检验位和对应要校验的数据位进行异或运算
> 
> $S1=P1\oplus D1\oplus D2\oplus D4$
> 
> $S2=P2\oplus D1\oplus D3\oplus D4$
> 
> $S3=P3\oplus D2\oplus D3\oplus D4$
> 
> 若 $S3,S2,S1$ 为 000，表示无错，否则该序列表示出错位的位置


---

<br/>


<br/>



### 多模块存储器

由于 CPU 的工作速度的增长比存储器快很多，致使主存的存取速度成为计算机系统瓶颈，除了寻找高速元件 和 采用层次结构以外，调整主存的结构可以提高访存速度。

**单体多字系统**

在一个存取周期内，在**同一个地址取出相邻几个存储单元的数据放入数据寄存器**（也就是存储字长比 CPU 字长 长）；

采用这种方法的前提是指令和数据是连续存放的，如果遇到转移指令或者操作数不能连续存放，该方法效果就不明显。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-18_155535.png" width="400" />
</center>



<br/>


**多体并行系统**

采用多体模块组成的存储器，每个模块有独立的MAR、MDR、地址译码、驱动电路和读写电路，可以并行工作也可以交叉工作；多体并行分为以下两种类型：

- **高位交叉**：地址的高位是存储体的序号，低位代表存储体体内的地址；指令和数据一般是顺序存储，对于这种情况，高位交叉方式会对其中一个存储体频繁访问，**不利于并行工作**，故这种方法**多用于存储器容量的扩充**。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-18_160229.png" width="450" />
</center>

- **低位交叉**：地址低位表示存储体体号，高位表示体内地址；将连续的指令、数据分到不同的存储体，便于存储体的并行工作；并行工作时，对于当个存储体而言，存取周期没有缩短，但是由于**CPU可以交叉访问各体，将多个存储体的读写过程重叠，在一个存取周期内，完成多组数据传输**，时序图如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-18_160736.png" width="450" />
</center>

假设每个存储体的存储字长和数据总线宽度一致，低位交叉模块数为 $n$ ，存取周期为 $T$ ，总线传输周期为 $\tau$ ，则采用流水线方式时满足 $T=n\tau$ ；故需要保证某体启动后，至少经过 $n\tau$ 才能再次启动该存储体。

<br/>

**高速芯片**

采用高性能芯片也是提高主存速度的措施，以下对几种高速芯片简单介绍：

- SDRAM（同步 DRAM）：需要同步系统的时钟信号，以处理器-存储器总线的最高速度运行，不许需要插入等待状态，当存储器准备数据时，CPU 给出的地址和控制信号被 SDRAM 锁存，直到指定时钟周期再响应，这段时间内 CPU 可执行其他任务，无需等待。
- RDRAM：解决存储器带宽问题。
- 带Cache的RDRAM：在RDRAM芯片内集成一个SRAM，用于存储上次访问的单元的同一列的所有数据，可以猝发式读取。

---

<br/>


<br/>



## 高速缓冲存储器

### Cache 概述

利用程序访问的局部性原理（时间局部性和空间局部性），主存可以将近期用到的数据以及相邻的数据送到缓存，处理器可以直接从缓存读取信息。

**Cache 的工作原理**

把主存和 Cache 都分为若干块，并且使他们的块大小（即每个块含有多少个字）相等。

当 CPU 要访问主存的某个字时，先查询 Cache，若 Cache 有对应数据，就直接取，如果没有，就访问内存把对应的字所属的块存入 Cache。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-18_185955.png" width="500" />
</center>



<br/>


**效率评估**

假设在一个程序执行期间，访问 Cache 的次数为 $N_C$ ，访问主存的次数为 $N_m$ ，则命中率 $h=\frac{N_c}{N_c+N_m}$ ，设访问一次 Cache 时间为 $t_c$ ，访问一次主存时间为 $t_m$ ，则访问效率 $\frac{t_c}{ht_c+\left( 1-h \right) t_m}$ 。


<br/>


**Cache 基本结构**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-18_190641.png" width="600" />
</center>



Cache主要由以下模块构成：

- Cache存储体
- 地址映射变换机构：将主存地址的块号进行查询，并判断是否命中
- 替换机构：当Cache已满时，且需要写入新的块时，判断被替换的块

<br/>

**Cache 的写操作**

写入的操作比较复杂，需要保证对Cache写入的信息和主存中的信息同步，有以下两种策略：

- **写直达法（Wirte-through）**：进行写操作时数据既写入Cache，有写入主存；很好保证了一致性问题，但是增加访问一次，例如进行求和操作时，和数改变一次数据，就要访问一次内存。
- **写回法（Wirte-back）**：写操作时，只把数据写入Cache，当Cache数据被替换时才写入内存；对于多处理器系统，**每个处理器都有独立Cache，该方法存在Cache一致性的问题**。

<br/>


**Cache的改进**

- **多级缓存**：随着集成电路逻辑密度的提高，把缓存和CPU集成在同一个芯片上面，称为片内缓存，可以提高外部总线利用效率；在片内缓存和主存之间也有片外缓存，也就是二级缓存。
- **统一缓存和分立缓存**：现代采用流水线控制的计算机，为了实现同时执行多条指令，通常把Cache分为指令Cache和数据Cache。

---

<br/>


<br/>

### Cache—主存地址映射

**直接映射**

采用的是固定的映射关系，核心思想为：假设 Cache 中块的数量为 $C$ ，将主存分为每个含有 $C$ 个字块的组，设 $i$ 是 Cache 的块号， $j$ 为主存块号，则 $i=i\ mod\ C$ ；本质上将主存上多个块映射到 Cache 某个固定的块。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-18_193013.png" width="550" />
</center>


<br/>


**全相联映射**

灵活性极大的映射，核心思想是：主存中的一个块可以存储到 Cache 任意一个块上面；需要的标志位变多，而且需要把主存的标志和 Cache 中所有标志比较一遍。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-18_193513.png" width="500" />
</center>



<br/>


**组相联映射**

结合了全相联和直接映射的特点，把 Cache 和主存都分为 $Q$ 组，主存某一组中的块，只能映射到 Cache 对应的组里面的块；组相联映射，当只有一组时就是全相联映射，当 $C$ 组时就是直接映射。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-18_194032.png" width="500" />
</center>


---

<br/>


<br/>



### 替换策略

组相联和全相联中，在需要写入输入且Cache已满时，需要考虑替换哪一个块，理想的算法是替换未来很少用到或者很久才用到的块，但很难实现，主要使用的算法有以下：

- **先进先出FIFO算法**：不要记录个字块的使用情况，容易实现开销小，但是不能提高命中率，例如在循环程序中，最早调入的块以后还要用到。
- **近期最少使用LRU（Least Recently Used）**算法：比较复杂，一般采用简化方法，只记录每个块最近一次使用的时间，平均命中率比FIFO高。
- **随机法**：比较简单，不能提高命中率。

---


<br/>


<br/>


<br/>


## 辅助存储器

辅存的特点时不直接与 CPU 交换信息，辅存不是重点，不做记录详情参考课件。

---


<br/>


<br/>


<br/>


<br/>




# 输入/输出系统

## 概述

### I/O 系统的发展

**早期阶段**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_093005.png" width="500" />
</center>

> 早期IO的特点
> - 每个 I/O 设备必须配有**独立逻辑电路**与 CPU 相连（线路散乱庞杂）
> - 输入输出过程穿插在 CPU 执行程序过程之中（CPU 空等）
> - 每个 I/O 设备的逻辑控制电路与 CPU 的控制器紧密构成不可分割的整体（增减或跟换 IO 设备困难）


<br/>


**接口模块和 DMA 阶段**

I/O 设备通过 接口模块 和主机连接，接口中有设备数据通路和控制通路，数据经过接口既起着缓冲作用，有可以完成串-并转换，主机和 IO 交换信息时 CPU 要执行中断程序

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_093503.png" width="350" />
</center>


直接存储器存取 DMA（Direct Memory Access）技术，IO 设备与主存之间有一条直接的数据通路。

<br/>


**具有通道结构阶段**

> 大中型计算机采用 DMA 方式出现的问题：
> - 每台 I/O 设备配置专用 DMA 接口，增加硬件成本
> - CPU 对大量 DMA 接口进行管理，影响效率

通道是用来管理 I/O 设备 以及 实现主存和 I/O 设备之间交换信息的部件（具有特殊功能处理器，不完全独立，依据 CPU 的 I/O 执行进行启动、停止或改变工作状态），有专门通道指令，独立执行通道指令编写的 I/O 程序；工作时，CPU 不直接参与管理，提高 CPU 利用率。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_094047.png" width="300" />
</center>


<br/>

**具有 IO 处理机阶段**

I/O 处理机 独立与主机工作，可以完成 IO 控制、码制转换、格式处理、数据检错纠错，和 CPU 工作并行性更高。


---

<br/>


<br/>


### I/O 系统组成

I/O 系统由 I/O 软件和 I/O 硬件组成。

**I/O 软件**

- I/O 指令：格式如下，操作码用于与其他指令区分，命令码指明要执行的具体操作，设备码是多个 I/O 设备的选择码。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_094701.png" width="300" />
</center>


- 通道指令：是对于具有通道的 I/O 系统专门设置的指令；一般用于指明参与传送的数据组在主存的首地址、字节数、末地址、I/O 设备码、操作命令码。

<br/>


**IO 硬件**

主要有 I/O 接口、设备控制器 和 通道。


---

<br/>


<br/>


### I/O 设备与主机联系方式

**IO设备编址方式** ^5ae088

- 统一编址：将 I/O 地址看成存储器地址一部分，分出部分存储器地址给 I/O 编号。
- 不统一编址：I/O 地址和存储器地址分开，对 I/O 设备的访问必须有**专门的 I/O 指令**。 ^28a070

<br/>


**联络方式**

- 立即响应方式：对于工作速度缓慢的 I/O 设备，与 CPU 联系时，通常已处于某种等待状态， I/O 指令一到就立即响应。
- 异步工作采用应答信号联络：IO 设备和主机速度不匹配时，各自完成自身工作，出现联络信号才准备交换信息。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_100518.png" width="400" />
</center>

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_100623.png" width="400" />
当使用的是串行传送时，双方需要设定一组特殊标记
</center>

<br/>

- 同步工作采用同步时标联络：要求 I/O 设备和 CPU 的工作速度完全同步。

<br/>

**IO设备和主机的连接方式**

- 辐射式：即每个IO设备单独配有一组控制线路和信号线，不利于增删设备
- 总线式

---

<br/>


<br/>


### I/O 设备与主机信息传送控制方式

**程序查询方式**

由 CPU 不断通过程序查询 I/O 设备是否做好准备，从而控制 I/O 设备与主机交换信息；只要启动 I/O 设备，CPU 便处理踏步状态，I/O 准备就绪之后也只能一个字一个字的从 I/O 设备取出，**由 CPU 存入主存**。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_102501.png" width="300" />
</center>


<br/>

**程序中断方式**

中断方式是在查询方式的基础上做了改进：CPU 发出读指令之后，就执行其他操作，**直到 IO 设备准备就绪** 向 CPU 发出中断请求，CPU 中断当前程序，执行 IO 操作，**省去了踏步的无效状态**。

在程序中断和操作过程中，需要保存、恢复原程序状态，需要占用 CPU 内部寄存器，同样是对 CPU 资源的消耗，该方式最终**还是需要通过 CPU 才能实现 IO 设备和主存的信息交流**。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_102955.png" width="500" />
</center>

<br/>


**DMA 方式**

主存和 I/O 设备之间存在数据通路，**当 DMA 和 CPU 同时访问主存时，CPU 将总线占用权让给 DMA**（窃取或者挪用），窃取的时间为一个存储周期，而且在该周期内，CPU 能继续执行内部操作。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_103737.png" width="500" />
</center>


---

<br/>


<br/>


<br/>


## I/O 设备

### 概述

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_190441.png" width="400" />
</center>

I/O设备大致可以分为三类：

- 人机交互设备：键盘、鼠标等
- 计算机信息存储设备：辅存
- 机-机通信设备：调制解调器、网卡等

---

<br/>


<br/>


### 输入设备

**键盘**

判断哪个按键被按下，将按键信息转为 ASCII 码。

工作原理：计数器输出信号控制两个译码器，译码之后就是按键的行列选择信号，通过这种方式循环扫描每个按键，当扫描到的按键被按下，发出脉冲信号，计数器停止计数，计数器的值对应着一按键。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_191300.png" width="500" />
</center>

<br/>

**鼠标**

根据定位的原理，分为机械式和光电式，机械式包含金属球和电位器，光电式包含光电转换器

<br/>


**触摸屏**

主要分为电阻式、电容式、表面超声波式、扫描红外线式和压感式。

---

<br/>


<br/>


### 输出设备

**显示器**

- 字符显示：
- 图形显示：主观图像
- 图像显示：客观图像（照片）

<br/>

**打印机**

- 击打式：点阵式，逐字或逐行打印，目前主要用于购物发票等小票的打印
- 非击打式：激光逐页打印、或喷墨式打印机逐字打印

---

<br/>


<br/>


<br/>


## I/O 接口

### 概述

接口是两个系统或两个部件之间的交接部分，IO接口是主机和IO设备之间设置的一个硬件电路以及相应的软件控制。
> 为什么要设置IO接口？
> - 实现IO设备的选择
> - 通过接口缓冲数据，达到速度匹配
> - 实现数据串并转换
> - 实现电平转换
> - 通过接口发送控制命令
> - 监视IO设备工作状态，保存状态信息，供CPU查询

接口（Interface）不同于端口（port），**端口是指接口电路中一些寄存器，用来存放数据信息、控制信息和状态信息，若干的端口加上相应的控制逻辑才能组成接口**。

---

<br/>


<br/>


### 5.3.2 接口功能与组成
**总线连接方式的IO接口电路**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679399864922-18761bac-d131-41fd-b4b2-e043a67c630c.png#averageHue=%23fbfafa&clientId=uac873f57-3d76-4&from=ui&height=319&id=uaf28ebaf&originHeight=866&originWidth=1082&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=56225&status=done&style=none&taskId=u0ed2d6df-bb07-43dc-abca-58f3527063e&title=&width=399" width="399" /> </div>



- 数据线：根数一般等于存储字长的位数或字符的位数，通常是双向的（如果是单向的，则需要两组）。
- 设备选择线：设备选择线可以有一组或两组（多的一组用于IO设备向主机回送设备码）。
- 命令线
- 状态线：将IO设备的状态报告给主机得信号线，时一组单向总线。

**接口的功能和组成**

- 选址功能：通过设备选择线的设备进行确定。
- 传送命令：接口中设有存放命令的命令寄存器以及命令译码器，命令线和所有接口电路的命令寄存器连接，只有被选中设备的SEL信号（选择信号）有效，命令寄存器才会接受命令线上的命令码。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679400320988-08647a26-5cb0-4a0d-993a-659babeab0ae.png#averageHue=%23e8e8e8&clientId=uac873f57-3d76-4&from=ui&height=283&id=u0c8c3bc4&originHeight=360&originWidth=445&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=74570&status=done&style=none&taskId=u12c03b32-3294-4561-a20c-5791c33ff28&title=&width=350" width="350" /> </div>



- 传送数据：接口中具有数据通路；通常具有数据缓冲寄存器DBR（Data Buffer Register），与IO总线的数据线相连。
- 反映设备的工作状态：接口设有反映设备状态的触发器。
> 完成触发器D：D为1表示设备完成工作
> 工作触发器B：B为1表示设备正在工作
> 中断请求触发器INTR：为1时，表示IO设备向CPU发出中断请求
> 屏蔽触发器MASK：和INTR配合使用，完成设备屏蔽功能

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679401215041-489f703e-548a-4dfc-ab68-88a83f23df5d.png#averageHue=%23f7f6f6&clientId=uac873f57-3d76-4&from=ui&id=u8456fa60&originHeight=691&originWidth=1613&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=105156&status=done&style=none&taskId=ud653715b-08fd-4e70-9c3a-bd11bcb823b&title=" width="600" /> </div>



### 5.3.3 接口类型
按数据传送方式分类：

- 串行接口
- 并行接口

按功能选择灵活性分类：

- 可编程接口：接口功能以及操作方式可以用程序来改变或选择
- 不可编程接口：硬连线逻辑实现功能

按通用性分类：

- 通用接口：可供多种IO设备使用
- 专用接口：

按数据传送控制方式分类：

- 程序型接口：用于连接速度较慢的IO设备，如终端、键盘，现代计算机一般采用程序中断方式与IO设备信息交换
- DMA型接口：用于连接高速IO设备


## 程序查询方式
### 5.4.1 程序查询流程
当有多个IO设备需要查询时，CPU需要按照IO设备优先级进行逐级查询。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679402440532-4d01eb19-8c75-43ef-8cbd-377dc9597f33.png#averageHue=%23f9f9f9&clientId=uac873f57-3d76-4&from=ui&height=395&id=u349d8126&originHeight=1008&originWidth=894&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=60267&status=done&style=none&taskId=u48904a34-4c9f-4d33-bcf8-c6e6a3822bb&title=&width=350" width="350" /> </div>


完成查询通常需要执行以下指令

- 测试指令：查询IO设备是否准备就绪。
- 传送指令：IO设备准备就绪，开始传送。
- 转移指令：IO设备未准备就绪，执行转移指令，转移回到测试指令。

单个IO设备程序查询的具体流程如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679402626201-ee5fa576-b0e1-4a72-8146-9f2b1e23801d.png#averageHue=%23f9f9f8&clientId=uac873f57-3d76-4&from=ui&height=451&id=ud7d1876b&originHeight=1155&originWidth=896&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=72721&status=done&style=none&taskId=u94dd0c5f-f694-4430-93ec-ee740139dcb&title=&width=350" width="350" /> </div>



- 程序查询方式需要占用CPU资源，执行程序程序之前需要保存寄存器原有内容
- 计数器用于设置要传输的数据的数量（计数器可以设置为原码，依次减一；也可以设为补码，依次加一）

### 5.4.2 程序查询方式接口电路
以IO输入为例，电路基本组成如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679402852902-bbadbf8d-d977-40e4-a6be-037e3ffb09fc.png#averageHue=%23f7f6f6&clientId=uac873f57-3d76-4&from=ui&height=239&id=u4cd8aaf0&originHeight=779&originWidth=1631&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=83785&status=done&style=none&taskId=u30672b4b-2fde-4d4d-9b0f-57e8c5ff49b&title=&width=500" width="500" /> </div>




## 程序中断方式
### 5.5.1 中断的概念
计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的执行，处理异常情况或特殊请求，处理结束后返回现行程序简短处，继续执行。
中断是现代计算机能有效合理发挥效能和提高效率的一个重要功能。

### 5.5.2 I/O中断产生
以下以打印机为例，显示IO程序中断的过程
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679405496922-3170d58d-4f6c-4384-9073-4fbc395c2b49.png#averageHue=%23fcfcfb&clientId=ue6b64d6d-29fe-4&from=ui&height=288&id=ub8871db7&originHeight=925&originWidth=1605&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=68435&status=done&style=none&taskId=ubba97c48-9918-423d-be2d-5e6a40279b1&title=&width=499" width="499" /> </div>


计算机系统引入中断并不仅仅是为了适应I/O工作速度慢的问题，中断还用于处理突发事件的产生（产生异常）、实现实时控制（控制权从用户程序返回操作系统？）。

### 5.5.3 程序中断接口电路
为了处理I/O中断，在I/O接口电路必须配置相关硬件线路：
**中断请求触发器和中断屏蔽触发器**
当中断请求触发器INTR为1时（接口的完成触发器D状态为1），表示该设备发出中断请求。
当有多个中断源时，CPU对各种中断源进行排队，优先处理优先级最高的请求，不允许其他中断源中断正在执行的中断服务程序，需要设置屏蔽触发器MASK，MASK为1时，INTR被屏蔽。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679406023280-5e2ca268-aac3-4675-a61a-e95066ab07c1.png#averageHue=%23f5f5f5&clientId=ue6b64d6d-29fe-4&from=ui&height=282&id=u47bdc919&originHeight=884&originWidth=940&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=42833&status=done&style=none&taskId=u9b2b7e2e-1f1f-448e-95f6-75b11f77c74&title=&width=300" width="300" /> </div>

 

**排队器**
给不同IO请求不同优先级，对于速度越高的IO设备优先级越高（若CPU不及时响应高速IO的请求，其信息可能会丢失）。
设备优先级的处理，可以采用软件方法或硬件方法，硬件方法的实现方法：可以在CPU内部对中断源设置一个统一的排队器；也可以在接口电路内分别设置各个设备的排队器——链式排队器：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679620266031-f69cf5de-3b65-4a93-8e56-22c677f5c764.png#averageHue=%23f4f3f1&clientId=u90f2628f-505f-4&from=ui&height=368&id=u7f3db94c&originHeight=1078&originWidth=2049&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=184564&status=done&style=none&taskId=u0a97f5e9-ebae-45bd-a7cd-bdbe7d6bf76&title=&width=700" width="700" /> </div>



**中断向量地址形成部件**
不同的设备有不同的中断服务程序，每个服务程序有一个入口，入口地址的寻找这里介绍硬件向量法：
由设备编码器生成向量地址，找到中断向量（其中保存程序入口地址），从而找到中断服务程序。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679620743788-07de2b6e-d1c6-481b-a75c-0d5b76818830.png#averageHue=%23f3f3f2&clientId=u90f2628f-505f-4&from=ui&height=288&id=ud6fc815e&originHeight=831&originWidth=1729&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=126581&status=done&style=none&taskId=ub75b01a8-080c-43ca-9c99-fc123f36ba8&title=&width=600" width="600" /> </div>


中断向量地址形成部件相当于一个设备编码器，一个例子如下
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679620712473-e53ccf7a-5b79-48fd-bc9a-9d8bae3a3413.png#averageHue=%23f0f0f0&clientId=u90f2628f-505f-4&from=ui&height=398&id=uaf9eb899&originHeight=737&originWidth=1111&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=190139&status=done&style=none&taskId=u8ce0e0ad-1630-4200-b4e9-d1638c0e274&title=&width=600" width="600" /> </div>



**电路结构简化图**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679620896454-10bc355b-1225-4a1e-9816-a8e5309d81f8.png#averageHue=%23efefef&clientId=u90f2628f-505f-4&from=ui&height=335&id=u4bb27092&originHeight=1092&originWidth=1631&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=113539&status=done&style=none&taskId=uff0fd9a4-b046-4aef-9ec4-a60f79de016&title=&width=500" width="500" /> </div>



### 5.5.4 中断处理过程
**CPU响应中断的条件和时间**
CPU能够响应中断的条件是，其中的 允许中断触发器$EINT$ 的值为1，该触发器可用开中断指令置位（开中断），用关中断指令或硬件自动复位（关中断）。

**中断服务的流程**

- 保护现场：保存程序断点（程序计数器PC），保存通用寄存器和状态寄存器的内容
- 中断服务（设备服务）
- 恢复现场：在退出中断服务之前，需要将原程序中断的现场恢复
- 中断返回：通常是中断返回指令
> 单重中断和多重中断
> 单重中断：CPU在执行中断服务程序时，不能执行其他优先级更高的中断服务的请求。
> 多重中断：CPU在执行中断服务程序时，可以执行其他优先级更高的中断服务的请求，与单重中断的区别在于开中断的时间不同。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679621574396-115aca77-7035-4839-af74-2c5daa747e02.png#averageHue=%23ebeaea&clientId=u90f2628f-505f-4&from=ui&height=438&id=ud9dbaff3&originHeight=1125&originWidth=1540&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=126629&status=done&style=none&taskId=ud89ebed4-abbf-4a4d-a5f5-beb599777cc&title=&width=600" width="600" /> </div>



从宏观上看，程序中断方式克服了程序查询方式的CPU原地踏步的现象，实现了CPU与I/O的并行工作。
从微观操作分析，CPU在处理中断服务程序时需要停止原程序的执行，尤其是高速I/O或辅存设备频繁、成批的与主存交换信息时，不断打断CPU主程序的执行。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679621809217-17330996-29ce-4938-91d2-49cda722f2c9.png#averageHue=%23f6f6f6&clientId=u90f2628f-505f-4&from=ui&height=295&id=u6e3e2a97&originHeight=781&originWidth=1590&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=56890&status=done&style=none&taskId=u33553a39-7795-424c-9bdc-a5342bc43bc&title=&width=600" width="600" /> </div>




## DMA方式
### 5.6.1 DMA方式特点
**DMA方式与程序中断的数据通路**
程序询问和程序中断方式都需要使用CPU中的寄存器进行进行数据传送，DMA方式在DMA接口和主存之间有数据通路，不需要通过CPU，工作速度高，适用于高速I/O或辅存与主存之间的信息交换。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679626776533-c9a556ba-cb57-4c31-87a3-e5327fff025e.png#averageHue=%23ebe9e5&clientId=u90f2628f-505f-4&from=ui&height=278&id=u736a3b9c&originHeight=685&originWidth=1231&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=64939&status=done&style=none&taskId=ud646e032-ea36-4f65-96a4-9b3b03a511d&title=&width=500" width="500" /> </div>



**DMA与主存交换数据的方式**

- **停止CPU访问主存**：进行DMA传送时，CPU放弃总线控制权。
   - 优点是控制简单，适用于数据传输率很高的I/O设备实现成组数据传送。
   - 缺点是DMA接口访问主存时，CPU基本处于不工作、保持状态（两次DMA传送之间，数据准备间隔大于存取周期）。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679627459781-462d9973-63df-4a74-ba1d-a3d4b62bc780.png#averageHue=%23f1f1f1&clientId=u90f2628f-505f-4&from=ui&height=149&id=uefe5d442&originHeight=452&originWidth=1512&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=41191&status=done&style=none&taskId=u55282c32-9b8e-4b89-af74-476f238e2d1&title=&width=500" width="500" /> </div>



- **周期挪用（周期窃取）**：当I/O设备发出DMA请求时，I/O设备挪用总线占有权一个或几个周期，当I/O设备发出DMA请求时，有以下情况：
   - CPU不需要访问主存
   - CPU正在访问主存：等待存取周期结束
   - 同时发出访存请求：访存权限交给优先级高的DMA

既实现了IO传输，有很好发挥了主存和CPU效率，该方法被广泛采用。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679627492934-ec47405d-3375-41fb-aed2-a29129a5a4bd.png#averageHue=%23f0f0f0&clientId=u90f2628f-505f-4&from=ui&height=121&id=ub4fa8381&originHeight=364&originWidth=1507&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=28305&status=done&style=none&taskId=uf8b1a6b8-c65a-46fa-9090-d0a27d2ce40&title=&width=500" width="500" /> </div>



- **CPU与DMA交替访问**：适用于CPU工作周期比主存存取周期长的情况，其总线控制权转移几乎不需要什么时间，具有很高DMA传输效率。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679627519589-bd27c467-5b3c-476d-a95a-6ed0020ccd38.png#averageHue=%23f5f5f5&clientId=u90f2628f-505f-4&from=ui&height=167&id=ua90fa9af&originHeight=515&originWidth=1538&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=30953&status=done&style=none&taskId=uc07b4e77-60ed-487a-8a51-11d6121655b&title=&width=500" width="500" /> </div>



### 5.6.2 DMA接口功能和组成
**DMA接口的功能**

- 向CPU申请DMA传送
- 处理总线控制权转交
- 管理系统总线，控制数据传送
- 确定数据起始地址和数据长度，传送过程并修正
- 给出DMA完成信号

**DMA接口的基本组成**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679627779054-296fdfa4-47e0-4405-b5b8-2fa7cb85c635.png#averageHue=%23f3f3f3&clientId=u90f2628f-505f-4&from=ui&height=382&id=ufb1ffddd&originHeight=1021&originWidth=1605&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=79838&status=done&style=none&taskId=u4d4001b4-9a00-487d-b84c-4bee265691c&title=&width=600" width="600" /> </div>



- 主存地址寄存器AR
- 字计数器WC：记录要传输的数据的总字数，通常以交换字数的补码值预置。
- 数据缓冲寄存器DR
- DMA控制逻辑
- 中断机构：WC溢出时，传输结束，请求CPU进行后处理，并不能处理异常事件。
- 设备地址寄存器DAR

### 5.6.3 DMA工作过程
**DMA数据传送过程**

- **预处理**：DMA接口开始工作之前，CPU预置以下信息：
   - 指明数据传输方向
   - 传入设备地址，启动设备
   - 写入AR和WC

以上工作为CPU完成，之后CPU继续执行其他工作

- **数据传送**：以输出为例，过程如下：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679628269478-fb0bc7b2-21bd-4ba0-ab77-75a6479c4d10.png#averageHue=%23f2f2f2&clientId=u90f2628f-505f-4&from=ui&height=364&id=ua24b8303&originHeight=991&originWidth=1633&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=92508&status=done&style=none&taskId=u42c7aea9-3888-4376-9d2a-eb1a785fa76&title=&width=600" width="600" /> </div>



- **后处理**：得到DMA中断请求后，CPU停止原程序执行，做后处理工作：数据检验、决定是否继续使用DMA传送、若DMA出错则进行处理。

**DMA接口与系统的连接方式**

- **具有公共请求线的DMA请求方式**：多个DMA接口通过一条公用的DMA请求线向CPU申请总线控制权，CPU采用链式查询方式选中DMA接口获得总线控制权。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679635643564-a82e6228-a830-4518-97e8-2ca6a7f6deda.png#averageHue=%23eae9e9&clientId=u90f2628f-505f-4&from=ui&height=184&id=u829bf6ef&originHeight=549&originWidth=1494&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=41246&status=done&style=none&taskId=u0f82c1e2-9be8-4183-9e7c-70714189bc1&title=&width=500" width="500" /> </div>



- **独立的DMA请求方式**：每个DMA接口都有一对独立的DMA请求线和DMA应答线。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679635668240-c0b5dfeb-5e08-4323-bcef-6032ed485880.png#averageHue=%23e9e9e9&clientId=u90f2628f-505f-4&from=ui&height=312&id=u251a6e0d&originHeight=871&originWidth=1395&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=61232&status=done&style=none&taskId=ub3f6b532-978e-443b-a6f9-7ae6035476e&title=&width=500" width="500" /> </div>


以上两种方式的优缺点和[总线判优控制](#lMuau)的两种方式类似

**DMA与程序中断方式相比的特点**

- 程序中断方式靠软件传送，DMA方式靠硬件。
- 程序中断方式在一条指令执行结束时响应，DMA方式可在周期内任意存取周期结束时响应。
- 程序中断方式有处理异常事件的能力，DMA方式没有，主要用于大批数据的传送。
- DMA方式无需保护现场。
- DMA方式优先级高。“
> DMA方式不需CPU干预传送操作，仅仅是开始和结尾借用CPU一点时间，其余不占用CPU任何资源，中断方式是程序切换,每次操作需要保护和恢复现场。”所以DMA优先级高于中断请求，这样加快处理效率。


### 5.6.4 DMA接口类型
**选择型DMA接口**
在物理上连接多个设备，在逻辑上只允许连接一个设备。在某一段时间内，DMA接口只能为一个设备服务（共用一组寄存器），适用于数据传输率很高的设备。
> **数据传输率**是指单位时间内传输的数据量，通常用比特每秒（bit/s）或字节每秒（B/s）来表示。


**多路型DMA接口**
在物理上连接多个设备，在逻辑上允许连接多个设备。每个设备设置一套寄存器，分别存放各自传送参数，适用于同时为多个数据传输率不十分高的设备服务。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679636614488-9e21cf82-b864-4bd7-ae8e-b7cb3629c51a.png#averageHue=%23f7f7f7&clientId=u90f2628f-505f-4&from=ui&height=278&id=ue53ff8d1&originHeight=699&originWidth=1258&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=45857&status=done&style=none&taskId=u431a101c-b69c-4c67-85c4-47685fcee13&title=&width=500" width="500" /> </div>


---

<br/>


<br/>


<br/>


<br/>




# 计算机运算方法

## 无符号与有符号数

### 无符号数

每一位都可以用来存放数值，浮点数没有无符号数的分类。

---

<br/>


<br/>

### 有符号数

**机器数与真值**

对于有符号数来说，机器无法识别正负符号，需要把正负符号进行机器表示，把符号“数字化”的真值成为机器数。

<br/>


**原码**

最高位是符号位，0表示正号，1表示负号。

原码表示简单，易于和真值进行转换，但是在进行加减运算时较为麻烦（例如，在操作数符号不同的加法运算时，要先判断两个数绝对值大小，然后用大的绝对值减去小的绝对值）

<br/>

**补码**

原理类似时钟，指针要转到一个数上面，可以顺时针也可以逆时针拨，补码定义如下：

$$
\left[ x \right] _补=\left\{ \begin{array}{l}
	0\ x\,\,\text{，}0\le x<2^n\\
	2^{n+1}+x\text{，}-2^n<=x<0\,\,\text{
}\\
\end{array} \right.
$$ 

其中 $n$ 代表数字位的位数。


<br/>


此时进行加法不必判断大小，进行减法时，即加上减数的补码，负数的补码和原码的快速转换——原码取反加一。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-16_133608.png" width="300" />
</center>



小数的补码定义为$\left[ x \right] _补=\left\{ \begin{array}{l}
	x\,\,\text{，}0\le x<1\\
	2+x\text{，}-1<=x<0\,\,\text{
}\\
\end{array} \right.$

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-16_133932.png" width="300" />
</center>




<br/>



**反码**

通常用于原码求补码或补码求原码的中间过渡。


<br/>


**移码**

由于补码表示很难直接判断真值的大小，所以引入了移码，移码的本质就是 补码+ $2^n$ ，**移码和补码的符号位相反，数字位相同**。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-28_110440.png" width="400" />
</center>




---

<br/>


<br/>


<br/>



## 定点表示 与 浮点表示

### 定点表示

小数点位置按照约定的位置给出，有以下两种格式：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-28_203958.png" width="500" />
</center>


---

<br/>


<br/>



### 浮点表示

通常浮点数被表示成 

$$
N=S\times r^j
$$

其中 $S$ 为尾数（可正可负）， $j$ 为阶数（可正可负）， $r$ 为基数，在计算机中基数可为 2, 4, 8 或 16。

**浮点数的表现形式**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-28_204339.png" width="400" />
</center>


阶符和阶码的位数 m 反映浮点数的表示范围以及小数点的实际位置，尾数的位数 n 表示浮点数的精度。

<br/>

**浮点数的表示范围**

以非格式化数为例，当阶数的数值为取 m 位，尾数的数值位取 n 位，其表示范围如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-28_204805.png" width="500" />
</center>

当浮点数**阶码大于最大阶码时上溢，机器停止运算，进行中断溢出处理**，当阶码小于最小阶码时下溢，通常将尾数各位置零，按机器零处理，不会停止运行。


<br/>

**浮点数格式化**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-28_205206.png" width="400" />
</center>

$r$ 越大，浮点数可表示的范围越大，能表示的数的个数越多；但是浮点数的精度越低。

<br/>


**机器零**

当尾数为 0 时，不论阶数为何值，通通按照机器零处理；

当阶码**小于或等于**所能表示的最小数时，不论尾数为何值，也按照机器零处理。

---

<br/>


<br/>



### IEEE 754 标准

现代计算机中，浮点数一般采用 IEEE 指定的国际标准，格式如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-28_210007.png" width="400" />
</center>


<br/>

<br/>


**32位浮点数和64位浮点数**

**其中尾数的最高有效位被隐藏**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-25_143135.jpg" width="700" />
</center>



<br/>

<br/>



阶码使用移码表示，但是<span style="background:#fff88f">**偏移量并不是常用的 2 的整数次幂，而是 127 和 1023**</span>。原因如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-25_143528.jpg" width="700" />
</center>



<br/>

<br/>




**特殊浮点数**
- 一般情况下，正零和负零是等价的
- 非规格化数可以处理阶码下溢，使得程序出现比最小规格化数还要小的数时，还能继续进行下去

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-25_144250.jpg" width="700" />
</center>


---

<br/>


<br/>


<br/>





##  定点运算

### 移位运算

当计算机没有乘除法运算电路时，可以采用移位和加法相结合实现乘除运算。

**算术移位**

仅仅对数值位进行操作，符号位不参与运算。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-17_141126.jpg" width="700" />
</center>




> **补码的另一种算术移位方法——符号位也参与运算**
> - **<span style="background:#fff88f">左移：高位移除，低位补 0，当符号位发生变化时，发生溢出。</span>**
> - 右移：低位移除，高位添补符号位。
> 
> 该方法优点：
> - 左移时，有检测发生溢出的方法
> - 符号位和数值位一起移位，方便 ALU 处理


<br/>


**逻辑移位**

**算术移位是有符号数的移位**， **逻辑移位是<span style="background:#fff88f">无符号数</span>的移位**；两者移位的规则是不一样的——对于逻辑移位，左右移位都是补 0 。

> 原码、反码、补码、移码都是用于表示**有符号**数的。 



<br/>


**C 语言中的移位操作**

- `<<`：对应汇编语言中的逻辑左移
- `>>`：根据操作数是有符号数还是无符号数，执行算术右移或逻辑右移
	- 逻辑右移：低位移除，高位补 0
	- 算术右移：低位移除，高位添补符号位



<br/>


**循环移位**

对于**无符号数**，循环移位会将移除的一位重新填入另一端，形成循环。在很多处理器架构中，循环移位指令会影响状态寄存器中的**进位标志 CF** 位，根据 CF 为是否加入循环移位过程，循环移位可以分为四种：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-17_143129.jpg" width="700" />
</center>




---

<br/>


<br/>



### 加法运算

由于减法运算可以看作是一个被减数加上减数的负值，现代计算机都采用补码加法作减法运算。

**补码加法基本公式**

- 整数： $\left[ A+B \right] _补\left( mod\ 2^{n+1} \right) =\left[ A \right] _补+\left[ B \right] _补,\ 其中n为数值位的位数$
- 小数： $\left[ A+B \right] _补\left( mod\,\,2 \right) =\left[ A \right] _补+\left[ B \right] _补$

原理的证明——以整数为例，由于高位会被丢弃，即 $mod\ 2^{n+1}$ ，每个操作数都可以看作是 $x+2^{n+1}$ ，此时用各自补码相加，然后丢弃进位即可。


<br/>


**溢出的判断**

- 如果两个操作数符号不同，则必然不会溢出；如果符号位相同，结果的符号为和操作数符号位不同的话，就必然溢出

- **一位符号位**：<span style="background:#fff88f">**符号位产生的进位 和 最高有效位产生的进位 进行异或运算**</span>，结果为 1 则溢出。 ^f9233d

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-17_145140.jpg" width="400" />
</center>


- **两位符号位**：即符号位有两位的变形补码。2个符号位不同时就溢出；无论是否溢出，最高移位符号为才是代表真正符号位。

> 当采用双符号位方案时，由于一个正确的数，其两个符号位总是相同的，所以寄存器和主存中的操作数只需保存一位符号数即可，在相加时，将保存的一位符号位同时送到加法器的两位符号位输入端。




---

<br/>


<br/>


### 乘法运算

**笔算乘法**

以下是笔算乘法的一个例子

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-31_092610.png" width="400" />
</center>



笔算乘法可以归纳出以下结论：

- 当乘数为$n$位时，需要进行**$n$次加法运算和$n$次移位**
- 每次做加法时，被乘数与部分积的高位相加，低位被移动到乘数空出来的高位位置


<br/>

**原码一位乘法**

乘积的符号可以通过符号位异或运算获得；数值位进行相乘的过程和改进后的笔算乘法过程一样，故原码一位乘法规则如下：
- 乘积符号位由两数的符号位异或运算结果决定
- 乘积数值部分有两数绝对值部分（即不要符号位）相乘得到，通式如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-31_093114.png" width="600" />
</center>


原码一位乘法需要注意：
- **存放部分积的寄存器有 $n+1$ 位**，存放乘法过程中绝对值超过 $n$ 位的值
- 乘积的数值部分是两数绝对值相乘的结果，故移位运算为逻辑右移

原码一位乘法硬件配置：
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-31_093646.png" width="500" />
</center>




- A、X、Q 均为 n+1位的寄存器，X 存放被乘数原码，Q 存放乘数原码，A 存放部分积
- S 存放乘积符号，Gm 为乘法标记
- 计数器 C 存放乘数位数（如果乘数原码除了符号位之外有 $n$ 位，就设为 $n$ ）

控制流程如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-31_094127.png" width="400" />
</center>



<br/>



**原码两位乘法**

为了提高运算速度，采用原码两位乘法，原码两位乘法**用两位乘数位来决定新的部分积**，如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-31_094420.png" width="700" />
</center>

其中
- 2 倍的被乘数，相当于被乘数左移 1 位
- 3 倍被乘数相当于 4 倍被乘数（左移两位）减去一个被乘数；可以加 4 倍的被乘数的操作，交给下一个乘数的两位去完成，需要一个存储器 $C_j$ 进行标记；当前只需要减去一个被乘数

由于需要进行 $-x^*$ 的操作，一般用 $+[x^*]_{补}$ 完成，所以两个操作数是绝对值的补码，移位运算是**算术移位**

在乘法过程中，需要 2 倍的被乘数，为了避免高位丢失，部分积需要 3 个符号位（也就是需要额外 2 位防止溢出），其中最高位才是真正的符号位。

为了统一操作（ 因为存在 标志 $C_j$ ，即使是乘数又偶数位，也需要高位补充两个 0，以便于处理前两位产生的标识 ），需要在乘数**高位增添“0”**，乘数位数为奇数时增添一个 0，为偶数时增添两个 0 ：
- 乘数数位 $n$ 为偶数时，需要做 $n/2$ 次移位， $n/2+1$ 次加法（将 C 设置为 $n/2$ ，当 C 为 0 时只做加法不移位）
- 乘数数位 $n$ 为奇数时，需要做 $n/2+1$ 次移位， $n/2+1$ 次加法（将 C 设置为 $n/2$ ，每一步都要加法和移位）


<br/>


**补码一位乘法**

进行补码乘法时，需要对乘数 $y$ 的符号进行讨论：

1）**被乘数 $x$ 符号任意，乘数 $y$ 符号为正**

$\left[ x \right] _补=2^{n+1}+x$

$\left[ y \right] _补=y$

$\left[ x \right] _补*\left[ y \right] _补=\left[ x \right] _补*y=\left( 2^{n+1}+x \right) *y=2^{n+1}*y+x*y=\left( 2^{n+1}+x*y \right) \ mod\ 2^{n+1}=\left[ x*y \right] _补$

即乘数为正数时，无论被乘数符号如何都可以使用原码乘法运算规则

2）**被乘数$x$符号任意，乘数$y$符号为负**

$\left[ x \right] _补=x_0x_1...x_n$

$\left[ y \right] _补=1y_1...y_n=y+2^{n+1}$

$y=\left[ y \right] _补-2^{n+1}=1y_1...y_n-2^{n+1}=0y_1...y_n-2^n$

$x*y=x*\left( 0y_1...y_n \right) -x*2^n$

$\left[ x*y \right] _补=\left[ x*\left( 0y_1...y_n \right) \right] _补+\left[ -x*2^n \right] _补$

可以看出，可以乘数为负数的乘法看成是 乘数为正数（乘数去掉符号位）的乘法，对于整数而言，最后得到的结果加上 $[-x]_补$ 左移 $n$ 位的结果 进行校正，故称为**校正法**。



<br/>

**Booth 算法**

该算法由校正法得出，也称为比较法。之前的校正法，对于定点数的补码乘法可以用一个统一的公式表示

$$
\left[ x*y \right] _补=\left[ x \right] _补\left( 0\ y_1\ y_2\ ...\ y_n \right) -\left[ x \right] _补*y_0
$$

可将以上算式改写

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-31_110237.png" width="600" />
</center>



其中$y_{n+1}=0$
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-31_110423.png" width="600" />
</center>



补码比较法的硬件配置：
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-31_110725.png" width="300" />
</center>



补码比较法的控制流程：
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-31_110845.png" width="500" />
</center>



<br/>



**补码两位乘法**

补码两位乘法是将判断$y_{n-1}y_n$和$y_ny_{n-1}$，也就是将下次和本次的部分积加减情况合并，需要注意的是下一个的加减情况要乘以2
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-31_111638.png" width="700" />
</center>



---


<br/>


<br/>



### 除法运算

 **笔算除法**
 
将笔算除法直接用计算机实现的问题有以下：
- 机器不能直接判断上商 0 还是 1 ，需要通过余数减去除数数的大小是正是负来判断
- 笔算除法每次总是余数不动，低位补0，除数右移一位。这种方式需要，两倍除数字长的加法器，**可以用左移余数的方法来代替**
- 机器难以将每位商直接写到寄存器的某个位置，**可将商先写入寄存器低位，然后左移一位**

<br/>


**原码除法**

符号位单独处理，商符号由两个操作数符号异或得出。商值由两操作数绝对值相除得到。

对于小数的定点除法，必须满足 $0<|被除数|<=|除数|$ 。实际计算中当被除数为 0，结果直接返回 0，当除数为 0，中断计算并报错。

1. **恢复余数法**

先用余数减去除数（加上除数的负数）得到新的余数，根据结果为正还是为负进行处理：
- 余数为负时：上商 0，并将余数加上除数进行恢复，然后余数左移
- 余数为正时：上商 1，然后余数左移

$n$ 位数位的原码进行除法时，进行 $n+1$ 次上商， $n$ 次移位（**用计数器 $C=n$ 判断运算是否结束， $C=0$ 时还要进行最后一次上商**）。第一次上商的结果在符号位上面（最后会被覆盖），可以根据第一次上商结果判断是否溢出（因为在小数点除法中，要求被除数小于除数）。

2. **加减交替法**

加减交替法也称为不恢复余数法，根据恢复余数法改进而来
对于余数$R_i$

- $R_i>0$ ，上商 1，做 $2R_i-y^*$ 运算
- $R_i<0$ ，上商 0，做 $2R_i+y^*$ 运算

运算流程如下
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-04_100224.png" width="600" />
</center>




<br/>


**补码除法**

一般采用加减交替法，在此只讨论这种方法

由于补码除法是**符号位和数值位一起参与运算**的，所以相较于原码除法需要额外解决几个问题：（1）如何确定商值（2）如何形成商符（3）如何获得新的余数

**1）比较余数和除数大小**

由于补码除法的操作数为补码，补码符号位是任意的，不能单纯用补码的差来判断大小，应该用绝对值大小进行比较，分以下两种情况：

   - 被除数和除数同号：余数与除数同号，表示够减
   - 被除数和除数异号：余数与除数同号，表示不够减

**2）商值确定**

由余数和除数大小、被除数和除数是否同号共同决定：

   - 被除数和除数同号：够减时，上商1（即此时商的结果为正数，可以根据原码的除法那样，够减就上商1）
   - 被除数和除数异号：不够减时，上商1

可以根据以上两种结论总结得到以下结果：
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-04_101922.png" width="600" />
</center>


**3）新余数确定**

和原码加减交替法类似
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-04_102142.png" width="600" />
</center>



> 如果对商的精度没有特殊要求，可采用末尾恒置一的方法，也就是最后一次上商恒上商 1
> - 因为在商为负数时，商是补码形式，若末尾为1，取反+1中的+1只会使末尾的0（原本是1）变成1，而不会影响到前面的位，即不会影响除了末尾以外其他位的数值，保证了精度在末尾的前一位。
> - 对于小数，最大误差仅为$2^{-n}$


补码除法控制流程如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-04_102455.png" width="500" />
</center>



---


<br/>


<br/>


<br/>





## 浮点四则运算

### 浮点加减法

**对阶**

使得两操作数的小数点对齐，遵循的原则是——**小阶向大阶对齐**，即**阶小的数尾数右移，阶数增加**

尾数右移时，可能会使得低位有效数字丢失，影响精度——但是如果采取大阶向小阶对齐，尾数左移，可能会发生更严重的尾数高位丢失，运算出错

<br/>

**尾数求和**

用补码进行相应的加法运算

<br/>


**规格化**

规格化——使得尾数的最高位必须是一个有效值。当基数不同时，规格化的结果也不同：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-25_164155.jpg" width="600" />
</center>


<br/>


**舍入**

在进行对阶和右规的过程中，可能会将尾数低位丢失，影响精度，可用舍入法提高尾数精度

- 0舍1入法：在原码中，当被移去的最高位为0时，就舍去；最高位为1时，在尾数的**末尾加一**；在补码中情况可能不一样，但是遵循的原则不变——舍去使得绝对值变小，进位使得绝对值变大
- 恒置1法：无论是原码和补码都是在**末尾置1（不是加一）**，对于补码，该方法可以将误差控制在最后一位

<br/>


**溢出判断**

浮点数溢出和定点数溢出定义不一样——浮点数溢出，是指阶码的溢出

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-05_100033.png" width="600" />
</center>




- 上溢：是指阶码的上溢，超过了最大的整数或小于最小的负数，此时机器停止运算，做溢出中断处理
- 下溢：阶码的下溢，浮点数趋于零，不做溢出处理，当成机器零

---

<br/>


<br/>


### 浮点数乘除运算

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-05_100833.png" width="500" />
</center>



尾数乘法运算

- 检查两个尾数中是否有为0的数，有则乘积为0不必在进行运算
- 左规时，如果阶下溢，则作机器零处理，右规时，如果阶上溢，则进行溢出中断处理

尾数相乘会得到双倍字长的结果，若只取一倍字长，需要将低位丢弃，采取的策略有以下：

- 截断法：处理简单，影响精度
- 舍入处理：对于原码和正数补码，0舍1 入。对于负数补码，总的原则是使得丢失的精度越小越好（可以将其看作是无符号数来理解），采取以下处理规则：
   - 丢失的各位全为0，不舍入——无影响
   - 丢失最高位为0，以下各位不全为0，或者最高位为1，之后各位全为0，则舍弃被丢失的各位
   - 丢失最高位为1，以下各位不全为0，尾数末尾加 1 —— 丢失精度超过当前最低位的一半

----


<br/>


<br/>


<br/>



## 算术逻辑单元

### ALU 电路

以下为 ALU 框图，A 和 B 为两个操作数，K 指定运算类型，F 为输出

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-05_104822.png" width="250" />
</center>



74LS181为四位 ALU，其引脚图和功能表参考教材

### 快速进位链

**加法器**

- 一位全加器： $S_i=X_i\oplus Y_i\oplus C_i$ ， $C_{i+1}=X_iY_i+\left( X_i\oplus Y_i \right) C_i$

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-22_140050.jpg" width="200" />
</center>


- 并行进位加法器

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-22_141034.jpg" width="700" />
</center>

假设与或非门即延迟时间为 $3t_y$ ，小组内只需要 $5t_y$ 就能产生全部进位：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-22_143555.jpg" width="700" />
</center>


<br/>


<br/>


**串行进位链**

全加器进位 $Ci$ 由两部分组成：
- 本地进位 $d_i=A_iB_i$ 
- 传递进位 $\left( A_i+B_i \right) C_{i-1}$ 

其中 $t_i= A_i+B_i$ 为传递条件，则有 $Ci=d_i+t_iC_{i-1}$

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-05_112129.png" width="250" />
</center>


<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-22_140314.jpg" width="600" />
逻辑电路图
</center>


<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-22_140632.jpg" width="600" />
</center>



<br/>



**并行进位链**

并行进位链是指并行加法器中进位信号是同时产生的，也称为先行进位、跳跃进位。有两种实现方式：

 **单重分组跳跃进位**：将 n 个全加器分为若干小组，组内进位并行产生，组间采用串行进位。


<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-22_151346.jpg" width="700" />
</center>



<br/>




**双重分组跳跃进位**：将全加器分为若干大组，大组中有分为若干小组。小组内部以及小组之间并行产生进位，大组之间串行传递进位：

对于一个大组中的每个小组，小组之间可以采用类似的并行进位策略，进位电路如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-05_113811.png" width="450" />
</center>


<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-07-22_152220.jpg" width="700" />
</center>


其中 D 和 T 的产生，由于小组内部的同步进位电路得出：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-05_114415.png" width="600" />
</center>

---

<br/>


<br/>


<br/>


<br/>




## 机器指令

### 指令格式

指令是由 操作码 和 地址码 两部分组成

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-11_103324.png" width="350" />
</center>


**操作码**

指明指令完成的操作，操作码长度：

- **长度固定**：便于硬件设计，指令译码时间短，广泛用于字长较长的、中大型就三级和超级小型计算机 以及 RISC
- **长度可变**：有效压缩了操作码的平均长度，在**字长较短的微型计算机中**广泛采用，增加了指令译码和分析的难度，控制器设计复杂，通常采用拓展操作码技术

<br/>


**拓展操作码技术**

操作码的长度随着地址数的减少而增加，任何短操作码不能是长操作码的前缀，可以在短操作码中留出一种，作为长操作码的前缀（例如，下图中选“1111”）

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-11_103823.png" width="500" />
</center>


<br/>


**地址码**

用来指出指令的的源操作数的地址，可以是主存地址、寄存器地址或者IO设备的地址。

- 四地址指令

	四个地址分别是：第一个操作数地址、第二个操作数地址、结果存放的地址、下一条指令的地址。一共需要4次访存（取指令、取两个操作数、存放结果）。程序中的指令大多是按照顺序执行的，PC 能存放当前欲执行的指令的地址，同时可以计数，可以自动生成下一条指令的地址，因此指令的地址部分可以省去下一条指令的地址。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-13_190254.png" width="250" />
</center>




- 三地址指令：

	三个地址分别代表第一个操作数地址、第二个操作数地址、结果存放的地址，一共需要4次访存（取指令、取两个操作数、存放结果）。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-13_190405.png" width="250" />
</center>




- 二地址指令

	存放操作数的内存可以存放结果，可以减少一个地址得到二地址指令，如果结果是存放在寄存器 ACC 中，则只需要3次访存（取指令、取两个操作数）。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-13_190505.png" width="260" />
</center>




- 一地址指令

	ACC 既可以存发结果，也可以存发一个操作数（当前操作数可以上一次运算的结果），一次只需要一个地址（操作数地址），一共需要2次访存（取指令、取一个操作数）。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-13_190534.png" width="260" />
</center>




- 零地址指令

	指令中没有地址码，如空操作（NOP）、停机（HLT）没有操作数，而子程序返回（RET）、中断返回（IRET）的操作数地址隐含在堆栈指针 SP 中。


用硬件资源（PC、ACC）可以代替指令字中某些地址字段后：

- 扩大指令寻址范围
- 缩短指令字长
- 减少访存次数

---

<br/>


<br/>


### 指令字长

指令的字长取决于操作码长度、地址码个数和地址码长度。

- 长度固定：早期计算机指令字长、机器字长和存储字长相等，指令字长固定，控制方式比较简单。
- 长度按字节倍数变化：现在计算机的指令系统可以采用不同位数的指令，控制电路比较复杂，多字长指令需要多次访存才能取出完整指令，为了提高指令运行速度和节省存储空间，尽可能把常用的指令（如，数据传送指令、算逻辑运算指令）设计成单字长或短字长格式指令。

---

<br/>


<br/>


<br/>


## 操作数、操作类型

### 操作数类型

机器中常见的操作数类型有以下：

- 地址：地址实际上也是一种数据，在许多情况下需要计算操作数的地址，可以看作是一个无符号整数
- 数字：常见的数字有定点数、浮点数和十进制数
- 字符：用ASCII码表示
- 逻辑数据：此时二进制数字串不是被看作是算术数字，而是被看作是逻辑数

---

<br/>


<br/>


### 数据存放方式

**单个数据在存储器存储的方式**

- 大端方式：数据高位放在低地址，字地址为高字节地址
- 小端方式：数据低位放在低地址，字地址为第字节地址

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-11_190604.png" width="550" />
</center>

<br/>


**字节编址方式**

以下为存储字长为8字节的机器为例子

- 从任意位置开始存储

	优点不浪费存储空间，但是除了字的第一个字节以外，其他位置的访存可能需要两个存储周期的时间，读写控制比较复杂

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-11_191323.png" width="600" />
</center>




- 从字的开始位置存储

	浪费了空间，但是访问任何数据只需要一个存储周期，读写控制简单

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-11_191526.png" width="600" />
</center>




- **边界对准方式**

	数据的存储的起始位置，是数据长度的整数倍，是之前两种方案的折中，在一个存储周期可以完成数据访问，内存浪费也不算太严重

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-11_191816.png" width="600" />
</center>

---

<br/>


<br/>


### 操作类型

不同的机器操作类型不同，但是几乎所有机器都有以下几种通用操作：

**数据传送**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-11_192332.png" width="450" />
</center>

<br/>


**算术逻辑操作**

- 算术操作：加、减、乘、除、增一、减一、取负数
- 逻辑操作：与、或、非、异或


<br/>


**移位**

分为算术移位、逻辑移位、循环移位

<br/>


**转移**

改变指令的执行顺序

- 无条件转移

	不受条件约束，直接把程序转移到下一条需要执行的指令的地址，例如 `JMP X`。

- 条件转移

	根据当前指令执行结果来决定是否需要转移，一般机器能够提供一些条件码，例如，零标志位 `Z`、负标识位 `N`、溢出标志位 `V`、进位标志位 `C`、奇偶标志位 `P`，为偶数时 `P=1`，其他标志位当满足对应条件时均为 1 。
	
	`SKP DZ` 表当触发器 D 为零时，跳过一条指令。

- 调用与返回

	调用指令 `CALL` 与返回指令 `RETURN` 配合使用

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-11_193635.png" width="500" />
</center>




- 陷阱指令

	陷阱 Trap 是一种意外事故的中断，此时计算机发出陷阱指令，暂停当前程序的执行，转入故障处理程序进行故障处理。一般不提供给用户使用，作为隐指令（指令系统中不提供的指令），但是有些机器设置供给用户使用陷阱指令，用来完成系统调用。

<br/>


**输入输出**

对于 IO 单独编址的计算机，通常设置输入输出指令，完成数据在寄存器和外部 IO 设备之间的转移，IO 设备和内存一起编址的计算机，不需要输入输出指令，使用转移指令完成对应操作。


---

<br/>


<br/>


<br/>


## 寻址方式

### 指令寻址

指令寻址比较简单，分为：
- 顺序寻址：通过PC加一（加多少取决地址编码方式），自动形成下一条指令地址
- 跳跃寻址：通过转移类指令来实现

---

<br/>


<br/>


### 数据寻址

数据寻址类型较多，指令字段中需要一个字段来指明寻址的方式，指令的地址码不一定代表真实地址，称为形式地址，记作 A，操作数的真实地址称为有效地址，记作 EA

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-11_212724.png" width="350" />
</center>



<br/>


**立即寻址**

操作数本身就存储在指令地址码字段，用`#`代表立即寻址。

<br/>


**直接寻址**

`EA=A`。寻找操作数比较简单，不需要计算操作数的地址，指令执行过程访存一次。缺点是A的位数限制了操作数的寻址范围，必须修改A，才能修改操作数地址。

<br/>


**隐含寻址**

寻址标志位隐含表示操作数在某个寄存器中。
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-11_213231.png" width="400" />
</center>


<br/>

**间接寻址**

形式地址指向的存储单元中存储的是有效地址，即`EA=(A)`。扩大了寻址范围；便于编制程序，例如用间接寻址很容易实现子程序的返回，在主程序中多次调用自程序时，不需要修改子程序指令，而是修改`(A)`即可。
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-12_083042.png" width="400" />
</center>



间接寻址缺点是需要访存多次。
多次间接寻址，可用存储字的首位来标志间接寻址是否结束。

<br/>


**寄存器寻址**

地址码部分给出的是寄存器的编号，即 `EA=Ri`。无须访存，减少执行时间；寄存器数量有限，缩短了指令字长。在计算机中应用广泛。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-12_083545.png" width="400" />
</center>




<br/>


**寄存器间接寻址**

寄存器中保存的是有效地址，即`EA=(Ri)`。需要访存一次。

<br/>


**基址寻址**

设有基址寄存器 `BR`，`EA=A+(BR)`。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-12_084040.png" width="400" />
</center>



基址寄存器有隐式和显式两种：

- 隐式：专门设有基址寄存器`BR`，用户不必明显指出该基址寄存器，只需有指令的寻址特征反映。
- 显示：基址在通用存储器中，由用户指明哪寄存器用作基址寄存器。

基址寻址可以扩大操作数寻址范围；在多道程序中很有用（操作系统的地址空间分段）。

<br/>


**变址寻址**

和基址寻址类似，`EA=A+(IX)`，但是不同的是，基址寻址中，基址不变，形式地址改变，而在变址寻址中，形式地址不变，基址改变。
变址寻址主要用于处理数组问题，在数组处理过程中，将形式地址`A`设置为数组首地址，通过在变址存储器中存放不同偏移量来访问数组元素，使用编制循环程序。
变址寻址还可以与其他寻址方式结合使用，如`EA=A+(IX)+(BR)`。

<br/>


**相对寻址**

有效地址由 PC 的值和形式地址相加得出，`EA=A+(PC)`。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-12_085222.png" width="500" />
</center>



特点在于转移地址不固定，无论程序在主存哪个区域，都可以正确运行，对于编写浮动程序有利；广泛用于转移指令。需要注意形式地址的设置问题，执行当前指令时，PC 的值已经加一。

<br/>

**堆栈寻址**

要求计算机中设有堆栈。堆栈中数据先进后出，栈顶为低地址，栈底为高地址，用堆栈指针 `SP` Stack Point 指出栈顶地址。

- 硬堆栈：用寄存器组来实现
- 软堆栈：用主存的一部分来实现



进栈则 `(SP)+1——>SP`，出栈则 `(SP)-1——>SP`。进出栈不一定是加一减一，取决于主存编址方式。

---


<br/>


<br/>


<br/>


## 指令格式举例

### 考虑的因素

- 与旧指令的兼容性
- 操作类型：指令数、操作难易程度
- 数据类型：确定哪些数据可以参与操作
- 指令格式
- 寻址方式
- 寄存器数量

---

<br/>


<br/>


### 7.4.2 指令格式举例

**IBM 360**

`R`表示存储器，`X`表示由变址寄存器指出的内存地址，`S`表示内存，`I`表示立即数。
结果存储在左边的符号表示的位置，如 `RR` 结果存储在寄存器，`SI` 结果存储在内存中。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-12_091000.png" width="600" />
</center>

<br/>

**Intel 8086**

指令字长不定长，为1-6个字节。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-12_091927.png" width="400" />
</center>


地址格式如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-12_092027.png" width="450" />
</center>

---

<br/>


<br/>


<br/>



## RISC 技术

### RISC 的发展

早期为了简化编译器的任务，缩小机器指令和高级语言之间的差距，产生了增加复杂指令的办法；后来发现，如果编译器过多依赖复杂指令，对减少机器代码、降低指令执行数和提高流水性能不利。

由于典型程序中 80% 的语句仅仅使用处理机中 20% 的指令，RISC 的产生就是用 20% 的简单指令组合不常用的80% 的指令功能。


---

<br/>


<br/>


### RISC的主要特征

- 选择使用频度比较高的简单指令，复杂指令由简单指令构成。
- **指令长度固定**，指令格式种类少，寻址方式少。
- **只有`LOAD`和`STORE`指令访存，其他指令都在寄存器完成**。
- CPU中设有多个通用寄存器。
- 采用流水线技术，大部分指令在一个时钟周期内完成。采用超标量和超流水线技术，指令平均执行时间小于一个时钟周期。
- **采用组合逻辑控制**，而不是微程序。

商品化的 RISC 机器通常不会是纯 RISC 机器，以上特点并不是所有 RISC 机器都具备。

---


<br/>


<br/>

### CISC主要特征

- 指令系统庞大复杂，各种指令使用频度差异大。
- 指令长度不固定，指令格式多，寻址方式多。
- 访存指令不受限制。
- CPU中设置专用存储器。
- 大多数指令需要多一个时钟周期才能完成。
- **采用微程序控制器**。

---

<br/>


<br/>


### RISC与CISC的比较

- RISC更能充分利用VLSI（超大规模集成电路）面积。
- RISC 更能 提高计算机运算速度，指令数、指令格式、寻址方式少，通用 寄存器多，采用 组合逻辑 ，便于实现 指令流水。
- RISC 便于设计，可 降低成本，提高 可靠性。
- RISC 不易 实现 指令系统兼容。


---

<br/>


<br/>


<br/>


<br/>


# CPU 结构与功能

## CPU 结构

### CPU 功能

CPU 实质包含 **运算器** 和 **控制器** 两大部分，运算器在第6章已经提及，这里侧重于控制器的功能。

CPU的功能有：取指令、分析指令、执行指令、控制程序输入及结果输出、总线管理、处理异常。这些功能可以划分为五类：

- 指令控制
- 操作控制
- 时间控制
- 数据加工
- 处理中断

---

<br/>


<br/>


### CPU 结构框图

分析实现CPU五大类功能各自所需的结构：

- 指令控制：PC、IR
- 操作控制、时间控制：CU、时序电路
- 数据加工：ALU、寄存器
- 处理中断：中断系统

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-13_212815.png" width="400" />
</center>


---

<br/>


<br/>



### CPU 的寄存器

**用户可见寄存器**

- 通用寄存器：存放操作数，或者作为某种寻址的专用寄存器
- 数据寄存器：存放操作数，需要满足各种数据类型，可以使用两个寄存器存放双倍字长的值
- 地址寄存器：位数满足最大地址范围，用于特殊的寻址方式
- 条件码寄存器：存放条件码，作为分支运算的依据

<br/>


**控制和状态寄存器**

- 控制存储器：如PC、MAR、MDR、IR
- 状态寄存器：如PSW寄存器（存放程序状态字）

---

<br/>


<br/>


### 控制单元和中断系统

CU 形成操作命令序列，有两种形成方式：

- 组合逻辑设计方式：硬连线逻辑，速度快，RISC 的 CU 使用该方式
- 微程序设计：存储逻辑，设计简单，适用于CISC

中断系统和CU在后面章节再具体介绍。

---


<br/>


<br/>


<br/>


## 指令周期

### 基本概念

指令周期—— 取出一条指令并完成执行所需的全部时间，可大致分为两个阶段：

- **取指阶段**：从存储器取出指令，并分析指令。
- **执行阶段**：取操作数，进行运算，结果写入内存等。

不同指令的指令周期是不同的，如下图：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-13_214613.png" width="500" />
</center>


采用间接寻址或执行中断的指令还有 **间址周期** 和 **中断周期** ：

例如，当 CPU 采用中断方式和 IO 交换信息时，在每条指令执行阶段结束之前需要发出中断查询指令，当有中断请求时，就进入中断周期以响应中断。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-13_214815.png" width="550" />
</center>

---

<br/>


<br/>


### 指令周期的数据流

**取值周期**

根据 PC 中的地址，从内存取出指令送到 IR，最后要**将 PC 增加一**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_144519.png" width="500" />
</center>

<br/>


**间址周期**

将 MDR 中形式地址部分送到 MAR 进行处理。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_144837.png" width="500" />
</center>


<br/>

**执行周期**

不同指令执行周期数据流不同，不用统一数据流图表示。

<br/>


**中断周期**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_145209.png" width="550" />
</center>



---

<br/>


<br/>


<br/>



## 指令流水

为了提高计算机速度，一方面可以提期间的性能；另一方面可以改进系统的结构，开发系统的并行性。并行包含两重含义：

- 并发：两个或多个事件在同一时间段内发生。
- 同时：两个或多个事件同时发生，在时间上重叠。

并行的等级：

- 程序级、进程级：统称为过程级，为粗粒度的并行，一般用软件实现。
- 指令之间级、指令内部级：统称指令级，为细粒度的并行，一般用硬件实现。

指令的流水作业就是一种**指令级的并行**。

### 指令流水原理

先把指令周期分为取指和执行阶段，执行的串行执行流程如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_150646.png" width="500" />
</center>

可以看出在任一时刻总是有取值部件或指令执行部件空闲，为了提高效率，可以让两条指令重叠，即指令的**二级流水**：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_150905.png" width="400" />
</center>

如果取值阶段和执行阶段时间相同，取值和执行阶段可以完美重叠，那么速度可以提升一倍，实际上很难达到提升一倍的效果，原因有：

- 取指时间$<$执行时间
- 条件转移指令：必须等待上条指令执行结束才能知道下条指令的地址。通常为了减少时间损失，采用猜测法：即使进入条件转移指令，依然顺序取下条指令，如果没有转移则没有时间损失，有转移则丢弃取到的指令，获取新的指令。

为了进一步提高处理速度，可以将指令的处理过程划分为更细的六个阶段：

- 取指 FI ：取出指令放入缓冲区。
- 指令译码 DI ：确定操作性质和操作数地址的形成方式。
- 计算操作数地址 CO
- 取操作数 FO
- 执行指令 EI
- 写操作数 WO

指令可以形成 **六级流水** ：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_151909.png" width="560" />
</center>


---

<br/>


<br/>


### 影响流水线性能因素

**结构相关**

不同指令争夺同一功能部件产生的资源冲突。例如，FI、FO、WO 都需要访存，可能会发生发出冲突，如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_152223.png" width="550" />
</center>



解决方法：

- 停顿：将指令的操作暂停一段时间（例如一个周期）后再执行。
- FI 和 FO 的冲突，可以设置两个独立指令 Cache 和数据 Cache，即指令存储和数据存储分开，这种结构被称为**哈佛结构(Harvard architecture)**
- 指令预取技术：将指令预先取到一个队列里面，避免 FI 和 FO 的冲突，适用于访存周期短的场景。


<br/>

**数据相关**

各条指令因为重叠操作，可能改变了对操作数的执行结果，导致数据相关冲突：

- 写后读相关

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_153144.png" width="400" />
</center>

- 读后写相关

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_153217.png" width="400" />
</center>

- 写后写相关

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_153244.png" width="400" />
</center>

解决方法：

- 后推法：相关指令延迟到所需操作数被写回到寄存器再执行。
- 定向技术：又称为旁路技术，不必等到某条指令的执行结果送回到寄存器，再从寄存器中读出作为操作数，而是将执行结果直接送到其他指令所需的地方。

<br/>

**控制相关**

由转移指令引起，统计表示转移指令约占总指令1//4，会使流水线丧失很多性能。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_153719.png" width="550" />
</center>



解决方法：

- 尽早判别转移是否发生，尽早生产转移目标地址。
- 如果无法提前判断，预取成功和失败两个控制流方向上的目标指令。
- 加快和提前形成条件码。

---

<br/>


<br/>


### 流水线性能

**吞吐率**

单位时间内完成指令的数量

- 最大吞吐率：流水线在连续流动之后达到稳定状态，对于$m$段流水线，每段时间为$\varDelta t$，最大吞吐率$T_{pmax}=\frac{1}{\varDelta t}$。
- 实际吞吐率：考虑流水线的建立时间和排空时间，为$T_p=\frac{n}{m\varDelta t+\left( n-1 \right) \varDelta t}$，当处理的指令远大于流水线段数时，实际吞吐率趋近于最大吞吐率。

<br/>


**加速比**

$m$ 段流水线和等功能非流水线的速度之比。

$$S_p=\frac{nm\varDelta t}{m\varDelta t+\left( n-1 \right) \varDelta t}=\frac{m}{1+\frac{m-1}{n}}$$

当$n>>m$时，加速比趋近于$m$。

<br/>


**效率**

流水线中各功能段的利用率。

$$E=\frac{nm\varDelta t}{m\varDelta t+\left( n-1 \right) \varDelta t}=\frac{n}{m+n-1}=\frac{S_p}{m}=T_p\varDelta t$$

当$n>>m$时，效率趋近于1。

---

<br/>


<br/>


### 流水线的多发技术

**超标量技术**

超标量（superscalar）技术是指——每个时钟周期内可同时并发多条独立指令，要求配置多个功能部件和指令译码电路、多个寄存器端口和总线。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_155722.png" width="500" />
</center>

超标量计算机不能改变指令执行顺序，但是可以通过编译优化技术，并能并行的指令搭配起来。

<br/>


**超流水技术**

超流水技术（superpipeline）是将一些流水线寄存器插入流水线段中，将流水线再分段。在一个时钟周期内将一个功能部件使用多次。

同样不能改变指令执行顺序，通过编译进行优化。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_160106.png" width="500" />
</center>

<br/>

**超长指令字技术**

超长指令字技术（VLIW） 和 超标量技术都是 采用多条指令能在多个处理部件中并行处理的结构。超标量的指令来自标准的指令流，VLIW 是在编译时挖掘出指令之间的并行性后，把**能并行的指令合并为一条具有多个操作码字段的超长指令**。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_160717.png" width="450" />
</center>

---

<br/>


<br/>


### 流水线结构

**指令流水线结构**

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_161632.png" width="350" />
</center>



在流水线每个操作部件的后面，都要有一个**缓冲寄存器（锁存器）**，称为流水寄存器，这个缓冲寄存器用于保存本阶段的执行结果，以保证各个部件之间的速度是匹配。

<br/>


**运算流水线**

流水线技术还可以用于部件级别，例如浮点数的加法运算也可以进行流水线工作：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-14_162121.png" width="350" />
</center>

分段的原则是保证每段操作时间尽量一致。


---


<br/>


<br/>


<br/>


## 中断系统

### 概述

**引起中断的因素**

- 人为设置的中断：自愿中断，例如 转管指令
- 程序性事故：如运算溢出、出现非法运算操作等
- 硬件故障
- I/O 设备
- 外部事件：例如通过键盘来中断现行程序。

引起中断的因素称为中断源。中断源可以分为：
- 不可屏蔽中断，如电源掉电
- 可屏蔽中断

<br/>


**中断系统解决的问题**
- 中断源提出中断请求
- 中断系统确定响应中断的优先次序
- CPU如何响应中断
- 如何找到中断服务程序入口地址
- 保护现场和恢复现场
- 中断过程中出现了新的中断请求如何处理


---

<br/>


<br/>


### 中断请求标记和判优逻辑

**中断请求标记**

**中断请求触发器 INTR** 为1表示有中断请求，多个触发器集成在 CPU 内部形成**中断请求标记寄存器**，如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-19_092910.png" width="500" />
</center>

中断请求触发器即可以集成在CPU内部的中断系统，也可以分散在各个中断源。

<br/>

**中断判优逻辑**

- **硬件排队**：
	- 一种为链式排队器，对应 **INTR 分散在各个中断源** 的情况，参考 [[#5.5.3 程序中断接口电路|IO 程序中断方式]]。
	- 另一种**排队器设在 CPU 内部**，结构如下：
	
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-19_093411.png" width="500" />
</center>

- **软件排队**：通过编写查询程序实现。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-19_093538.png" width="450" />
</center>

---


<br/>


<br/>



### 中断服务程序入口


**硬件向量法**

利用硬件产生向量地址，再由向量地址找到中断服务程序的入口地址。向量地址可以利用排队器的输出通过一个编码电路形成。

通常有两种方式，向量地址内存单元放置的是：
- 无条件转移指令
- 向量表，存储单元内容为入口地址。

硬件向量法寻找入口地址速度快，在现代计算机被普遍采用。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-19_120057.png" width="600" />
</center>



<br/>


**软件查询法**

不涉及硬件方法，查询时间较长。

---


<br/>


<br/>



### 中断响应

**响应中断的条件**

CPU 能够响应中断的条件是 允许中断触发器 `EINT` 为 1。


<br/>

**响应中断的时间**

CPU总是在**指令执行周期结束后**，响应中断。在一个指令的执行周期结束后，统一向中断源发送查询信号，如果有中断就进行响应。
某些计算机中有些指令的执行时间很长，可在指令执行周期过程中设置若干个查询端点。

<br/>


**中断隐指令**

中断隐指令是**机器指令系统中没有的指令**，在中断周期中**硬件自动完成**的一条指令。具体操作如下：

- 保护程序断点：将当前程序计数器 `PC` 的内容保存到存储器。可以存入在存储器的特定单元（0号地址）或者存入堆栈。
- 寻找中断服务程序入口地址：使用硬件向量法或者软件查询法。
- 关中断：单重中断开始响应中断时就关中断，避免受到其他中断源的影响。以下为硬件关中断的示意图：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-19_141831.png" width="400" />
</center>


---


<br/>


<br/>



### 保护现场和恢复现场

**保护现场**

- 程序断点（PC的内容）：由中断隐指令完成。
- 保护 CPU 内部各寄存器的内容：在中断服务程序中，由用户或系统用机器指令编程实现。

<br/>


**恢复现场**

将寄存器的内容恢复到中断处理前的状态，由中断服务程序完成。

---

<br/>


<br/>



### 中断屏蔽技术

中断屏蔽技术主要用于多重中断。

**实现多重中断的条件**

- 提前设置开中断指令
- 只有优先级更高的中断才能打断当前的中断服务

<br/>

**屏蔽技术**

排队器分散在接口上时，单个中断请求接口电路如下，只有屏蔽触发器为 `MASK` 为 0 时才能发出中断请求：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-03-21_213856.png" width="300" />
</center>

排队器集成在 CPU 内部时，加上屏蔽条件，组成具有屏蔽功能的排队器：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-19_143541.png" width="400" />
</center>

将所有屏蔽触发器组合在一起，构成一个屏蔽寄存器，屏蔽寄存器的内容称为屏蔽字。屏蔽字和中断源的优先级是一一对应的，如下图：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-20_203428.png" width="500" />
</center>


<br/>


**屏蔽技术改变优先级**

优先级分为 响应优先级 和 处理优先级：

- **响应优先级**：CPU 响应各中断源请求的优先次序，一般是硬件线路设置，不便于改动。
- **处理优先级**：CPU 实际对中断源的处理的优先次序。屏蔽技术可以**给中断源设置屏蔽字来改变中断源的处理优先级**。

假设现在有4个中断源，响应优先级为 $A\rightarrow B\rightarrow C\rightarrow D$ ，CPU 执行中断程序过程如下图：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-20_204544.png" width="500" />
</center>

对中断源的屏蔽字进行修改：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-20_204719.png" width="500" />
</center>

此时 CPU 执行过程如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-20_204905.png" width="600" />
</center>


可以看到，CPU 依然按照响应优先级进行响应，但是在开中断之后，会被处理优先级更高的中断源打断。**屏蔽字决定了中断处理程序可以被哪一些中断源打断**。

<br/>


**多重中断的断点保护**

中断系统对断点的保护是在中断周期有中断隐指令实现的，对用户透明。程序断点可以保存在以下位置：

- 堆栈：由于堆栈先进先出的特点，可以准确回到程序间断处。
- 特定存储单元：可以约定程序断点一律保持到 0 地址单元，为了避免之前存入的断点被覆盖，必须先将 0 地址的内容转存到其他地址单元中。


---


<br/>


<br/>


<br/>


<br/>




# 控制单元的功能

## 微操作命令分析

控制单元具有**发出各种微操作命令（控制信号）序列**的功能。

### 取值周期

取指令的过程可以归纳为以下操作：

- $PC\longrightarrow MAR$
- 向主存发出读命令$1\longrightarrow R$
- $M(MAR)\longrightarrow MDR$
- $MDR\longrightarrow IR$
- $(PC)+1\longrightarrow PC$

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-21_160005.png" width="350" />
</center>

---

<br/>


<br/>


### 间址周期

- $Ad(IR)\longrightarrow MAR$
- 向主存发出读命令$1\longrightarrow R$
- $M(MAR)\longrightarrow MDR$
- $MDR\longrightarrow Ad(IR)$

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-21_161216.png" width="350" />
</center>

---

<br/>


<br/>


### 执行周期

不同指令的执行周期的微操作是不同的，下面分情况进行讨论：

**非访存指令**

- 清除累加器指令`CLA`，$0\longrightarrow ACC$
- 累加器取反指令`COM`，$\overline{ACC}\longrightarrow ACC$
- 算术右移一位指令`SHR`，$L(ACC)\longrightarrow R(ACC),ACC_0\longrightarrow ACC_0$
- 循环左移移位指令`CSL`，$R(ACC)\longrightarrow L(ACC),ACC_0\longrightarrow ACC_n$
- 停机指令`STP`


<br/>

**访存指令**

这类指令在执行阶段需要访问存储器。

- 加法指令

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-21_161424.png" width="200" />
</center>

- 存数指令

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-21_161506.png" width="200" />
</center>

- 取数指令

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-21_161541.png" width="200" />
</center>


<br/>


**转移类指令**

- 无条件转移指令`JMP X`，$Ad(IR)\longrightarrow PC$。
- 条件转移指令，以`BAN X`为例，若上一条指令运行结果为负则转到`X`，否则继续执行，记作$A_0\cdot Ad\left( IR \right) +\overline{A_0}\cdot \left( PC \right) \longrightarrow PC$，其中$A_0$为上一条指令运行结果的最高位。

---

<br/>


<br/>


### 中断周期

中断周期要使用中断隐指令保存断点、寻找中断服务程序入口地址、硬件关中断。假设断 点保存在主存 0 号地址，采用硬件向量法寻找入口地址：

- $0\longrightarrow MAR$，若将断点存入堆栈，则$(SP)-1\longrightarrow SP,SP\longrightarrow MAR$
- $1\longrightarrow W$
- $PC\longrightarrow MDR$
- $MDR\longrightarrow M(MAR)$
- $向量地址\longrightarrow PC$
- 关中断 $0 \longrightarrow EINT$

---

<br/>


<br/>


<br/>


## 控制单元的功能

### 控制单元外特性

以下为控制单元的外特性框图：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-21_162714.png" width="500" />
</center>

**输入信号**

- 时钟信号：完成每个操作需要时间，时钟信号使得控制单元按一定的先后顺序、一定节奏发送各个控制信号。一个时钟脉冲发出一个操作命令，或者一组可以同时执行的操作命令。
- 指令寄存器：指令的操作码字段是控制单元的输入信号，和时钟信号配合产生不同控制信号。
- 标志：指令的执行有时依赖 CPU 当前所处的状态。
- 来自控制总线的控制信号：如，中端请求、DMA 请求。

<br/>

**输出信号**

- CPU 内部控制信号：用于 CPU 内部寄存器之间的传送 和 控制 ALU 实现不同功能。
- 送至系统总线（控制总线）的信号：主存和 I/O  设备的读写命令、中断响应等。

---

<br/>


<br/>


### 控制信号举例

**不采用 CPU 内部总线的方式**

按一定时序控制门电路的开关，如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-21_164057.png" width="600" />
</center>

<br/>

**采用 CPU 内部总线方式**

也是按一定时序打开对总线和部件之间的线路进行开关控制，如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-21_164325.png" width="250" />
</center>

---

<br/>


<br/>



### 多级时序系统

**机器周期**

机器周期是指令执行过程中的一个基准时间。确定机器周期需要指令执行的步骤和每一步骤所需时间，有以下策略：

- 以完成最复杂指令功能时间为基准：对于简单指令来说该基准执行会造成浪费。
- 以访问一次存储器的时间为基准。

<br/>

**时钟周期**

一个机器周期里可完成若干微操作，每个时钟周期（节拍）完成一个或几个需要同时执行的操作。时钟周期是计算机操作的最小时间单位。

<br/>

**多级时序系统**

每个指令周期内的机器周期数可以相等也可以不等，每个机器周期内的节拍数可以等也可以不等：

- 定长的机器周期
- 不定长的机器周期：适用于操作比较简单的指令，可跳过某些时钟周期，从而缩短指令周期。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-21_165537.png" width="450" />
</center>

一般而言 CPU 主频越高，机器的运行速度越快，但也和机器周期中含时钟周期数和指令周期含机器周期数有关：

$MIPS=\frac{CPU\text{主频}}{\text{平均每条指令所含时钟周期数量}\times 1,000,000}$


---

<br/>


<br/>


### 控制方式

**同步控制**

- 定长的机器周期

	采用最长的微操作序列和最繁的微操作作为标准，采用完全统一的，具有时间间隔和相同数目节拍的机器周期运行不同指令。对于较简单指令，造成时间上的浪费。
	
<br/>

- 不定长的机器周期

	每个机器周期内的节拍数可以不等，可解决微操作执行时间不一的问题。通常把大多数微操作安排在一个较短的机器周期内完成，对于复杂的微操作，采用延长机器周期或增加节拍的方法。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-21_183821.png" width="500" />
</center>


- 中央控制和局部控制相结合

	大部分指令安排在统一的、较短的机器周期内完成。少数操作复杂的指令中的某些操作（如乘除法和浮点运算）采用局部控制方式完成。


	局部节拍的每一个节拍宽度和中央控制节拍的宽度相同。**局部控制的节拍要和作为中央控制节拍的延续**，保证局部控制和中央控制的同步。
	
<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-21_184606.png" width="500" />
</center>



<br/>


**异步控制**

采用应答方式。可以使得 CPU 没有空闲状态，结构比同步控制复杂。

<br/>


**联合控制方式**

同步控制和异步控制相结合。大部分统一、小部分区别对待。

<br/>


**人工控制方式**

为了调机和软件开发的需要，在机器面板或内部设置一些开关或按键。

- `Reset`键：使计算机处于初始状态。
- 连续或单条执行转换开关
- 符合停机开关

---

<br/>


<br/>


<br/>


<br/>

# 控制单元设计

本章主要介绍控制单元的两种设计方法——组合逻辑设计和微程序设计。

## 组合逻辑设计

### 组合逻辑设计框图

指令的操作码是决定控制单元发出不同控制信号的关键。为了简化控制单元的逻辑，假设 `IR` 中的 $n$ 位操作码经过译码产生 $2^n$ 个输出信号，每一个输出信号对应一个**微操作**。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_192029.png" width="500" />
</center>

---

<br/>


<br/>


### 微操作节拍安排

安排微操作的节拍应该注意以下：

- 有些微操作的次序不容改变。
- 凡是能够在一个节拍内完成的微操作，尽量安排在同一个节拍并行完成。
- 有些微操作的执行时间不长，可以将他们安排在一个节拍内完成，允许这些微操作有先后顺序。

---

<br/>


<br/>


### 组合逻辑设计的步骤

**列出微操作命令的操作时间表**

写出每一个节拍内要进行的微操作。

<br/>


**写出微操作命令的最简逻辑表达式**

列出微操作命令的逻辑表达式，表明控制该微操作的的信号在哪些指令的哪些阶段哪些节拍会有效。要求能够利用现有的电路实现逻辑表达式。

<br/>


**画出微操作命令的逻辑图**

根据逻辑表达式画出逻辑图。实际上需要考虑门的扇入系数。

---


<br/>


<br/>


<br/>



## 微程序设计

### 微程序设计思想

为了克服组合逻辑控制单元线路庞杂的缺点，采用与存储程序类似的思想来解决微操作命令序列的形成。

微程序设计省去了组合逻辑设计过程中对逻辑表达式的化简，控制信号以二进制代码存储，可以通过修改微指令代码，改变操作内容，便于调试、修改，有利于计算仿真。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_193628.png" width="400" />
</center>

**一条机器指令对应一个微程序**，一个微程序包含多个**微指令**，微指令存储在`ROM`中，一个微指令一般对应多个能够并行执行的微操作命令。

---

<br/>


<br/>


### 微程序控制单元框图

**机器指令对应的微程序**

微程序设计方法设计控制单元的过程：根据机器指令所需的微操作命令的先后顺序，编写每一条机器指令对应的微程序。

可以**将一些机器指令共有的操作统一编成同一个微程序**，如取值周期微程序、间址周期微程序、中断周期微程序。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_193933.png" width="400" />
</center>

<br/>

**微程序控制单元基本框图**

微指令存储在控制存储器中，通过顺序逻辑部件产生下一条微指令的地址。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_195846.png" width="500" />
</center>

微指令的格式如下，包括操作控制部分和顺序控制部分。操作控制部分指令要进行的微操作，顺序控制指明下条微指令的地址。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_200510.png" width="340" />
</center>

---

<br/>


<br/>


### 微指令编码方式

**直接编码方式**

指令的操作控制部分的每一个“1”直接对应一个微操作。这种方式含义清晰，微指令从控存中读出就能发出控制命令，速度快。但是由于 $n$ 个位只能对应 $n$ 个操作命令，需要的控存的容量很大。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_201226.png" width="400" />
</center>

<br/>

**字段直接编码方式**

将不能同时执行的（互斥）微操作放在同一个字段中（一个字段的译码输出对应一个微操作），一个 $n$ 位字段通过译码电路译码产生 $2^n$ 种输出，对应不同的微操作。这种方式缩短了微指令长度，但是增加了译码电路，使得微程序执行速度稍微减慢。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_201313.png" width="500" />
</center>

<br/>

**字段间接编码方式**

一个字段的某些为命令还需要另一个字段中某些微命令来解释。进一步缩短微指令字长，但是削弱了微指令的并行控制能力，通常作为字段直接编码的一种辅助手段。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_201711.png" width="500" />
</center>


<br/>


**混合编码**

把直接编码和字段编码混合使用，综合考虑微指令字长、灵活性和执行速度等方面。

----


<br/>


<br/>


### 微指令序列地址的形成

**由于微指令的下地址指出**

顾名思义，这种方法又称为断定方式。

<br/>


**根据机器指令的操作码形成**

当机器指令放入`IR`之后，微指令的地址根据机器指令的操作码经过位地址形成部件给出。

<br/>

**增量计数法**

在很多情况下，后续微指令的地址是连续的，对于顺序地址可以采用增量计数法。$\left( CMAR \right) +1\longrightarrow CMAR$。

<br/>


**分支转移**

条件转移指令，需要根据标志来决定下一条微指令的地址。微指令格式如下：

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_202447.png" width="500" />
</center>

转移方式指明判别条件，转移地址指明转移成功后的去向。

<br/>

**测试网络**

将顺序控制的地址的部分字段设置为测试地址，进过测试网络之后和非测试地址组成形成新地址。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_202716.png" width="500" />
</center>

<br/>

**硬件产生微程序入口地址**

当电源加电后，第一条微指令的地址可由专门的硬件电路产生，也可以由外部直接向`CMAR`中输入微指令的地址。该地址其实是取值周期的微程序的入口地址。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_222208.png" width="550" />
</center>


---

<br/>


<br/>



### 微指令格式

**水平型微指令**

一次能够定义并**执行多个并行操作**的微命令。

<br/>


**垂直型微指令**

采用类似机器指令操作码的方式。设置微操作码字段，微操作码规定微指令功能，通常一条微指令控制1-2种微操作，并不强调并行控制能力。

<br/>

**两种微指令对比**

- 水平型微指令并行操作能力强、灵活性强。
- 水平型微指令执行一条机器指令所需微指令数目少，速度快。
- 水平型微指令用较短的微程序结果换取较长的微指令结果（每一条微指令执行的操作多），垂直型微指令恰恰相反。
- 垂直型微指令和机器指令相似，水平型微指令和机器指令差别大。

---

<br/>


<br/>


### 静态微程序设计与动态微程序设计

**静态微程序设计**

微程序无需改变，控制存储器采用ROM。

<br/>


**动态微程序设计**

通过改变微指令和微程序来改变机器指令，有利于仿真，采用EPROM。

---

<br/>


<br/>


### 毫微程序设计

机器指令用微程序解释，微程序又可以用毫微程序解释，也就是**微指令可以用毫微指令解释**。采用毫微程序设计的计算机优点是使用少量的控制存储器空间来达到高度并行。

毫微程序设计采用两级微程序的设计方法：

- 第一级为垂直型微指令：并行功能不强，但是有严格的顺序结构，由他确定后续微指令地址。如果只产生一些简单的控制信号，则可以通过译码直接形成微操作目录，不必调用二级。
- 第二级为水平型微指令：并行操作能力强，不包含后续微指令地址。

两级微程序分别存放在两级控制存储器中。水平型微指令和垂直型微指令并不是一一对应的关系，而是由水平型为指令（毫微指令）组成的毫微程序去执行垂直型微指令的操作。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_222323.png" width="600" />
</center>


---

<br/>


<br/>


### 串行和并行微程序控制

完成一条微指令也分为两个阶段：取微阶段和执行阶段。两个阶段的的操作是在不同的部件中完成的，可以并行执行，形成二级流水。

<center>
<img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-04-25_221854.png" width="700" />
</center>


---










