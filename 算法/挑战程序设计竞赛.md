<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1681454004324-88a6e9ab-c42b-47a6-8a36-4c7a64d58324.jpeg" width="500" /> </div>


# 初级篇
复杂度分析
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682774565665-96143e83-e872-4c09-9065-0fd055765f9f.jpeg" width="700" /> </div>


## 2.1 搜索

### 2.1.1 递归函数
一个递归函数的例子是斐波那契数列
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680177545315-93399e4b-4374-4619-8c14-9a7b75c54ed2.png" width="300" /> </div>


由于计算斐波那契数列的递归函数，会按照指数级别扩展开来，时间和空间复杂度很高。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680177637011-d0b1b300-a8b7-43a4-bac8-6076b676ff78.png" width="300" /> </div>


可以看出在递归调用的时候，有重复进行的计算，可以利用将计算结果存储起来来优化计算，这就是记忆化搜索或者动态规划的想法。

---

<br/>


<br/>


### 2.1.2 栈
函数的调用是通过栈来实现的，因此递归函数的递归过程可以改用栈上的操作实现。

---

<br/>


<br/>



### 2.1.3 队列
不做介绍。

---

<br/>


<br/>


### 2.1.4 深度优先搜索
DFS是从某个状态开始不断转移状态，直到找到解，如果无法进行下去，就退回上一步的状态，继续转到其他状态；可以发现这一过程和栈入栈、出栈过程很类似，DFS可以递归函数实现。


> **Lake Counting (POJ No.2386)**
> 有一个大小为$N\times M$的园子，雨后积起了水。八连通的积水被认为是连接在一起的。请求出园子里总共有多少水洼？（八连通指的是下图中相对$W$的$*$的部分）
> $***$
> $*W*$
> $***$
> 限制条件：$N,M<=100$
>
> 可以用 DFS 遍历 W 区域，同时进行覆盖，当遍历完成时，一个独立的 W 区域就被完全覆盖了，此时统计进行了多少次 DFS 遍历就相当于有多少个独立 W 区域。
> 
> ```cpp
> const int MAX_N = 100, MAX_M = 100;
> int N, M;
> char field[MAX_N + 1][MAX_M + 1];
> 
> void dfs(int x, int y) {
> 	field[x][y] = '.';	//标记位置已经被访问过
> 	//遍历移动的8个方向
> 	for (int dx = -1; dx <= 1; ++dx) {
> 		for (int dy = -1; dy <= 1; ++dy) {
> 			int nx = x + dx, ny = y + dy;
> 			if (nx >= 0 && nx < N && ny >= 0 && ny < M && field[nx][ny] == 'W')
> 				dfs(nx, ny);
> 		}
> 	}
> }
> void solve() {
> 	int ans = 0;
> 	for (int i = 0; i < N; ++i) {
> 		for (int j = 0; j < M; ++j) {
> 			//当发现有水洼，ans++，同时dfs遍历，将当前水洼标记为访问过
> 			if (field[i][j] == 'W') {
> 				dfs(i, j);
> 				++ans;
> 			}
> 		}
> 	}
> 	printf("%d\n", ans);
> }
> ```

---

<br/>


<br/>



### 2.1.5 宽度优先搜索

BFS从一个状态开始，先搜索距离初始状态近的状态，然后不断向外拓展；宽度优先搜索利用了队列，搜索试试首先将初始状态添加到队列中，然后不断从队列前端取出状态。
BFS按照距离开始状态由近及远的顺序进行搜索，因此很容易用来求最短路径、最少操作之类的问题，只要将已经访问过的状态用标记管理起来，就可以很好地做到由近及远的搜索。


**迷宫的最短路径**
给定一个大小为$N\times M$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四格的通道移动。请求出从起点到终点所需的最小步数。请注意，本题假定从起点一定可以移动到终点。
限制条件：$N,M<=100$

将已经访问过的状态标记起来，可以用一个数组记录从起点指定位置的最短距离，用INT_MAX进行初始化
```cpp
typedef pair<int, int> P;
const int MAX_N = 100, MAX_M = 100;
int N, M;
int sx, sy;
int gx, gy;
char maze[MAX_N + 1][MAX_M + 1];
int d[MAX_N + 1][MAX_M + 1];	//记录起点到当前距离的最短距离
int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };	//移动的四个方向

int bfs() {
	queue<P> que;
	for (int i = 0; i < N; ++i)
		for (int j = 0; j < M; ++j)
			d[i][j] = INT_MAX;
	
	que.push(P(sx, sy));
	d[sx][sy] = 0;
	while (!que.empty()) {
		P p = que.front();
		que.pop();
		if (p.first == gx && p.second == gy)
			break;
		for (int i = 0; i < 4; ++i) {
			int nx = p.first + dx[i], ny = p.second + dy[i];
			if (nx >= 0 && nx < N && ny >= 0 && ny < M && maze[nx][ny] != '#' && d[nx][ny] == INT_MAX) {
				que.push(P(nx, ny));
				d[nx][ny] = d[p.first][p.second] + 1;
			}
		}
	}
	return d[gx][gy];
}

void solve() {
	int ans = bfs();
	printf("%d\n", ans);
}
```

### 2.1.7 剪枝
DFS时，有时早已明确知道从当前状态无论如何转移都不会存在解，此时应该及时回溯而不是继续搜索下去，这一个方法称为剪枝。


## 2.2 贪心
贪心就是遵循某种规则，不断的贪心的选取当前最优策略的算法设计思想。
### 2.2.1 硬币问题

**硬币问题**
有1 元、5 元、10 元、50 元、100 元、500 元的硬币各$C_1\ C_5\ C_{10}\ C_{50}\ C_{100}\ C_{500}$枚。现在要用这些硬币来支付$A$元，最少需要多少枚硬币？假定本题至少存在一种支付方案：
限制条件：
• $0<=C_1\ C_5\ C_{10}\ C_{50}\ C_{100}\ C_{500}<=10^9$
• $0<=A<=10^9$

要求的是使用最少硬币，所以可以优先使用面额的硬币
```cpp
const int V[6] = { 1,5,10,50,100,500 };//标记每种硬币价值
int C[6];	//保存每种硬币数量	
int A;


void solve() {
	int ans = 0;
	for (int i = 5; i >= 0; --i) {
		int t = min(A / V[i], C[i]);//硬币是有限的
		A -= V[i] * t;
		ans += t;
	}
	printf("%d\n", ans);
}

```

### 2.2.2 区间问题

**区间调度问题**
有$n$项工作，每项工作分别在$s_i$时间开始，在$t_i$时间结束。对于每项工作，你都可以选择参与与否。如果选择了参与，那么自始至终都必须全程参与。此外，参与工作的时间段不能重叠（即使是开始的瞬间和结束的瞬间的重叠也是不允许的）
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680699442229-7207e6b6-99e2-4976-b15b-1ac3803039dd.png#averageHue=%23f7f7f7&clientId=ud9503b38-e915-4&from=ui&height=147&id=ub9a315a1&originHeight=296&originWidth=1411&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=62532&status=done&style=none&taskId=ud26fd039-f29d-4c01-ab1a-2bdffb36a46&title=&width=700" width="700" /> </div>


你的目标是参与尽可能多的工作，那么最多能参与多少项工作呢？
限制条件：

- $1<=N<=10^5$
- $1<=s_i<=t_i<=10^9$

使用贪心求解，可以设计出各种贪心算法，但是只有一种是对的——在可选的工作中，每次选取结束时间最早的工作
这种算法与其他算法相比，在同一时间开始可以选取工作时，其选取的工作结束时间不会比其他方案选取的工作结束时间迟，因此有更多时间执行更多工作
```cpp
const int MAX_N = 100000;
int N, S[MAX_N],T[MAX_N];
pair<int, int> itv[MAX_N];


void solve() {
	//对工作结束时间进行排序，所以把T放入first
	for (int i = 0; i < N; ++i) {
		itv[i].first = T[i];
		itv[i].second = S[i];
	}
	sort(itv, itv + N);
	int ans = 0, t = 0;//t用于标记上个工作结束时间
	for (int i = 0; i < N; ++i) {
		if (itv[i].second > t) {
			++ans;
			t = itv[i].first;
		}
	}
	printf("%d\n", ans);
}
```

### 2.2.3 字典序最小问题
:::tips
**Best Cow Line (POJ3617)**
给定长度为iv的字符串$S$, 要构造一个长度为$N$的字符串$T$起初，$T$是一个空串，随后反复进行下列任意操作。

- 从$S$的头部删除一个字符，加到$T$的尾部
- 从$S$的尾部删除一个字符，加到$T$的尾部

目标是要构造字典序尽可能小的字符串$T$
限制条件：

- $1<=N<=2000$
- 只包含大写英文字母
:::
为了构造字典序最小的字符串，每次优先选择更小的字母加到$T$，就是局部最优解，会有以下情况：
分别将$S$开头和结尾的字符记为$a\ b$

- $a\ b$不相等，则选取较小者
- $a\ b$相等时，为了下次能够尽早用到更小的字符，需要对他们各自下一个位置的字母进行比较
```cpp
int N;
const int MAX_N = 2000;
char S[MAX_N + 1];

void solve() {
	int a = 0, b = N - 1;
	while (a <= b) {
		bool left = false;
		for (int i = 0; i + a <= b; ++i) {
			if (S[a + i]<S[b - i]) {
				left = true;
				break;
			}
			if (S[a + i] > S[b - i]) {
				left = false;
				break;
			}
		}
		if (left)
			putchar(S[a++]);
		else
			putchar(S[b--]);
	}
}
```

### 2.2.4 其他例题

**Saruman's Army (POJ 3069)**
直线上有iV 个点。点/ 的位置是X。从这;V 个点中选择若干个，给它们加上标记。对每一个点，其距离为尺以内的区域里必须有带有标记的点（自己本身带有标记的点，可以认为与其距离为0 的地方有一个带有标记的点）。在满足这个条件的情况下，希望能为尽可能少的点添加标记。请问至少要有多少点被加上标记？

为了达到标记最少的点的目标，应该从最左边未被标记的点$s$开始，找到距离该点为$R$内最远的点$g$，然后进行标记
为了便于下一个被标记点的位置，应该在一轮循环结束之前，提前找到下一个未被标记的点
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680183034564-76139e69-15e6-4cab-96b8-e59835bade85.png#averageHue=%23f5f5f5&clientId=u7010b318-a569-4&from=ui&height=146&id=uf2f1b163&originHeight=206&originWidth=566&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=31144&status=done&style=none&taskId=ucab48477-60fa-4d17-9a0f-06897211c7c&title=&width=400" width="400" /> </div>


```cpp
int N,R;
const int MAX_N = 2000;
int x[MAX_N + 1];

void solve() {
	sort(x, x + N);

	int ans = 0, i = 0;
	while (i < N) {
		int s = x[i++];
		while (i < N && x[i] <= s + R) ++i;//找到能覆盖到左端点的最远的点
		int p = x[i - 1];	//标记点
		while (i < N && x[i] <= p + R) ++i;//找到第一个没有被覆盖的点
		++ans;
	}
	printf("%d\n", ans);
}
```
 


**Fence Repair (POJ 3253)**
农夫约翰为了修理栅栏，要将一块很长的木板切割成$N$块。准备切成的木板的长度为$L_1,L_2,..$未切割前木板的长度恰好为切割后木板长度的总和。每次切断木板时，需要的开销为这块木板的长度。
例如，长度为21 的木板要切成长度为5、8、8 的三块木板。长21 的木板切成长为13 和8 的板时，开销为21。再将长度为13 的板切成长度为5 和8 的板时，开销是13。于是合计开销是34。
请求出按照目标要求将木板切割完最小的开销是多少。

切割的方法可用二叉树描述
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680700673108-805c3a3a-ba9c-46c3-97bf-301db998ca9b.png#averageHue=%23f5f5f5&clientId=ud9503b38-e915-4&from=ui&height=252&id=u48d002c6&originHeight=418&originWidth=996&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=86668&status=done&style=none&taskId=u3298450d-daaa-4172-9681-7d628efdc77&title=&width=600" width="600" /> </div>


叶子节点的深度就是需要切割的次数，可以得出$开销=木板长度\times 深度$
所以为了开销更小，可以将长度更长木板放到深度小的位置，这种思想和霍夫曼编码一样，所以采用霍夫曼算法解决
```cpp
const int MAX_N = 20000;
int N, L[MAX_N];

void solve() {
	long long ans = 0;
	while (N > 1) {
		int min1 = 0, min2 = 1;	//找到长度最小的两块木板
		if (L[min1] > L[min2]) swap(min1, min2);
		for (int i = 2; i < N; i++) {
			if (L[i] < L[min1]) {
				min2 = min1;
				min1 = i;
			}
			else if (L[i] < L[min2]) {
				min2 = i;
			}
		}

		int t = L[min1] + L[min2];	//合并木板
		ans += t;
		//将新的木板加入数组，同时移除原来的两块木板
		if (min1 == N - 1) swap(min1, min2);	
		L[min1] = t;	
		L[min2] = L[N - 1];
		--N;
	}
	printf("%lld\n", ans);
}
```


## 2.3 动态规划
### 2.3.1 记忆化搜索与动态规划

**01 背包问题**
有$n$个重量和价值分别为$w_i\ v_i$的物品。从这些物品中挑选出总重量不超过妒的物品，求所有挑选方案中价值总和的最大值。
限制条件：

- $1\le n\le 100$
- $1\le w_i,v_i\le 100$
- $1\le W \le 10^4$

朴素的思想是，针对每个物品是否放入背包进行搜索，实现如下：
```cpp
const int MAX_N = 100;
int n, W;
int w[MAX_N], v[MAX_N];

int rec(int i, int j) {
	if (i == n)
		return 0;
	if (j < w[i])
		return rec(i + 1, j);
	else
		return max(rec(i + 1, j - w[i]) + v[i], rec(i + 1, j));
}
```
搜索深度为$n$，最坏时间复杂度为$O(2^n)$，分析可以发现，在递归调用的过程，会进行重复的计算，所以可以将计算的结果存储到一个二维数组（有两个参数），这就是记忆化搜索
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680702896783-409bc7be-6d73-418d-a1f7-c038b2bdba3d.png" width="700" /> </div>


记忆化搜索实现如下：
```cpp
const int MAX_N = 100;
int n, W;
int w[MAX_N], v[MAX_N];
int dp[MAX_N + 1][MAX_N + 1];

int rec(int i, int j) {
	if (dp[i][j] >= 0)
		return dp[i][j];
	if (i == n)
		return 0;
	if (j < w[i])
		return rec(i + 1, j);
	else
		return max(rec(i + 1, j), rec(i + 1, j - w[i]) + v[i]);
}

int main() {
	memset(dp, -1, sizeof(dp));
	printf("%d\n", rec(0, W));
	return 0;
}
```
记忆化搜索可以转换成递推，递推公式如下
$dp\left[ i \right] \left[ j \right] =\left\{ \begin{array}{l}
	dp\left[ i+1 \right] \left[ j \right] \ ,j<w\left[ i \right]\\
	\max \left( dp\left[ i+1 \right] \left[ j \right] ,dp\left[ i+1 \right] \left[ j-w\left[ i \right] \right] \right)\\
\end{array} \right.$
因此可以用循环代替递归，时间复杂度没有变，但是简洁了很多




**最长公共子序列问题**LCS（Longest Common Sbusequence）
给定两个字符串$s_1s_2...s_n$和$t_1t_2...t_n$。求出这两个字符串最长的公共子序列的长度。

这个问题是被称为最长公共子序列LCS（Longest Common Sbusequence）的著名问题
可以将$dp[i][j]$定义为$s_1...s_i$和$t_1...t_j$的LCS的长度，递推关系为：
$dp\left[ i+1 \right] \left[ j+1 \right] =\left\{ \begin{array}{l}
	\max \left( dp\left[ i \right] \left[ j \right] +1,dp\left[ i+1 \right] \left[ j \right] ,dp\left[ i \right] \left[ j+1 \right] \right) \ ,s\left[ i \right] ==t\left[ j \right]\\
	\max \left( dp\left[ i+1 \right] \left[ j \right] ,dp\left[ i \right] \left[ j+1 \right] \right)\\
\end{array} \right.$



### 2.3.2 递推关系进一步探讨 

**完全背包问题**
有$n$种重量和价值分别为$w_i \ v_i$的物品。从这些物品中挑选总重量不超过$W$的物品，求出挑选物品价值总和的最大值。在这里，每种物品可以挑选任意多件。

由于每种物品可以选多次，所以相对于01背包，设$dp[i+1][j]$表示从前$i$中挑选总重量不超过$j$的最大价值，递推关系要改为
$dp\left[ i+1 \right] \left[ j \right] =\left\{ \begin{array}{l}
	dp\left[ i \right] \left[ j \right] \,\,,j<w\left[ i \right]\\
	\max \left( dp\left[ i \right] \left[ j-k*w\left[ i \right] \right] +k*v\left[ i \right] \right) \ ,0\le k\\
\end{array} \right.$
代码实现如下：
```cpp
int solve() {
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j <= W; ++j) {
			for (int k = 0; k * w[i] <= j; ++k) {
				dp[i + 1][j] = max(dp[i + 1][j], dp[i][j - k * w[i]] + k * v[i]);
			}
		}
	}
	return dp[n][W];
}
```
此时程序变成了三重循环，最坏时间复杂度为$O(n\times W^2)$
这种递推公式中，有多余的计算——$dp[i+1][j]$中计算选择$k$个情况和在$dp[i+1][j-w[i]]$选择$k-1$的情况是一样的，如下图
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680755760052-bb58498c-116a-4a11-9f03-90146193c58d.png#averageHue=%23e9e9e9&clientId=ud999e277-306e-4&from=ui&height=139&id=u9d2b5864&originHeight=210&originWidth=906&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=90667&status=done&style=none&taskId=ua8b5eeaf-676c-41af-9c66-1d30510f15e&title=&width=600" width="600" /> </div>


可进行优化，从$dp[i+1][j-w[i]]$中推出结果，递推关系可写出这样：
$dp\left[ i+1 \right] \left[ j \right] =\left\{ \begin{array}{l}
	dp\left[ i \right] \left[ j \right] \,\,,j<w\left[ i \right]\\
	\max \left( dp\left[ i \right] \left[ j \right] ,dp\left[ i \right] \left[ j-w\left[ i \right] \right] +v\left[ i \right] \right)\\
\end{array} \right.$
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680755837693-c1269f99-90c3-4d67-b5ea-66ad19190271.png#averageHue=%23eaeaea&clientId=ud999e277-306e-4&from=ui&height=149&id=ubcd41d79&originHeight=211&originWidth=852&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=77616&status=done&style=none&taskId=u330df921-c3de-43e0-ab26-ac958f74acf&title=&width=600" width="600" /> </div>


**DP数组再利用**
在dp二维数组中，只有两行会同时用到，可以利用两个数组滚动来实现重复利用，如下
```cpp
int dp[2][MAX_N + 1];

int solve() {
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j <= W; ++j) {
			if (j < w[i])
				dp[(i + 1) & 1][j] = dp[i & 1][j];
			else
				dp[(i + 1) & 1][j] = max(dp[i & 1][j], dp[(i + 1) & 1][j - w[i]] + v[i]);
		}
	}
	return dp[n&1][W];
}
```
> 这里` i & 1 `和对2取余的结果是一样的




**01 背包问题 之 2**
有$n$个重量和价值分别为$w_i\ v_i$的物品。从这些物品中挑选出总重量不超过妒的物品，求所有挑选方案中价值总和的最大值。
限制条件：

- $1\le n\le 100$
- $1\le w_i,\le 10^7$
- $1\le v_i \le 100$
- $1\le W \le 10^9$

这里和开头的01背包问题修改了数据量大小，此时$O(n\times W)$的时间复杂度显然是过大的；观察可发现，相较于重量，价值的范围较小，可以修改dp数组的意义，$dp[i+1][j
]$表示从前$i$个物品中挑出价值总和为$j$的重量最小值，递推关系为：
$dp\left[ i+1 \right] \left[ j \right] =\min \left( dp\left[ i \right] \left[ j \right] ,dp\left[ i \right] \left[ j-v\left[ i \right] \right] +w\left[ i \right] \right)$
此时时间复杂度为$O\left( n\times \sum{v_i} \right)$
上例可以看出，可以根据问题规模改变递推关系，从而改变算法的时间复杂度。



**多重部分和问题**
有$n$ 种不同大小的数字$a_i$ 每种各$m_i$个。判断是否可以从这些数字之中选出若干使它们的和恰好为$K$
限制条件

- $1\le n\le 100$
- $1\le a_i,m_i \le 10^5$
- $1\le K \le 10^5$

先考虑$dp[i+1][j]$表示能够用前$i$种数字得到$j$
最坏时间时间复杂度为$O(n\times K\times \sum{m_i})$
```cpp
const int MAX_N = 100;
const int MAX_K = 100000;
int n,K;
int a[MAX_N], m[MAX_N];
bool dp[MAX_N + 1][MAX_K + 1];

void solve() {
	dp[0][0] = true;
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j <= K; ++j) {
			for (int k = 0; k <= m[i] && k * a[i] <= j; k++) {
				dp[i + 1][j] |= dp[i][j - k * a[i]];
			}
		}
	}
}
```
以上算法的时间复杂度显然太高，原因是用dp数组仅仅保存bool结果保存的信息太少，效率低的原因和之前完全背包的问题一样，进行了重复的计算，如下图
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1680765969873-b1f4a2dc-41d2-4c87-91b1-f1dda4745bcb.jpeg#averageHue=%23e7e6e5&from=url&height=203&id=tpOA4&originHeight=393&originWidth=1161&originalType=binary&ratio=1&rotation=0&showTitle=false&size=87347&status=done&style=none&title=&width=600" width="600" /> </div>


用$dp[i+1][j]$表示用前$i$中数字加得到$j$时，第$i$种数字最多能剩余多少个（加不到时为-1）
递推关系为
$dp\left[ i+1 \right] \left[ j \right] \left\{ \begin{array}{l}
	m_i\ \ ,dp\left[ i \right] \left[ j \right] \ge 0\\
	-1\ \ ,j<a_i\text{或者}dp\left[ i+1 \right] \left[ j-a_i \right] \le 0\\
	dp\left[ i+1 \right] \left[ j-a_i \right] -1\\
\end{array} \right.$
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1680765970566-e19e28cc-ec9c-4a66-b1de-bcafb17688b4.jpeg#averageHue=%23e8e8e7&from=url&height=199&id=xnFQ0&originHeight=396&originWidth=1196&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56613&status=done&style=none&title=&width=600" width="600" /> </div>


时间复杂度为$O(n\times K)$
由递推式中可以发现，可以只用一个维度的dp数组
```cpp
const int MAX_N = 100;
const int MAX_K = 100000;
int n,K;
int a[MAX_N], m[MAX_N];
int dp[MAX_K + 1];

void solve() {
	memset(dp, -1, sizeof(dp));
	dp[0]=0;
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j <= K; ++j) {
			if (dp[j] >= 0)
				dp[j] = m[i];
			else if (j < a[i] || dp[j - a[i]] <= 0)
				dp[j] = -1;
			else
				dp[j] = dp[j - a[i]] - 1;
		}
	}
}
```



**最长上升子序列问题**LIS（Longest Increasing Subsequence）
有一个长为$n$的数列$a_0,a_1,...,a_{n-1}$。请求出这个序列中最长的上升子序列的长度
上升子序列指的是对于任意的i<j都满足$a_i<a_j$;的子序列。
限制条件：

- $1 ≤n≤1000$
- $0 ≤a_i≤1000000$

最长上升子序列LIS是一个可以用DP高效求解的著名问题
**策略一**：用$dp[i]$表示以$a[i]$结尾的LIS的长度，递推关系为
$dp[i]=max\{1,dp[j]+1\},j<i且a[j]<a[i]$
```cpp
const int MAX_N = 1000;
int n;
int a[MAX_N];
int dp[MAX_N];

void solve() {
	for (int i = 0; i < n; ++i) {
		dp[i] = 1;
		for (int j = 0; j < i; ++j) {
			if (a[j] < a[i])
				dp[i] = max(dp[i], dp[j] + 1);
		}
	}
	printf("%d\n", dp[n]);
}
```
分析以上代码可得，时间复杂度$O(n^2)$

分析以上过程可得，LIS 长度相同时，末位元素越小的序列越有优势，越容易进行拓展，所以可以得出第二种递推关系

**策略二**：用$dp[i]$表示长度为$i+1$的上升序列的末尾最小元素（不存在就是INF），递推关系为
$dp[i]=min\{dp[i],a[j]\}\ \ ,a[j]>dp[i-1]$
如果顺序查找$a[j]>dp[i-1]$实现这个查找过程，时间复杂度为$O(n^2)$，但是dp数组除了INF外是严格递增的，可以进行二分查找，时间复杂度为$O(n*logn)$
```cpp
const int MAX_N = 1000;
int n;
int a[MAX_N];
int dp[MAX_N];

void solve() {
	fill(dp, dp + n, INT_MAX);
	for (int i = 0; i < n; ++i) {
		*lower_bound(dp, dp + n, a[i])=a[i];
	}
	printf("%d\n", *lower_bound(dp, dp + n, INT_MAX));
}
```


### 2.3.3 有关计数问题的DP

**划分数**
有$n$个无区别的物品，将它们划分成不超过$m$组，求出划分方法数模$M$的余数。
限制条件：

- $1\le m\le n\le 1000$
- $2\le M\le 10000$

这样的划分称为$n$的$m$划分。
**尝试一**：先考虑$dp[i][j]$表示$j$的$i$划分，一个尝试是先取出$k$个，然后剩下$j-k$个分为$i-1$份，那么递推公式为$dp\left[ i \right] \left[ j \right] =\sum_{k=0}^j{dp\left[ i-1 \right] \left[ j-k \right]}$，看起来似乎正确，但是由于是无区别的物品，所以是组合问题，以上公式会重复计数，例如$1+1+2$和$1+2+1$会被当成不同划分进行计算。

**尝试二**：考虑别的递推关系，对于$n$的$m$划分$a_i$，如果每个$a_i>0$，那么$\{ a_i-1\}$就是$n-m$的$m$划分，但如果存在$a_i=0$（也就是划分组数小于$m$），此时对应$n$的$m-1$划分。递推关系为：
$dp[i][j]=dp[i][j-i]+dp[i-1][j]$
```cpp
const int MAX_N = 1000;
const int MAX_M = 1000;
int n, m;
int dp[MAX_M][MAX_N];
void solve() {
	dp[0][0] = 1;
	for (int i = 1; i <= m; ++i) {
		for (int j = 0; j <= n; ++j) {
			if(j-i>=0)
				dp[i][j] = dp[i][j - i] + dp[i - 1][j];
			else
				dp[i][j] = dp[i - 1][j];
		}
	}
	printf("%d\n", dp[m][n]);
}
```



**多重集组合数**
有$n$种物品，第$i$种物品有$a_i$个。不同种类的物品可以互相区分但相同种类的无法区分。从这些物品中取出$m$个的话，有多少种取法？求出方案数模$M$的余数。
限制条件：

- $1\le n,m,a_i\le 1000$
- $2\le M \le 10000$

为了不重复计数，同一种类的物品最好一次性处理，所以
$dp[i+1][j]$表示从前$i$种物品中取出$j$个的组合数
在之前划分数问题的尝试一中，由于物品无区别所以会重复计数，但在此处，由于第$i$种物品是和前面是有区别的，所以可以采取该方法：
**策略一**：$dp\left[ i+1 \right] \left[ j \right] =\sum_{k=0}^{\min \left( j,a\left[ i \right] \right)}{dp\left[ i \right] \left[ j-k \right]}$。时间复杂度为$O(n\times m^2)$
**策略二**：对策略一的递推公式进行变形
$\sum_{k=0}^{\min \left( j,a\left[ i \right] \right)}{dp\left[ i \right] \left[ j-k \right]}=\sum_{k=0}^{\min \left( j-1,a\left[ i \right] \right)}{dp\left[ i \right] \left[ j-1-k \right] +dp\left[ i \right] \left[ j \right] -dp\left[ i \right] \left[ j-1-a_i \right]}$
故，$dp[i+1][j]=dp[i+1][j-1]+dp[i][j]-dp[i][j-1-a_i]$
时间复杂度为$O(n\times m)$
```cpp
void solve() {
	for (int i = 0; i <= n; ++i)	//一个都不取的方法总是有1种
		dp[i][0] = 1;
	for (int i = 0; i < n; ++i) {
		for (int j = 1; j <= m; ++j) {
			if (j - 1 - a[i] >= 0)
				dp[i + 1][j] = dp[i + 1][j - 1] + dp[i][j] - dp[i][j - 1 - a[i]];
			else
				dp[i + 1][j] = dp[i + 1][j - 1] + dp[i][j];
		}
	}
	printf("%d\n", dp[n][m]);
}
```


## 2.4 初级数据结构
数据结构是数据存储的方式，不同方式存储数据，可以对数据进行不同的高效操作，本章主要讨论堆、二叉搜索树、并查集。
### 2.4.1 树和二叉树
内容基础，参考[数据结构二叉树](https://www.yuque.com/xiaofeng_garden/we8z43/rsvzzp#gSl4g)部分。

### 2.4.2 优先队列和堆
**优先队列**
能够完成以下操作的数据结构称为优先队列：

- 插入一个元素
- 每次取数取出最小元素（获得数值，并删除）

**二叉堆**
二叉堆是像下图那样的数据结构，其最终要的性质就，子节点的值不小于父节点的值（小根堆）
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681297196599-b75943d6-4dbd-4cf3-ac5e-05d2460636c4.png#averageHue=%23fbfbfb&clientId=ub91eb273-8823-4&from=ui&height=195&id=u8d7955c0&originHeight=306&originWidth=786&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=33032&status=done&style=none&taskId=ufd27c1cb-4f40-4552-8038-09226bdcca0&title=&width=500" width="500" /> </div>


堆排序的建立堆的过程，参考[数据结构堆排序](https://www.yuque.com/xiaofeng_garden/we8z43/rsvzzp#YupC2)，现在简单介绍堆添加元素和删除元素的操作：

- 添加元素：先在堆的末尾插入该数值，然后不断向上调整直到没有大小颠倒的情况。
- 删除元素：把最后一个元素的值复制到根节点，然后删除最后一个节点，从根节点开始不断向下调整直到没有大小颠倒的情况，向下交换的过程中，有两个子节点，优先选择数值较小的子节点进行交换。

**堆操作效率**
堆的两种操作都和树的深度成正比，如果有$n$个元素，对于优化之后的二叉堆（比较接近平衡二叉树），操作的时间复杂度为$O(log\ n)$。

**堆的实现**
使用数组来实现堆，下标从$0$开始，设节下标为$i$，则有：

- 左子节点下标：$2*i+1$
- 右子节点下标：$2*i+2$

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681352311747-6a9e4b93-ce52-4811-93d8-0c1dfd5da01a.png#averageHue=%23f7f7f7&clientId=u174a7248-3fae-4&from=ui&height=189&id=u4b1cf6c7&originHeight=341&originWidth=902&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=64958&status=done&style=none&taskId=uaf8c6afa-8510-49c4-9fe9-4da4e33ddf4&title=&width=500" width="500" /> </div>


代码实现堆如下：
```cpp
const int MAX_N = 1000;
int heap[MAX_N],sz=0;

void push(int x) {
	int i = sz++;
	while (i > 0) {
		int p = (i - 1) / 2;
		if (heap[p] <= x)
			break;
		heap[i] = heap[p];
		i = p;
	}
	heap[i] = x;
}
int pop() {
	int ret = heap[0];
	int x = heap[--sz];
	int i = 0;
	while (i * 2 + 1 < sz) {
		int a = 2 * i + 1, b = 2 * i + 2;
		if (b < sz && heap[b] < heap[a])
			a = b;
		if (heap[a] >= x)
			break;
		heap[i] = heap[a];
	}
	heap[i] = x;
	return ret;
}
```
C++ STL的`priority_queue`是优先队列的高效实现，默认情况下取出的数值是最大值，如果需要每次取出的是最小值，需要在创建对象时，重载比较运算符：
`priority_queue< int, vector<int>, greater<int> >`
`greater<int>`是一个可调用对象，当第一个数大于第二个数时返回`true`

**需要优先队列的题目**

**Expedition (POJ 2431)**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681353611580-29529e98-dc08-459d-93e7-276abea903b2.png#averageHue=%23eff0f0&clientId=u174a7248-3fae-4&from=ui&height=255&id=ueda5c446&originHeight=410&originWidth=1125&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=120101&status=done&style=none&taskId=u0aa74ef6-76bd-4179-953f-6123e223d7e&title=&width=700" width="700" /> </div>


在经过加油站$i$之后，在之后任何时候有加$B_i$单位油的权利。为了使得加油次数尽量少，使用以下贪心策略：

- 卡车不够燃料去到下一个加油站才加油。
- 优先选择可加的加油量最大的加油站。

使用优先队列解决如下：
```cpp
const int MAX_N = 10000;
int L, P, N;
int A[MAX_N + 1], B[MAX_N + 1];
void solve() {
	A[N] = L;
	B[N] = 0;
	N++;
	priority_queue<int> que;
	int ans = 0, pos = 0, tank = P;
	for (int i = 0; i < N; ++i) {
		int d = A[i] - pos;
		while (tank - d < 0) {
			if (que.empty()) {
				cout << "-1" << endl;
				return;
			}
			tank += que.top();
			que.pop();
			++ans;
		}
		tank -= d;
		pos = A[i];
		que.push(B[i]);
	}
	cout << ans << endl;
}
```

之前在贪心提到的[**Fence Repair (POJ 3253)**](https://www.yuque.com/xiaofeng_garden/we8z43/fo4uzlfkfrc8hexg?inner=ubdd90526)，可以使用优先队列将时间复杂度降为$O(N*log N)$。

### 2.4.3 二叉搜索树
二叉搜索树的简单介绍参考[**数据结构二叉搜索树**](https://www.yuque.com/xiaofeng_garden/we8z43/rsvzzp#NmyTJ)**。**
**二叉搜索树的实现**
C++中，set容器是使用二叉搜索树来维护集合的容器，map容器是用红黑树来维护key和value的容器。

### 2.4.4 并查集
并查集的简单介绍参考[**Union_Find**](https://www.yuque.com/xiaofeng_garden/we8z43/pxbnx9iuv32xmxzc#wPH4M)**。**
**并查集的效率**
经过加入`rank`和路径压缩优化的并查集效率非常高，对$n$个元素的并查集进行一次操作的复杂度为$O(\alpha(n))$，$\alpha(n)$为阿克曼函数的反函数，比$O(log \ n)$更快。
这里的复杂度为均摊复杂度，是进行多次操作之后的平均复杂度。

**并查集的实现**
```cpp
#include<stdc++.h>
using namespace std;

const int MAX_N = 10000;
int par[MAX_N], r[MAX_N];

void init(int n) {
	for (int i = 0; i < n; ++i) {
		par[i] = i;
		r[i] = 0;
	}
}

int find(int x) {
	if (par[x] == x)
		return x;
	else
		return par[x] = find(par[x]);//路径压缩
}

void nuite(int x, int y) {
	x = find(x);
	y = find(y);
	if (x == y)
		return;
	if (r[x] < r[y]) {
		par[x] = y;
	}
	else {
		par[y] = x;
		if (r[x] == r[y])
			++r[x];
	}
}

bool same(int x, int y) {
	return find(x) == find(y);
}
```


**需要并查集的题目**

**食物链（POJ 1182)**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681355861071-eb161a12-7ebf-4166-92f6-689e71e62fae.png#averageHue=%23eff0f0&clientId=u3779dd36-e8d4-4&from=ui&height=274&id=u74665977&originHeight=454&originWidth=1160&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=97560&status=done&style=none&taskId=u1c58d5a0-998a-4553-9e95-f6ac3156993&title=&width=700" width="700" /> </div>


并查集用于维护是否属于同一组的问题，但是在本题中，还有捕食关系。
本题的并查集表示同一集合中的事情可以同时发生，所以对于每个动物维护3个元素，分别表示属于A、B、C类的某种情况。
```cpp
const int MAX_K = 100000;
int N, K;
int T[MAX_K], X[MAX_K], Y[MAX_K];

void solve() {
	init(N * 3);
	int ans = 0;
	for (int i = 0; i < K; ++i) {
		int t = T[i];
		int x = X[i] - 1, y = Y[i] - 1;
		if (x < 0 || x >= N || y < 0 || y >= N) {	//检查超出范围的错误
			++ans;
			continue;
		}
		if (t == 1) {	//第一种情况：x和y属于同一类
			if (same(x, y + N) || same(x, y + 2 * N))	//表明和之前的信息冲突
				++ans;
			else {
				unite(x, y);
				unite(x + N, y + N);
				unite(x + 2 * N, y + 2 * N);
			}
		}
		else {		//第二种情况：x吃y
			if (same(x, y) || same(x, y + 2 * N))
				++ans;
			else {
				unite(x, y + N);
				unite(x + N, y + 2 * N);
				unite(x + 2 * N, y);
			}
		}
	}
	cout << ans << endl;
}
```



## 2.5 图
### 2.5.1 图的基本概念
参考[数据结构图的基本概念](https://www.yuque.com/xiaofeng_garden/we8z43/rsvzzp#aFeLC)。


### 2.5.2 图的表示
主要有邻接矩阵和邻接表两种方式，具体参考[数据结构图的存储结构](https://www.yuque.com/xiaofeng_garden/we8z43/rsvzzp#QDfuQ)。


### 2.5.3 图的搜索
图的搜索主要有DFS和BFS两种，只需要在遍历过的节点做标记即可。以下介绍应用。

**二分图判定**
给定一个具有$n$个顶点的图。要给图上每个顶点染色，并且要使相邻的顶点颜色不同。问是否能最多用2 种颜色进行染色？题目保证没有重边和自环。
限制条件：

- $1\le n \le 1000$

最小着色数为2的图为二分图。由于只用两种颜色，在一个顶点的颜色确定之后，与其相邻的顶点的颜色也就确定了。用DFS可进行实现：
```cpp
int V;
vector<vector<int>> G(V);
vector<int> color(V);

bool dfs(int v, int c) {
	color[v] = c;
	for (int i = 0; i < G[v].size(); ++i) {
		if (color[G[v][i]] == c)
			return false;
		if (color[G[v][i]] == 0 && !dfs(G[v][i], -c))
			return false;
	}
	return true;
}
void solve() {
	for (int i = 0; i < V; ++i) {
		if (color[i] == 0) {
			if (!dfs(i, 1)) {
				cout << "NO" << endl;
				return;
			}
		}
	}
}
```
由于题目不保证是连通图，所以需要在`solve`函数对所有顶点检测一遍。其实可以把DFS的递归改为循环，参考[1042. 不邻接植花](https://www.yuque.com/xiaofeng_garden/we8z43/wti401gn2mc941p0#BYNv0)。


### 2.5.4 最短路问题
最短路问题是图论中最基础的问题，在程序设计竞赛试题中经常出现。

**单源最短路问题——Bellman-Ford算法**
设$d[i]$为从起点出发到顶点$i$的最短距离，递推公式如下：
$d\left[ i \right] =\min \left( d\left[ j \right] +\cos t\left( j,i \right) \right) ,\ \left( j,i \right) \in E$
算法实现如下，时间复杂度为$O(|V|\times |E|)$。
```cpp
int V, E;
struct edge {
	int from, to;
	int cost;
};
vector<int> d(V,INF);
vector<edge> es(V);

void bellman_ford(int s) {
	d[s] = 0;
	while (true) {
		bool update = false;
		for (int i = 0; i < E; ++i) {
			edge e = es[i];
			if (d[e.from] != INF && d[e.to] > d[e.from] + e.cost) {
				d[e.to] = d[e.from] + e.cost;
				update = true;
			}
		}
		if (!update)
			break;
	}
}
```
该算法适用于图中没有从s可达的负环的情况。在不存在负环的情况下，从s出发最短路的不会经过同一个顶点两次，因此上述代码的`while(true)`循环最多执行`|V|-1`次。
> 每执行一次外层`while`循环，相当于从s出发的确定的最短路径的长度加一，即往外多确定了一个节点到s的最短路径。

如果存在负环，`while(true)`循环将会一直进行下去，循环次数必然超过`|V|-1`次，可以根据这个性质来判定图是否有负环。
```cpp
bool find_negative_loop() {
	for (int i = 0; i < V; ++i) {
		for (int j = 0; j < E; ++j) {
			edge e = es[j];
			if (d[e.to] > d[e.from] + e.cost) {
				d[e.to] = d[e.from] + e.cost;
				if (i == V - 1)
					return true;
			}
		}
	}
	return false;
}
```

**单源最短路问题——Dijkstra算法**
在没有负边的情况下，Bellman-Ford算法中，如果$d[j
]$不是最短距离，那么根据递推公式计算出来的结果也必然不是最短距离，此外在一个循环中，即使$d[j]$的值没有发生变化，也依然要检测一次从$j$出发的所有边。
Dijkstra算法是基于贪心的算法，思想如下：

- 在已经确定最短距离的顶点中，选出最优的那个，从它出发更新相邻顶点最短距离。
- 此后不再需要考虑上面使用过的最优顶点。

Dijkstra算法是建立在没有负边的基础上的，因为不存在负的边，$d[i]$在之后的更新不会变大，所以能抛弃使用过（曾经用来拓展顶点）的顶点。
```cpp
int cost[MAX_V][MAX_V]; //邻接矩阵
int d[MAX_V];           //最短路径长度
bool used[MAX_V];       //标记顶点是否被使用过
int V;

void dijkstra(int s){
    fill(d,d+V,INF);
    fill(used,used+V,false);    //一开始都没有被使用过
    d[s]=0;

    while(true){
        int v=-1;   //用来保存最优节点
        for(int i=0;i<V;++i){
            if(!used[i]&&(v==-1||d[i]<d[v])){
                v=i;
            }
        }
        if(v==-1)   //算法结束
            break;
        for(int i=0;i<V;++i){
            d[i]=min(d[i],d[v]+cost[v][i]);
        }
    }
}
```
使用邻接矩阵实现的Dijkstra算法时间复杂度为$O(|v|^2)$，使用邻接表算法复杂度也一样，但是如何使用优先队列（堆）来保存顶点和查找最优顶点，时间复杂度为$O(|E|\times log|V|)$。使用优先队列实现需要注意：放入优先队列的值有可能会在之后的步骤更新，所有在取出值时需要和$d[i]$进行对比判断。
```cpp
struct edge {int to,cost;};
typedef pair<int,int> P; //first是最短距离，second是顶点的编号
int V;//顶点个数
vector<edge> G[MAXV];
int d[MAXV];

void dijkstra(int s)
{
    priority_queue<P,vector<P>,greater<P> > que;
    memset(d,INF,sizeof d);
    d[s] = 0;
    que.push(P(0,s)); //把起点推入队列
    while(!que.empty())
    {
        P p = que.top(); que.pop();
        int v = p.second; //顶点的编号
        if (d[v] < p.first)             //此时需要进行比对，如果和d[v]不一样直接丢弃，不需要重新入队，因为该值在之前的更新中已经入队了
            continue;   
        for(int i = 0; i < G[v].size(); i++)
        {
            edge e = G[v][i];
            if (d[e.to] > d[v] + e.cost)
            {
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}
```

**任意两点间的最短路算法——Floyd-Warshall算法**
可以使用$|V|$次Dijkstra算法，这里尝试用DP解决，用$dp[k+1][i][j]$表示在只用顶点$0-k$和$i、j$从$i$到$j$的最短路径长度，递归关系为
$dp\left[ k \right] \left[ i \right] \left[ j \right] =\min \left( dp\left[ k-1 \right] \left[ i \right] \left[ j \right] \ ,\ dp\left[ k-1 \right] \left[ i \right] \left[ k \right] +dp\left[ k-1 \right] \left[ k \right] \left[ j \right] \right)$
也可以用二维数组实现$dp\left[ i \right] \left[ j \right] =\min \left( dp\left[ i \right] \left[ j \right] \ ,\ dp\left[ i \right] \left[ k \right] +dp\left[ k-1 \right] \left[ k \right] \left[ j \right] \right)$，时间复杂度一样为$O(|V|^3)$。
这就是Folyd算法，可以处理负边的情况（同样不能有负圈）。

**路径还原**
如果不仅仅要求求出最短路径长度，还要求出具体路径，对于Dijkstra算法，可以用一个`prev[i]`数组记录最短路上节点的前驱。


### 2.5.5 最小生成树
根据MST性质，使用贪心算法来求最小生成树，有两种不同的策略：
**Prim算法**
设已经变成树的顶点集合为$x$，在连接$x$和$V-x$的边中选出权值最小的边$(i,j)$，把顶点$j$加入集合$x$。
```cpp
int cost[MAX_V][MAX_V];
int mincost[MAX_V];
bool used[MAX_V];
int V;

int prim(){
    //初始化
    for(int i=0;i<V;++i){
        mincost[i]=INF;
        used[i]=false;
    }
    mincost[0]=0;
    int ans=0;
    while(true){
        int v=-1;
        while(used[i]==false&&(v==-1||mincost[i]<mincost[v]))
            v=i;
        if(v==-1)
            break;
        used[v]=true;
        ans+=mincost[v];
        for(int i=0;i<V;++i){
            mincost[i]=min(mincost[i],cost[i][v]);
        }
    }
    return ans;
}
```
算法时间复杂度为$O(|V|)$，用优先队列优化的时间复杂度为$O(|E|\times log|V|)$。

**Kruskal算法**
Kruskal算法按照边的权值的顺序从小到大査看一遍，如果不产生圈(重边等也算在内）,就把当前这条边加入到生成树中。
Kruskal算法在取边时需要判断边和重边，也就判断边的两个端点是否在同一个集合里面，可以用并查集高效实现，算法时间复杂度为$O( sort( |E| ) ) + O(|E| * alpha( |V| )$。
```cpp
struct edge{
    int u,v,cost;
};
bool cmp(const edge& a,const edge& b){
    return a.cost<b.cost;
}

edge es[MAX_E];
int V,E;

int Kruskal(){
    int ans=0;
    sort(es.es+E,cmp);
    init_union_find(V);
    for(int i=0;i<E;++i){
        edge e=es[i];
        if(same(e.u,e.v)==false){//边的两个顶点不在同一集合
            unite(e.u,e,v);
            ans+=e.cost;
        }
    }
    return ans;
}
```


### 2.5.6 应用问题

**Roadblocks (POJ No.3255)**
某街区共有条$R$道路、$N$个路口。道路可以双向通行。问1 号路口到$N$号路口的次短路长度是多少？次短路指的是比最短路长度长的次短的路径。同一条边可以经过多次。
限制条件 ：

- $1\le R\le 5000$
- $1\le N \le 100000$

用Dijkstra算法可以容易求出最短路，但对于次短路需要额外处理。到顶点$v$的次短路，要么是到顶点$u$的最短路加上$u\rightarrow v$，要么是到顶点$u$的次短路加上$u\rightarrow v$。
具体实现同时记录最短路和次短路，然后在进行Dijkstra算法同步更新即可。
```cpp
struct edge{
    int to,cost;
};
vector<edge> G[MAX_N];
typedef pair P;
int dist[MAX_N];
int dist2[MAX_N];
int N;

int solve(){
    priotity_queue <P,vector<P>,greater<P>>  que;
    //初始化
    fill(dist,dist+N,INF);
    fill(dist2,dist2+N,INF);
    dist[0]=0;
    que.push(P{0,0});
    while(!que.empty()){
        P p=que.top();
        que.pop();
        int v=p.second,d=p.first;
        if(d>dist2[v]) continue;
        int d2=d+e.cost;
        for(int i=0;i<G[v].size();++i){
            edge& e=G[v][i];
            if(dist[e.to]>dw){
                swap(dist[e.to],d2);
                que.push(P{dist[e.to],e.to});
            }
            if(dist2[e.to]>d2&&dist[e.to]<d){
                dist2[e.to]=d2;
                que.push(P{d2,e.to});
            }
        }
    }
    return dist2[N-1];
}
```


**Conscription (POJ No.3723)**
需要征募女兵$N$人，男兵$M$人。每征募一个人需要花费10000 美元。但是如果已经征募的人中有一些关系亲密的人，那么可以少花一些钱。给出若干的男女之间的1~9999 之间的亲密度关系，征募某个人的费用是10000-( 已经征募的人中和自己的亲密度的最大值）。要求通过适当的征募顺序使得征募所有人所需费用最小。
限制条件 ：

- $1\le N,M\le 10000$
- $0\le R \le 50000$
- $0<d<10000$

问题是最大权森林问题，可用最小生成树的变形解决，可以把边取反然后用最小生成树算法求解出可以减去的费用。在本题中图不一定是连通图，如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681734380403-180c244c-0b5d-43bf-bae1-f1bd444dc2f1.png#averageHue=%23eff0f0&clientId=u7d768cc3-1477-4&from=ui&height=155&id=u42a81de0&originHeight=231&originWidth=746&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=30327&status=done&style=none&taskId=u55521add-64e7-43ae-a0d1-1ca9c7bc88a&title=&width=500" width="500" /> </div>


最小权森林问题但是依然可以用之前的Kruskal算法解决，但是不能用prim算法。


**Layout (POJ No.3169)**
农夫约翰养了N头牛，编号分别是1到N。现在，它们要进食，按照编号顺序排成了一排。在它们之间有一些牛关系比较好，所以希望彼此之间不超过一定距离，也有一些牛关系比较不好，所以希望彼此之间至少要满足某个距离。此外，牛的性格比较颦，所以有可能有多头牛挤在同一个位置上。给出了ML个关系好的牛的信息(AL,BL,DL )以及MD个关系不好的牛的信息(AD,BD,DD)。这表示的是牛AL与牛BL之间的最大距离DL和牛AD与牛BD之间的最小距离DD。在满足这些条件的排列方法中，求1号牛和N号牛之间的最大距离。如果不存在任何一种排列方法满足条件则输出-1。无限大的情况输出-2。
限制条件：

- $2≤N≤1000$
- $1≤ML,MD≤100001≤AL<BL≤N$
- $1≤AD<BD≤N$
- $1≤DL, DD≤1000000$

记第$i$头牛的位置为$d[i]$，有以下约束关系：

- $d[i]\le d[i+1]$
- $d[AL]+DL>=d[BL]$
- $d[AD]+DD\le d[BD]$

如果采取[单纯性法](https://cloud.tencent.com/developer/article/1087679)解决，较为复杂，本题可以采用图的最短路问题解决。对于最短路问题这样的关系：$d[u]+u\rightarrow v>=d[v]$，和上面的约束关系形式很相近，处理如下：

- $d[i]\le d[i+1]+0$
- $d[BL]\le d[AL]+DL$
- $d[AD]\le d[BD]-DD$

分别对应两个顶点之间边的权重，由于权重存在负值，所以采用Bellman-Ford算法。
```cpp
//input
int N, ML, MD;
int AL[MAX_ML], BL[MAX_ML], DL[MAX_ML];
int AD[MAX_MD], BD[MAX_MD], DD[MAX_MD];

int d[MAX_N]; // 最短距离

int solve(){
    fill(d,d+N,INF);
    d[0]=0;
    for(int k=0;k<N;++k){   //在没有负环的情况下，最多循环N次
        for(int 0;i+1<N;++i){
            if(d[i+1]<INF){
                d[i]=min(d[i],d[i+1]);
            }
        }
        for(int i=0;i<ML;++i){
            if(d[AL[i]-1]<INF){
                d[BL[i]-1]=min(d[BL[i]-1],d[AL[i]-1]+DL[i])
            }
        }
        for(int i=0;i<MD;++i){
            if(d[BD[i]-1]<INF){
                d[AD[i]-1]=min(d[AD[i]-1],d[BD[i]-1]+DD[i])
            }
        }
    }
    if(d[N-1]<0)    //负环
        return -1;
    else if(d[N-1]==INF)    //无解
        return -1;
    return d[N-1];
}
```



## 2.6 数学
### 2.6.1 辗转相除法
**求最大公约数**

**线段上格点的个数**
给定平面上的两个格点$P_1=(x_1,y_1)$和$P_2=(x_2,y_2)$，线段$P_1P_2$上，除$P_1P_2$以外一共有几个格点？
限制条件：

- $-10^9\le x_1,y_1,x_2,y_2\le 10^9$

对于范围内的点一个一个的进行检查虽然可以得到答案，但是时间复杂度高，所以另辟蹊径。一个例子如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681819638638-bf12bb89-dec1-4412-a508-39142285ef6a.png#averageHue=%23fdfdfd&clientId=u9407381f-c394-4&from=ui&height=288&id=u6fcadfc6&originHeight=526&originWidth=913&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=30439&status=done&style=none&taskId=ued416ad0-e159-4c50-96d3-e91113c2377&title=&width=500" width="500" /> </div>


所求格点的数量就是$|x_1-x_2|$和$|y_1-y_2|$的最大公约数$-1$。以下介绍求最大公约数的方法——欧几里德算法：
设$gcd(a,b)$为求$a$和$b$最大公约数的函数，如果$a$除以$b$的商和余数分别为$p$和$q$，即$a=b\times p+q$，则$gcd(b,q)$必定能整除$a$和$b$，有$gcd(a,b)=gcd(b,a\%b)$，这样循环进行下去，最终会得到$gcd(a,b)=gcd(c,0)$，则$c$就是最大公约数。
```cpp
int gcd(int a,int b){
    if(0==b)
        return a;
    return gcd(b,a%b);
}
```

**复杂度分析**
粗略估计辗转相除法的时间复杂度在$O(log\ max(a,b))$以内。
C++ STL中`gcd`函数求最大公因数，`lcm`函数求最小公倍数，定义在头文件`numeric`中。

**拓展欧几里德算法**

**双六**
一个双六上面有向前向后无限延续的格子，每个格子都写有整数。其中0号格子是起点，1号格子是终点3，而骰子上只有$a,b,-a,-b$四个整数，所以根据a 和b 的值的不同，有可能无法到达终点。
掷出四个整数各多少次可以到达终点呢？如果解不唯一，输出任何一组皆可。如果无解，输出-1。
限制条件：

- $1\le a,b\le 10^9$

题目的意思就是求整数$x$和$y$使得$xa+yb=1$。以下介绍拓展欧几里得算法：主要用于求解$ax+by=gcd(a,b)$的一组可行解的问题。
由裴蜀定理以及欧几里德算法得，$ax_1+by_1=gcd\left( a,b \right)$,$bx_2+\left( a\%b \right) y_2=gcd\left( b,a\%b \right)$
有，$ax_1+by_1=bx_2+\left( a-\lfloor \frac{a}{b} \rfloor \times b \right) y_2=ay_2+b\left( x_2-\lfloor \frac{a}{b} \rfloor \times b\times y_2 \right)$
故，$x_1=y_2,y_1=x_2-\lfloor \frac{a}{b} \rfloor \times y_2$
将$x_2,y_2$不断代入递归求解直至 $gcd$为 0 递归 $x=1,y=0$ 回去求解。
```cpp
int Exgcd(int a, int b, int &x, int &y) {
  if (b==0) {
    x = 1;
    y = 0;
    return a;
  }
  int d = Exgcd(b, a % b, x, y);
  int t = x;
  x = y;
  y = t - (a / b) * y;
  return d;
}
```

**值域分析**
用数学归纳法可以证明$|x|\le b,|y|\le a$，证明过程参考[OIwiki](https://oi-wiki.org/math/number-theory/gcd/)。


### 2.6.2 有关素数的基础算法
**素数判定**
给定整数请判断$n$是不是素数。
限制条件：
- $1\le n \le 10^9$

对于单个整数的判断，可以检测$2-n-1$是否能整除$n$。如果$d$是$n$的约数，那么$n/d$也是$n$的约数，$min(d,n/d)\le \sqrt{n}$。
类似的算法，除了可以解决素数判定，还可以解决约数枚举、整数分解问题，如下：
```cpp
//素性判定
bool is_prime(int n){
    for(int i=2;i*i<=n;++i){
        if(n%i==0)
            return false;
    }
    return n！=1;//特殊情况
}

//约数枚举
vector<int> divisor(int n){
    vector<int> res;
    for(int i=1;i*i<=n;++i){
        if(n%i==0){
            res.push_back(i);
            if(i!=n/i) res.push_back(n/i);
        }
    }
    return res;
}

//整数分解
map<int,int> prime_factor(int n){
    map<int,int> res;
    for(int i=2;i*i<=n;++i){
        while(n%i==0){
            ++res[i];
            n/=i;
        }
    }
    if(n!=1) res[n]=1;
    return res;
}
```

**埃氏筛法**
对于一个整数进行判断，可以接受$O(\sqrt n)$的算法，但对于对多个整数进行素性判断，使用埃氏筛法。

**素数的个数**
给定整数$n$ 请问$n$以内有多少个素数?
- $1\le n \le 10^6$
算法核心思想——一个数的整数倍必然不是素数。
```cpp
//埃氏筛法
int prime[MAX_N];
bool is_prime[MAX_N];
int solve(int n){
    int p=0;
    for(int i=0;i<=n;++i) is_prime[i]=true;
    is_prime[0]=is_prime[1]=false;
    for(int i=2;i<=n;++i){
        if(is_prime[i]){
            prime[p++]=i;
            for(int j=2*i;j<=n;j+=i){
                is_prime[j]=false;
            }
        }
    }
    return p;
}
```
埃氏筛的时间复杂度为$O(nloglogn)$，证明[参考此处](https://www.cnblogs.com/dc93/p/3930362.html)，在比赛中的数据规模可以看作是线性的。

**区间筛法**

**区间内素数的个数**
给定整数$a$和$b$, 请问区间$[a,b)$内有多少个素数？
- $a<b\le 10^{12}$
- $b-a\le 10^6$

$b$以内所有合数的最小质因数一定不超过$\sqrt{b}$。所以先求$\sqrt{b}$以内的素数表，再在$[a,b)$上利用埃氏筛法。
```cpp
//区间筛法
bool is_prime[MAX_L];
bool is_prime_small[MAX_SQRT_B];

void segment_sieve(long long a,long long b){
    for(int i=0;(long long)i*i<b;++i) is_prime_small[i]=true;
    for(int i=0;i<b-a;++i) is_prime[i]=true;

    for(int i=2;(long long)i*i<b;++i){
        if(is_prime_small[i]){
            for(int j=2*i;(long long)j*j<b;j+=i){
                is_prime_small[j]=false;
            }
            for(long long j=max(2LL,(a+i-1)/i)*i;j<b;j+=i){
                is_prime[j-a]=false;
            }
        }
    }
}
```


### 2.6.3 模运算
**为什么需要模运算**
在程序设计竞赛中，对结果进行取模可以避免超出64整数的范围，消除语言差异带来的不利因素（C和C++没有自带的高精度计算）。

**基本模运算**
对$m$同余：即两整数对$m$取余结果相同，记作$a\equiv b\left( mod\ m \right)$，同余具有以下性质：

- 如果$a\equiv b\left( mod\ m \right)$，则$\left( a-b \right) mod\ m=0$。

如果$a\equiv c\left( mod\ m \right)$且$b\equiv d\left( mod\ m \right)$，则有：

- $a+b\equiv c+d\left( mod\ m \right)$
- $a-b\equiv c-d\left( mod\ m \right)$
- $a\times b\equiv c\times d\left( mod\ m \right)$


### 2.6.4 快速幂运算

**Carmichael Numbers ( UVa No.10006 )**
我们把对任意的$1<x<n$都有$x^n\equiv x\left( mod\ n \right)$成立的合数$n$称为Carmichael Number。对于给定的
整数$n$，请判断它是不是Carmichael Number。
- $2<n<65000$

如果按常规方法计算$n$次幂，时间复杂度为$O(n)$，在本题中总的时间复杂度为$O(n^2)$。
现在介绍一种时间复杂度为$O(logn)$计算$n$次幂的方法——反复平法。
如果$n=2^k$，那么$x^n=((x^2)^2)...$，只需做$k$次平方运算。
对一任意一个整数$n$，可表示为$n=2^{k_1}+2^{k_2}+...$，对应了其二进制的$1$，有：
$x^n=x^{2^{k_1}}\times x^{2^{k_2}}\times ...$
利用位运算代码实现：
```cpp
long long mod_pow(long long x,long long n,long long mod){
    long long res=1;
    while(n>0){
        if(n&1) res=res*x%mod;
        x=x*x%mod; //计算x^2 x^4 x^8....
        n>>=1;
    }
    return res;
}
```

也可以这样来理解：

- $n$为偶数时，$x^n=\left( x^2 \right) ^{\frac{n}{2}}$
- $n$为奇数时，$x^n=\left( x^2 \right) ^{\frac{n}{2}}\times x$

不断递归求解，代码实现如下：
```cpp
long long mod_pow(long long x,long long n,long long mod){
    if(n==0)
        return 1;
    long long res=mod_pow(x*x%mod,n/2,mod);
    if(n&1) res=res*x&mod;  //对应n位奇数的情况，需多乘一个x
    return res;
}
```



## 2.7 应用

**Minimum Scalar Product (2008 Round1AA)**
有两个向量$v_1=(x_1,x_2,...,x_n)$和$v_2=(y_1,y_2,...,y_n)$，允许任意交换$v_1$和$v_2$各自的分量的顺序。请计算交换顺序之后两个向量的内积的最小值。

使用贪心解决，$v_1$的小的分量优先和$v_2$的最大的分量相乘，可得到内积最小值。


**Crazy Rows ( 2009 Round2 A )**
给定一个由0 和1 组成的矩阵。只允许交换相邻的两行（第$i$行和第$i+1$ 行）， 要把矩阵化成下三角矩阵（主对角线上方的元素都是0)， 最少需要交换几次？输入的矩阵保证总能化成下三角矩阵。

对于第1行，在下三角矩阵中，最后一个1的位置必然<=1，对于其他行也如此。可以先统计原矩阵每一个最后一个1出现的位置。算法从第一行开始遍历，当下面的行有多个满足条件的行时，优先选择最近的，可以使得交换次数最少。
一个疑问：如果当前遍历到第`i`行，从`j=i`开始往下寻找第一个合适的行`a[j]<=i`会不会使得后面的行找不到合适的行？——不会，由于从上往下遍历，对于第`i`行匹配的行，对于后面的行也一定匹配。
第二个疑问：当下面的行有多个满足条件的行时，优先选择最近的，会不会让后面的操作次数增加？——有可能会让后面操作次数增加，但是本次操作次数少了，后面操作次数多了，这种情况总的操作次数还是一样的；如果不是让后面操作次数增加的情况，不优先选最近的行，会让总的操作次数增加。



**Bribe the Prisoners ( 2009 Round 1C C )**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681981124390-4ab4f484-3a0e-4a08-a5f3-82b3c86dbd18.png#averageHue=%23e7e7e7&clientId=u70308580-e902-4&from=ui&height=536&id=u8d36c986&originHeight=737&originWidth=963&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=148984&status=done&style=none&taskId=u72dc537b-2cb1-4f7d-97f4-0f4c80018ab&title=&width=700" width="700" /> </div>



问题是先选哪个囚犯的问题，选了一个囚犯又需要考虑下一个选哪个囚犯，可以递归进行下去，为了避免重复计算可改成记忆化搜索，再改成递推。
用$dp[i][j]$记录释放$(i,j)$范围内所需释放囚犯需要的最小金币，递推的过程如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1681984673730-887ae49d-d380-4b4b-ac88-e3824944c09a.jpeg#averageHue=%23fafafa&clientId=u70308580-e902-4&from=ui&height=185&id=u4b92d32f&originHeight=539&originWidth=1749&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=44801&status=done&style=none&taskId=u8b60aa6b-d486-444e-99d1-932b8be42e8&title=&width=600" width="600" /> </div>


发现只需要记录$i$和$j$关有需要被释放的囚犯的$dp[i][j]$。所以为了避免空间浪费，用$dp[i][j]$记录释放$(A[i],A[j])$范围内所需释放囚犯需要的最小金币
```cpp
int P,Q,A[MAX_Q+2];
int dp[MAX_Q+1][MAX_Q+2];
void solve(){
    A[0]=0;
    A[Q+1]=P+1;
    for(int q=0;q<=Q;++q){//区间中间没有要释放的囚犯，故为0
        dp[q][q+1]=0;
    }

    for(int w=2;w<=Q+1;++w){
        for(int i=0;i+w<=Q+1;++i){//w为区间间隔，w为2，表示区间之间有一个要释放的囚犯
            int j=i+w,t=INT_MAX;
            for(int k=i+1;k<j;++k){
                t=min(t,dp[i][k]+dp[k][j]);
            }
            dp[i][j]=t+A[j]-A[i]-2;
        }
    }
    printf("%d",dp[0][Q+1]);
}
```



**Millionaire ( 2008 APAC local onsites C )**
你被邀请到某个电视节目中去玩下面这个游戏。一开始你有$x$元钱，接着进$M$轮赌博。每一轮，可以将所持的任意一部分钱作为赌注。赌注不光可以是整数，也可以是小数。一分钱不押或全押都没有关系。每一轮都有P的概率可以赢，赢了赌注就会翻倍，输了赌注就没了。如果你最后持有1000000 元以上的钱的话，就可以把这些钱带回家。请计算当你采取最优策略时，获得1000000 元以上的钱并带回家的概率。

“连续性”是本题最大的问题，由于每一轮可以压的赌注不是整数，所以有无限种可能，无法进行性递归搜索。
化连续为离散
只需检查有限种可能即可，首先考虑最后一轮赌博，以下是最优的选择之后的结果：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681987564955-d1a2ad8d-5af9-4981-b451-3f4907dc4e81.png#averageHue=%23fafafa&clientId=u8975dd8c-edc7-4&from=ui&height=214&id=uca0f9a2b&originHeight=368&originWidth=1032&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=44070&status=done&style=none&taskId=uf1e03fcd-cfdd-46f5-83a6-cc9bbe6eb1d&title=&width=600" width="600" /> </div>


由此可以推出上一轮赌博：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681987668490-da2f773c-09be-4397-a582-8a64ef986324.png#averageHue=%23fafafa&clientId=u8975dd8c-edc7-4&from=ui&height=237&id=u0ad64f57&originHeight=379&originWidth=960&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=37593&status=done&style=none&taskId=u9445b726-cc4b-449c-bbe4-480065ab4ce&title=&width=600" width="600" /> </div>


只要不断递推下去，递推到倒数第$M$轮赌博，检查一开始赌本所在区间的概率就可以得到答案。到最后只有$2^M+1$种状态。
```cpp
int M,X;
double P;

double dp[2][1<<MAX_M+1];
void solve(){
    int n=1<<M+1;       //状态的个数
    double *prv=dp[0],*nxt=dp[1];
    //初始化
    memset(prv,0,sizeof(double)*(n+1));
    prv[n]=1.0;     //在赌博结束后，只有达到最后一个状态，才能1的概率拿到奖金

    for(int r=0;r<M;++r){   //从最后一轮开始递推，到第一轮
        for(int i=0;i<=n;++i){
            int jub=min(i,n-i);     //此处取最小值原因——当i>n/2时，没必要使得i+j>n，此时不是最优策略(投入较少时一样可以拿到钱，但输的时候会输更多钱)
            double t=0.0;
            for(int j=0;j<=jub;++j){
                t=max(t,P*dp[i+j]+(1-P)*dp[i-j]);
            }
            nxt[i]=t;
        }
        swap(prv,nxt);
    }
    int i=X*n/1000000;
    printf("%.6f",prv[i]);      //最后一轮swap了，所以答案在prv中
}
```



# 中级篇
## 3.1 二分法
不断缩小解可能存在的范围，从而求得问题最优解的方法。本章讨论运用二分搜索的经典问题。
通常用二分在一个有序序列中进行查找一个特定的值，但是使用的场景不仅限于有序序列，例如假定一个节是否可行的问题，这种问题通常是，求取满足条件的区间的左右边界。
### 3.1.1 从某个数组中查找某个值

**lower bound**
给定长度为$n$的单调不下降数列$a_0,a_1,a_2,...,a_{n-1}$和一个数$k$, 求满足$a_i>=k$条件的最小的$i$。不存在的情况下输出-1。

- $1\le n \le 10^6$
- $0\le a_j\le 10^9$

该问题为二分搜索问题的最小化问题，即求满足条件的最小值问题，也就是求“右边区间的左端点”，可以将解存在的区间`[l,r)`不断压缩，直到区间中只有一个元素，即`r-l==1`。
C++ STL提供了二分搜索的函数`lower_bound`和`upper_bound`。


### 3.1.2 假定一个解并判断是否可性
:::tips
**Cable master (POJ No.1064)**
有$N$条绳子，它们的长度分别为$L_i$。如果从它们中切割出$K$条长度相同的绳子的话，这$K$条绳子每条最长能有多长？答案保留到小数点后2位。

- $1≤N≤10000$
- $1≤K≤10000$
- $1≤L_i≤100000$

本题是解最大化问题，即存在多个可行解，但求的是最大的可行解，可以对可行解的空间进行二分搜索，不断二分压缩解空间，直到找到可行解的边界。
具体来说，在本题中，初始解空间设为`(0,MAX_L]`，对该区间进行二分。判断一个`x=mid`是否满足解条件的方法是`sum(floor(Li/x))`是否大于等于`K`。
本题还是一个浮点数二分的问题，对于问题有精度要求，此时二分的结束条件不是`r-l==1`，而是用一个循环，进行特定次循环，循环的次数取决于初始区间长度和要求的精度，每循环一次区间长度减半。
```cpp
int N,K;
double L[MAX_N];

double check(double x){
    int num=0;
    for(int i=0;i<N;++i){
        num+=(int)(L[i]/x);
    }
    return num>=K;
}
void solve(){
    double lb=0,rb=MAX_L;
    for(int i=0;i<100;++i){
        double mid=(lb+rb)/2;
        if(check(mid)) 
            rb=mid;
        else
            lb=mid;
    }
    printf("%.2f",floor(rb*100)/100);
}
```
本题输出答案时，为了避免`printf`输出四舍五入得到错误结果，采用了`floor(rb*100)/100`的方式。


### 3.1.3 最大化最小值

**Aggressive cows (POJ No.2456)**
农夫约翰搭了一间有$N$间牛舍的小屋。牛舍排在一条线上，第$i$号牛舍在$x_i$的位置。但是他的$M$头牛对小屋很不满意，因此经常互相攻击。约翰为了防止牛之间互相伤害，因此决定把每头牛都放在离其他牛尽可能远的牛舍。也就是要最大化最近的两头牛之间的距离。求这样操作之后牛之间距离的下界。

- $2≤N≤100000$
- $2≤M≤N$
- $0≤x_i≤10^9$

同理对解空间进行压缩，让最小值最大化，初始搜索空间为`[0,MAX_X)`，在进行二分时，对于一个`mid`，`check`函数用于判断能否让任意两头牛之间的距离`>=mid`，用贪心实现：

- 对牛舍的位置进行排序。
- 将一头牛放入$x_0$中。
- 对于需要判断的`mid`，如果第`i`头牛放入`x[j]`中，第`i+1`头牛就要放入第一个满足`x[j]+mid<=x[k]`中。
```cpp
        int crt=last+1;
        while(crt<N&&X[cet]-X[last]<x){
            ++cet;
        }
        if(crt==N)
            return false;
        last=crt;
    }
    return true;
}
void solve(){
    sort(X,X+N);
    int l=0,r=INF;
    while(r-l>1){
        int mid=(l+r)/2;
        if(check(mid))
            l=mid;
        else
            r=mid;
    }
    printf("%d",l);
}
```


### 3.1.4 最大化平均值

**最大化平均值**
有$n$个物品的重量和价值分别是$w_i$和$v_i$，从中选出$k$个物品使得单位重量的价值最大。

- $1\le k\le n\le 10^4$
- $1\le w_i,v_i \le 10^6$
:::
用二分解决问题，在可能存在解的区间进行搜索，查找的是满足要求的区间的右边界。目前需要解决的问题是如何判断一个`x`是否满足条件，即可选出k个物品使得单位重量价值≥`x`。
问题可以转化为是否存在某个长度为`k`的结合`S`，使得：
$\sum_{i\in S}^{}{v_i/\sum_{i\in S}^{}{w_i}\ge x}$
变形得到：
$\sum_{i\in S}^{}{\left( v_i-x\times w_i \right)}\ge 0$


可以对$\left( v_i-x\times w_i \right)$进行排序，然后从大到小贪心的选取`k`个值求和进行判断。
```cpp
int n,k;
int w[MAX_N],v[MAX_N];
double y[MAX_N];//用于存单vi-xwi的值

bool check(double x){
    for(int i=0;i<n;++i){
        y[i]=v[i]-x*w[i];
    }
    sort(y,y+n);
    double sum;
    for(int i=0;i<k;++i){
        sum+=y[n-i-1];
    }
    return sum>=0;
}
void solve(){
    double l=0,r=INF;
    for(int i=0;i<100;++i){
        double mid=(l+r)/2;
        if(check(mid))
            l=mid;
        else
            r=mid;
    }
    printf("%.2f",l);
}
```



## 3.2 常用技巧

本章介绍竞赛中一些常用技巧。

### 3.2.1 尺取法
尺取法其实就滑动窗口算法，以下通过例题来巩固：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682736513331-c8688903-d9e4-47a8-9c42-645b37fd6d5e.jpeg#averageHue=%23e7e7e7&clientId=ue3c2b438-7298-4&from=ui&height=208&id=uc00945f7&originHeight=420&originWidth=1416&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=90201&status=done&style=none&taskId=ub4671b81-fc16-4c6f-9dfc-06ebf613bd3&title=&width=700" width="700" /> </div>

使用滑动窗口方法，可以采用一个map记录知识点以及出现的次数，每次滑动右窗口知道能够覆盖所有知识点，然后滑动左窗口，枚举窗口长度。
```cpp
const int MAX_P=1000001;
int P;
int a[MAX_P];
void solve(){
    //计算知识点数量
    set<int> all;
    for(int i=0;i<P;++i)
        all.insert(a[i]);
    int n=all.size();
    map<int,int> count;
    int ans=P;
    int s=0,t=0,num=0;
    for(;;){
        while(t<P&&num<n){
            if(count[a[t++]]++==0)
                ++num;
        }
        if(num<n)
            break;
        ans=min(ans,t-s);
        if(--count[a[s++]]==0)
            --num;
    }
    printf("%d\n",ans);
}
```


### 3.2.2 反转（开关问题）
反转问题的特点是对于同一个对象施加多次操作会回答原来状态，因此是无效的，但是有时不得不进行，所以需要记录对于每个状态施加操作的次数。从开头开始往下进行操作。有时“开头”的状态也有多种，需要全部枚举出来。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682738018218-763b4337-fd79-4330-9bfb-b47c210b8195.jpeg#averageHue=%23e7e7e7&clientId=ue3c2b438-7298-4&from=ui&height=205&id=u9aa41d4e&originHeight=349&originWidth=1189&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=60454&status=done&style=none&taskId=uc8913e76-1350-43bc-8a12-5c31f1e20d4&title=&width=700" width="700" /> </div>

首先考虑对于一个特定的K，求解N。交换区间的反转顺序对于结果是没有影响的，所以考虑从左边开始翻转，对于一头牛`i`，如果这头牛已经朝向前面了，就不需要进行反转，否则要对区间`[i,i+K-1]`进行反转。如果在翻转操作时直接对区间的牛进行修改，同时一开始还要枚举K，算法时间复杂度为$O(N^3)$。
用`f[i]`记录区间`[i,i+K-1]`的反转情况，`1`代表进行过翻转操作。对于牛`i`，如果$\sum_{j=i-K+1}^{i-1}{f\left[ j \right]}$为奇数，说明之前的操作使得牛`i`和原来牛的方向相反。
由于$\sum_{j=\left( i+1 \right) -K+1}^i{f\left[ j \right]}=\sum_{j=i-K+1}^{i-1}{f\left[ j \right]}+f\left[ i \right] -f\left[ i-K+1 \right]$，可以在常数时间计算出来，所以算法总的时间复杂度降为$O(N^2)$。
```cpp
const int MAX_N=50001;
int N;
int dir[MAX_N];//用于记录牛的方向，0为正向，1为反向
int f[MAX_N];
//对于枚举的每一个K，计算其N，不存在则返回-1
int cal(int K){
    memset(f,-1,sizeof(f));
    int ans=0,sum=0;//sum就是求和上面公式求和那一部分，用于判断当前牛i的方向是否和刚开始状况不同
    for(int i=0;i+K<=N;++i){
        //需要反向
        if((dir[i]+sum)%2!=0){
            ++ans;
            f[i]=1;
        }
        sum+=f[i];
        if(i-K+1>=0)
            sum-=f[i-K+1];
    }
    //以下检查后面的牛是否正向，后面的牛不能进行反转操作了
    for(int i=N-K+1;i<N;++i){
        if((dir[i]+sum)%2!=0)
            return -1;
        if(i-K+1>=0)
            sum-=f[i-K+1];
    }
    return ans;
}
void solve(){
    int K=1,M=N;
    for(int k=1;k<=N;++k){
        int m=cal(k);
        if(m>=0&&M>m){
            M=m;
            K=k;
        }
    }
    printf("%d %d\n",K,M);
}
```


<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682757448758-23863695-3962-4963-bb8f-37f0762f33e9.jpeg#averageHue=%23e5e5e5&clientId=ue3c2b438-7298-4&from=ui&height=275&id=u93ae8a6b&originHeight=465&originWidth=1185&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=108628&status=done&style=none&taskId=u1c64aa24-cf9d-4e66-b33a-0d7594b4611&title=&width=700" width="700" /> </div>

采用和上一题类似的思想，用`f[m][n]`记录`tile[m][n]`是否进行过反转操作，然后根据本身的颜色和其周围的瓷砖的`f`一起判断瓷砖的颜色。
现在问题是还能像上一题那样操作左边开始进行判断吗？显然行不通，上一题中，之后区间的翻转操作不会影响之后的翻转结果，但是在本题中会影响。所有不妨先确定第一行的翻转情况，然后从第二行开始操作，一直操作到最后一行，如果最后一行在操作之后，全为白瓷砖则这是一个有效解，第一行中有$2^N$中情况，必须进行枚举，然后选出最优解。
```cpp
const int MAX_N=16;
//邻接格子坐标
const int dx[5]={-1,0,0,0,1};
const int dy[5]={0,-1,0,1,0};
//输入
int M,N;
int tile[MAX_N][MAX_N];

int opt[MAX_N][MAX_N];//保存最优结果
int flip[MAX_N][MAX_N];//保存中间结果
//查询颜色
int get(int x,int y){
    int c=tile[x][y];
    for(int d=0;d<5;++d){
        int nx=x+dx[d],ny=y+dy[d];
        if(nx>=0 && nx<M && ny>=0 && ny<N){
            c+=flip[nx][ny];
        }
    }
    return c%2;
}
//在第一行操作确定的情况下，确定最小操作次数
int cal(){
    for(int i=1;i<M;++i){
        for(int j=0;j<N;++j){
            if(get(i-1,j)!=0){//上一行对应位置为黑色就必须反转
                flip[i][j]=1;
            }
        }
    }
    //判断最后一行情况，判断解是否有效
    for(int j=0;j<N;++j){
        if(get(M-1,j)!=0)
            return -1;
    }
    //统计反转次数
    int res=0;
    for(int i=0;i<M;++i){
        for(int j=0;j<N;++j){
            res+=flip[i][j];
        }
    }
    return res;
}
void solve(){
    int res=-1;
    int n=1<<N;
    for(int i=0;i<n;++i){
        memset(flip,0,sizeof(flip));
        for(int j=0;j<N;++j)
            flip[0][N-j-1]=i>>j&1;//i从0开始，填入从N-j-1开始填是为了字典序最小
        int num=cal();
        if(num>=0 && (res<0 || res>num)){
            res=num;
            memcpy(opt,flip,sizeof(flip));
        }
    }
    if(res<0)
        printf("IMPOSSIBLE\n");
    else{
        for(int i=0;i<M;++i){
            for(int j=0;j<N;++j){
                printf("%d%c",opt[i][j],j==N-1?'\n':' ');
            }
        }
    }
}
```


### 3.2.3 弹性碰撞

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682764956711-5d7ebfd9-e520-4d4d-90d6-cfda4b3b4a19.jpeg#averageHue=%23e8e8e8&clientId=ue3c2b438-7298-4&from=ui&height=319&id=ubde03315&originHeight=539&originWidth=1181&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=84307&status=done&style=none&taskId=u8fc9f044-6740-4e8e-bd90-aef1a66a4f1&title=&width=700" width="700" /> </div>

**首先考虑只有一个球的情况**，从高为$H$的位置下落需要花费时间$t=\sqrt{\frac{2H}{g}}$，在时刻$T$，令$k$为满足$kt\le T$的最大整数，那么：
$y=\left\{ \begin{array}{l}
	H-\frac{1}{2}g\left( T-kt \right) ^2,\ k\text{为偶数}\\
	H-\frac{1}{2}g\left( kt+t-T \right) ^2,\ k\text{为奇数}\\
\end{array} \right.$
**考虑多个球的情况**，由于球与球之间会有碰撞，如果使用物理模拟，问题很复杂，难以进行计算，先考虑$R=0$的特殊情况，此时由于小球可以视为质点，而且发生的是弹性碰撞，所以两个小球相碰时（交互速度），可以小球擦身而过（也就是两个小球进行了身份互换）。由于小球之间有碰撞，所以小球之间顺序不会改变，所以单独对每个小球进行计算高度，然后排序就可以知道每个小球的最终位置。
**现在考虑**$R>0$**的情况**，其实小球在$R>0$的情况和$R=0$（也就是质点）的情况是对应的——第$i$个球恒在其对应质点上方$i\times 2R$的位置。
```cpp
using namespace std;

const double g=10.0;
const int MAX_N=101;
int N,H,R,T;
double y[MAX_N];//球最终位置

double cal(int T){
    if(T<0) return H;
    double t=sqrt(2*H/g);
    int k=(int)(T/t);
    if(k%2==0){
        double d=T-k*t;
        return H-g*d*d/2;
    }else{
        double d=k*t+t-T;
        return H-g*d*d/2;
    }
}
void solve(){
    for(int i=0;i<N;++i){
        y[i]=cal(T-i);
    }
    sort(y,y+N);
    for(int i=0;i<N;++i){
        printf("%.2f%c",y[i]+2*R*i,i==N-1?'\n':' ');
    }
}


```


### 3.2.4 折半枚举（双向搜索）
对于一个数据量很大的问题，有时直接进行处理会超时，可以将问题拆分成两部分，对一半各自枚举，然后结合得出答案。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682768814226-4623e559-256d-4a59-b409-05f96aacdf7f.jpeg#averageHue=%23e8e8e8&clientId=ue3c2b438-7298-4&from=ui&height=178&id=u7b7379c3&originHeight=299&originWidth=1176&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=47758&status=done&style=none&taskId=u35ab9e0d-c098-4492-9147-18f88ea31ec&title=&width=700" width="700" /> </div>

如果直接枚举的话，时间复杂度为$O(n^4)$。有些问题规模较大的问题，无法枚举所有元素，可以将问题拆成两版分别枚举，再合并结果。
本题中，先枚举出数组`C`和数组`D`的所有组合到数组`CD`中，然后将结果排序，然后枚举`A`和`B`，再从`CD`中进行二分查找`-(A[i]+B[j])`的个数。此时时间复杂度为$O(n^2\times log \ n)$。
```cpp
const int MAX_N=4001;
int n;
int A[MAX_N],B[MAX_N],C[MAX_N],D[MAX_N];
int CD[MAX_N*MAX_N];
void solve(){
    for(int i=0;i<n;++i){
        for(int j=0;j<n;++j){
            CD[i*n+j]=C[i]+D[j];
        }
    }
    sort(CD,CD+n*n);

    long long ans=0;
    for(int i=0;i<n;++i){
        for(int j=0;j<n;++j){
            int cd=-A[i]-B[j];
            ans+=upper_bound(CD,CD+n*n,cd)-lower_bound(CD,CD+n*n,cd);
        }
    }
    printf("%lld\n",ans);
}
```


<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682769876120-cfa2020f-9e1c-417f-98e9-3a84ab9c5c6d.jpeg#averageHue=%23ebebeb&clientId=ue3c2b438-7298-4&from=ui&height=194&id=ub6bd1176&originHeight=328&originWidth=1181&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=34400&status=done&style=none&taskId=u6ec2a973-af43-4480-812f-d1062dfa879&title=&width=700" width="700" /> </div>

由于此处$W$和$w_i,v_i$很大，使用DP求解显然会超时，这里由于$n$较小，所以可以考虑枚举，直接枚举的的话，时间复杂度为$O(2^n)$，对于这种复杂度$n\le 25$才能不超时，所以考虑将问题拆分成两半，先枚举出前半部分的$w$和$v$，然后做些处理，在枚举后半部分时，可以用二分进行查找前面对应的$w$和$v$。
```cpp
typedef long long ll;
const int MAX_N=40;
const int INF=0x3f3f3f3f;
int n;
ll w[MAX_N],v[MAX_N];
ll W;
pair<ll,ll> ps[1<<(MAX_N/2)];
void solve(){
    //枚举前半部分的w和v
    int n2=n/2;
    for(int i=0;i<(1<<n2);++i){
        ll sw=0,sv=0;
        for(int j=0;j<n2;++j){
            if(i>>j&1){
                sw+=w[j];
                sv+=v[j];
            }
        }
        ps[i]=make_pair(sw,sv);
    }
    //对枚举结果进行处理，排序并去除多余元素，方便后面二分查找
    sort(ps,ps+(1<<n2));
    int m=1;
    for(int i=1;i<(1<<n2);++i){
        if(ps[m-1].second<ps[i].second) //排序之后，后面的pair w必然比前面的大，如果后面的v小于等于前面的就可以舍弃
            ps[m++]=ps[i];
    }
    //枚举后半部分部分
    ll res=0;
    for(int i=0;i<(1<<(n-n2));++i){
        ll sw=0,sv=0;
        for(int j=0;j<(n-n2);++j){
            if(i>>j&1){
                sw+=w[n2+j];
                sv+=v[n2+j];
            }
        }
        if(sw<=W){
            ll tv=(lower_bound(ps,ps+m,make_pair(W-sw,INF))-1)->second;
            res=max(res,sv+tv);
        }
    }
    printf("%lld\n",res);

}
```


### 3.2.5 坐标离散化

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682777956597-66c5a27b-d605-4dd9-bac8-efc4d7f777cd.jpeg#averageHue=%23e3e3e3&clientId=ue3c2b438-7298-4&from=ui&height=362&id=u50be203b&originHeight=605&originWidth=1171&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=54570&status=done&style=none&taskId=u0388bd5d-e69a-45fa-9494-4ea9a7c4617&title=&width=700" width="700" /> </div>

朴素的思想是建立$w\times h$的数组然后记录直线，最后进行搜索得到答案，但是本题$w,h$很大，没法建立这样的数组，为了能解决问题，进行坐标离散化——将前后没有变化的行和列消除并不影响区域个数。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682819516278-0fb93c14-4be2-41f2-a3e0-5e0fb82b8fbc.jpeg#averageHue=%23dfdfdf&clientId=ua3b82242-1218-4&from=ui&height=194&id=u9bcc1aa0&originHeight=340&originWidth=1049&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=32657&status=done&style=none&taskId=u4123fd3c-b3dd-45cf-993f-b185438aeb1&title=&width=600" width="600" /> </div>


数组中只需要存储有直线的行列极其前后的行列即可，此时最多使用$6n\times 6n$的数组。
```cpp
const int MAX_N=500;
//输入
int W,H,N;
int X1[MAX_N],X2[MAX_N],Y1[MAX_N],Y2[MAX_N];
const int dx[4]={1,0-1,0},dy[4]={0,1,0,-1};
bool fld[6*MAX_N][6*MAX_N];
//对坐标进行离散操作
int compress(int*x1,int*x2,int w){
    vector<int> xs;
    for(int i=0;i<N;++i){
        for(int d=-1;d<=1;++d){
            int tx1=x1[i]+d,tx2=x2[i]+d;
            if(tx1>=0 && tx1<=w) xs.push_back(tx1);//注意坐标是从1开始变化的
            if(tx2>=0 && tx2<=w) xs.push_back(tx2);
        }
    }
    sort(xs.begin(),xs.end());
    xs.erase(unique(xs.begin(),xs.end()),xs.end());//对重复元素进行删除

    for(int i=0;i<N;++i){
        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();
        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();
    }
    return xs.size();
}
void solve(){
    //坐标离散化
    W=compress(X1,X2,W);
    H=compress(Y1,Y2,H);
    //填充有直线的部分
    memset(fld,0,sizeof(fld));
    for(int i=0;i<N;++i){
        for(int y=Y1[i];y<=Y2[i];++y){
            for(int x=X1[i];x<=X2[i];++x){
                fld[y][x]=true;     //这里需要注意y和x代表的意义
            }
        }
    }
    //下面是求区域个数，由于数组范围还是较大，用dfs递归可能会让栈溢出，所以使用bfs
    int ans=0;
    for(int y=0;y<H;++y){
        for(int x=0;x<N;++x){
            if(fld[y][x]) //区域被遍历过或者为直线部分
                continue;
            ++ans;
            queue<pair<int,int>> que;
            que.push(make_pair(x,y));
            while(!que.empty()){
                int sx=que.front().first,sy=que.front().second;
                que.pop();
                for(int i=0;i<4;++i){
                    int nx=sx+dx[i],ny=sy+dy[i];
                    if(nx>=0&&nx<W&&ny>=0&&ny<H&&fld[ny][nx]==false){
                        que.push(make_pair(nx,ny));
                        fld[ny][nx]=true;
                    }
                }
            }
        }
    }
    printf("%d\n",ans);
}
```
由于区域可能还是很大，所以用递归函数dfs可能溢出，所以采用bfs进行搜索。



## 3.3 中级数据结构
### 3.3.1 线段树
**线段树概念**
线段树擅长处理区间，线段树是一颗完美二叉树。叶子节点代表一个元素，除了叶子节点的所有节点维护一个区间，子节点维护的是父节点等分之后的其中一个子区间。当有$n$个元素时，对区间的操作可以在$O(logn)$的时间内完成。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682835931752-aa8e0273-25ee-4d16-8cd3-121f4d9f85ee.jpeg#averageHue=%23f4f4f4&clientId=u36e402d6-5c9e-4&from=ui&height=197&id=u3c880ea0&originHeight=295&originWidth=897&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=28824&status=done&style=none&taskId=u2ca7e805-52a8-4ff2-b007-755e1c750b6&title=&width=600" width="600" /> </div>


根据节点中维护的数据的不同，线段树可以提供不同的功能，以下介绍实现**Rangee Minimum Query（RMQ）**操作的线段树为例。

**基于线段树的RMQ结构**
基于RMQ的线段树可以在给定数列的情况下，在$O(logn)$的时间内完成以下操作：

- 查询给定元素区间的最小值。
- 修改特定元素的值。

**基于线段树的RMQ结构的查询**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682836280193-86fb4c14-22e4-4647-8978-eba9879a9176.jpeg#averageHue=%23efefef&clientId=u36e402d6-5c9e-4&from=ui&height=221&id=u7cac16c3&originHeight=402&originWidth=1271&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=67964&status=done&style=none&taskId=u5b8f73eb-0675-497f-9fab-de4898c907c&title=&width=700" width="700" /> </div>


一开始从根节点开始查询

- 当所查询区间包含当前区间，返回节点的值。
- 当所查询区间和当前区间没有交集，返回一个不影响的值（INF）。
- 剩下的情况就是：当前区间包含了所查询区间，就对两个子节点递归处理，选取结果的较小值。

**基于线段树的RMQ的值的更新**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682836622966-3e08e289-f26e-4c2b-8638-ea2f319277fa.jpeg#averageHue=%23f4f4f4&clientId=u36e402d6-5c9e-4&from=ui&height=258&id=u92e25a74&originHeight=400&originWidth=774&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=37015&status=done&style=none&taskId=u81498a67-620e-443f-b479-0baa80c045a&title=&width=500" width="500" /> </div>


从叶子节点开始往根节点更新。

**基于线段树的RMQ的复杂度**
两种操作的复杂度为$O(log \ n)$。初始化的时间和空间复杂度为$O(n)$。因为
$\sum{n+\frac{n}{2}+\frac{n}{4}+...=n+\underset{x\rightarrow \infty}{\lim}\frac{\frac{1}{2}\left( 1-\frac{1}{2}^x \right)}{\frac{1}{2}}}=2n$，即数节点的总数为$2n$。

**基于线段数的RMQ的实现**
```cpp
const int MAX_N=1<<10;
const int INF=0x3f3f3f3f;
//存储线段树的全局数组
int n,dat[2*MAX_N-1];

//初始化
void init(int n_){
    //n_为元素数量，但是为了便于处理，将其元素个数扩大到2的幂
    n=1;
    while(n<n_)
        n*=2;
    //值初化
    for(int i=0;i<2*n-1;++i)
        dat[i]=INF;
}
//把第k（0开始）个值更新
void update(int k,int a){
    k+=n-1;
    dat[k]=a;
    while(k>0){
        k=(k-1)/2;
        dat[k]=min(dat[2*k+1],dat[2*k+2]);
    }
}
/*
查询区间[a,b)的最小值
    k为当前区间对应的节点的下标
    [l,r)为当前区间，初始为[0,n)
*/
int query(int a,int b,int k,int l,int r){
    if(r<=a || b<=l) return INF;
    if(a<=l && b>=r) return dat[k];
    else{
        int v_l=query(a,b,k*2+1,l,(l+r)/2);
        int v_r=query(a,b,k*2+2,(l+r)/2,r);
        return min(v_l,v_r);
    }
}
```

**运用线段树的问题**

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682837964207-73030a9d-48e2-4382-88f5-1367977a1050.jpeg#averageHue=%23eaeaea&clientId=u36e402d6-5c9e-4&from=ui&height=530&id=u2b1a3db3&originHeight=644&originWidth=851&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=70098&status=done&style=none&taskId=u3d02c458-50ad-4980-b109-54d935196da&title=&width=700" width="700" /> </div>

由于一条线段发生改变之后，后续所有线段都会发生改变，如果一个一个取遍历修改时间代价显然太高，观察到后续一整个区间都会发生变化，所以使用线段树对区间进行维护。
线段树中每个节点`[L,R)`保存的是一个从`L`指向`R`的向量，另外还需要保存区间两个子向量之间的角度。
```cpp
const int ST_SIZE = (1<<15)-1;
const int MAX_N = 10000;
const int MAX_C = 10000;
int N,C;
int L[MAX_N],S[MAX_C],A[MAX_N];

//线段树维护的数据
double vx[ST_SIZE],vy[ST_SIZE];//区间对应的向量
double ang[ST_SIZE]; //两个子向量的角度
//保存当前角度
double prv[MAX_N];

//初始化线段树
void init(int k,int l,int r){
    ang[k]=vx[k]=0.0;
    if(r-l==1)//叶子节点
        vy[k]=L[l];
    else{//非叶子节点
        int chl=k*2+1,chr=k*2+2;
        init(chl,l,(l+r)/2);
        init(chr,(l+r)/2,r);
        vy[k]=vy[chl]+vy[chr];
    }
}

void change(int start,double a,int v,int l,int r){
    if(start<=l || start>=r)    //当前区间内部的角度不需要改变
        return ;
    int chl=v*2+1,chr=v*2+2;
    int m=(l+r)/2;
    change(start,a,chl,l,m);
    change(start,a,chr,m,r);
    if(start<=m)
        ang[v]+=a; //区间右边所有向量角度都发生了改变

    double s=sin(ang[v]),c=cos(ang[v]);
    vx[v]=vx[chl]+(c*vx[chr]-s*vy[chr]);
    vy[v]=vy[chl]+(s*vx[chr]-c*vy[chr]);
}

void solve(){
    init(0,0,N);
    for(int i=1;i<N;++i) prv[i]=M_PI;

    for(int i=0;i<C;++i){
        int s=S[i];
        double a=A[i]/360.0*2*M_PI;
        change(s,a-prv[s],0,0,N);
        prv[s]=a;
    }
    printf("%.2f %.2f",vx[0],vy[0]);
}
```

**基于稀疏表实现的RMQ**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1683100965542-92e1dcc2-6e6c-453e-b3bf-0eac131497b3.jpeg#averageHue=%23e7e7e7&clientId=u61889068-7d7b-4&from=ui&height=219&id=uf097e88b&originHeight=323&originWidth=886&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=50408&status=done&style=none&taskId=u36900322-d659-4378-a3b0-137aba3709a&title=&width=600" width="600" /> </div>


其中$t_{i,j}$表示的是序列$a_j,a_{j+1},...a_{j+2^i}$的最小值。根据这个表求$a_x,a_{x+1},...,a_y$的最小值的步骤如下：

- 找到满足$2^i\le y-x \le 2^{i+1}$的$i$。
- 序列最小值为$min(t_{i,x}\ ,\ t_{i,y-2^i})$。如下图：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1683101250094-f2c0e808-84a1-40b3-8b1f-810f4393542b.jpeg#averageHue=%23f7f7f7&clientId=u61889068-7d7b-4&from=ui&height=168&id=ub55623ae&originHeight=290&originWidth=1038&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=26236&status=done&style=none&taskId=u85508fd4-d922-4007-9a74-b2dd803dc86&title=&width=600" width="600" /> </div>



### 3.3.2 Binary Indexed Tree
树状数组可以高效完成以下操作：对于一个数列$a_1,a_2,...,a_n$

- 给定$i$，计算$a_1+a_2+...+a_i$
- 给定$i$和$x$，执行$a_i+=x$

**基于线段树的实现**
线段树可以高效维护区间，但是当需要计算$s$到$t$的和的时候，可以用$(1到t的和)-(1到s-1的和)$。也就是说只需对于任意的$i$，能够求出从1到$i$的和即可。此时，线段树的每个节点的右子节点（记作$r$）都不需要用到了，但需要$r$的值，只需要用到其左兄弟$l$和父节点$f$的值。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1683288495439-313c1644-f304-4063-ad1c-acfebeab0329.jpeg#averageHue=%23f6f6f6&clientId=u009b89b2-99c9-4&from=ui&height=199&id=u1fb0efef&originHeight=380&originWidth=1148&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=49000&status=done&style=none&taskId=ub55e992b-cc7b-4926-a40e-47e188e8354&title=&width=600" width="600" /> </div>



**BIT的结构**
BIT维护部分和的结构如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1683288566386-b0431ed8-2559-48e2-b43e-f6c4327b0599.jpeg#averageHue=%23f8f8f8&clientId=u009b89b2-99c9-4&from=ui&height=245&id=u453671b4&originHeight=443&originWidth=1083&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=33384&status=done&style=none&taskId=ufcfd755b-42f2-4b92-8cc8-7db2a9d077c&title=&width=600" width="600" /> </div>


编号的二进制表示最右边有$k$个0，该节点维护的区间长度为$2^k$。

**BIT求和**
求和时需要不断把加上当前节点的父节点的左兄弟节点，将当前节点编号的二进制的最后一个“1”去掉就可得到目标节点。`i-=i&-i`。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1683288957241-ba4f121a-c9c1-46a6-9e1a-709ea4b71496.jpeg#averageHue=%23f6f6f6&clientId=u009b89b2-99c9-4&from=ui&height=271&id=u3dc3541d&originHeight=446&originWidth=988&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=38366&status=done&style=none&taskId=ue770af17-1a93-47d5-8fff-78d8ea86fc1&title=&width=600" width="600" /> </div>



**BIT值的更新**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1683288999355-732ab95c-e539-4da6-b366-d8c1f23a6d36.jpeg#averageHue=%23f8f8f8&clientId=u009b89b2-99c9-4&from=ui&height=249&id=ufc7d7c0d&originHeight=482&originWidth=1160&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=42771&status=done&style=none&taskId=u34c3c147-0afa-4ac1-bfb6-01c837e3cc5&title=&width=600" width="600" /> </div>



**BIT实现**
```cpp
int bit[MAX_N+1],n;//节点编号从1开始，0号单元不使用
int sum(int i){
    int s=0;
    while(i>0){
        s+=bit[i];
        i=i&(i-1);//作用和i-=i&-i一样
    }
    return s;
}

void add(int i,int x){
    while(i<=n){
        bit[i]+=x;
        i+=i&-i;
    }
}
```

**运用BIT的题目**

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1683631590434-16c90b4b-f696-4735-a7a1-1b0aa8548a1b.jpeg#averageHue=%23eaeaea&clientId=ubcbaac4b-4a41-4&from=ui&height=155&id=ud876dcea&originHeight=313&originWidth=1411&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=48591&status=done&style=none&taskId=u7dd0430b-512c-4c14-977c-a71c2580b1e&title=&width=700" width="700" /> </div>

题目起始要求的就是逆序数，遍历序列的同时，用BIT维护$\le$当前元素的元素数量，对于每一个`i`进行`ans+=si-sum(a[i])`即求得之前有多少个元素大于当前元素，并加入答案。
```cpp
int n,a[MAX_N];//输入
void solve(){
    long long ans=0;
    //此次省略BIT部分代码
    for(int i=0;i<n;++i){
        ans+=i-sum(a[i]);
        add(a[i],1);
    }
    printf("%ld",ans);
}
```


<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1683632054761-d231eef8-71db-4266-b291-aee41b06fcce.jpeg#averageHue=%23e9e9e9&clientId=ubcbaac4b-4a41-4&from=ui&height=125&id=uee378dff&originHeight=252&originWidth=1413&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=37721&status=done&style=none&taskId=u4d4405c2-b63e-48b5-9da0-d75d8af4a2a&title=&width=700" width="700" /> </div>



树状数组可以高效实现单个值的更新，无法对于区间值进行高效更新。首先考虑使用擅长处理区间的线段树解决，线段树节点维护区间的和，可以在$O(log\ n)$时间内查询区间的和，但是在进行区间更新时，需要对于相关节点的值都需要进行更新，为了高效进行更新，线段树节点多维护一个值：

- 一个值为当前区间的值。
- 另外维护一个值`k`表明当前区间所有节点都加上`x`。












