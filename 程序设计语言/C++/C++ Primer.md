<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1682560371240-b93425bf-be82-44ba-afbc-a047a4812bda.jpeg" width="500" /> </div>



# 第1章  绪论
**GUN编译器**

- 编译指令： `g++`
- 指定生成文件名：`-o` ，例如 `g++  -o   program   program.cpp`
   - 在UNIX系统生成可执行文件`program.out`，在Windows系统生成`program.exe`
- 运行可执行文件：
   - Windows系统：直接用程序名，不需要拓展名。有些情况下，即使文件在当前目录，也需要在前面加上`. \ `。
   - UNIX系统：需要加上拓展名 .`out ` 。

**初识输入输出流**
C++未定义IO语句，iostream库中包含了两个基础类型`istream`（输入流）和`ostream`（输出流），其中定义类四个IO对象：

- **`cin`**：标准输入
- **`cout`**：标准输出
- **`cerr`**：输出警告和错误信息
- **`clog`**：输出程序运行的一般性信息

输出运算符 `>>` 和输入运算符 `<<`：两个运算符箭头指向的一侧的必须是一个 ostream 对象，另一侧是要输出或输入的值。

操纵符 endl：结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。（缓冲刷新操作可以保证程序所有的输出都真正写入输出流中，而不是仅停留在内存中等待写入流）

命令空间和作用域运算符`::`：命名空间可以表面变量名字相同引起的冲突，cin、cout和end都属于命名空间std，可以使用作用域运算符指明变量所属的命名空间。

**初识类**
点运算符`.` ：左侧为一个类的对象，右侧是该类型的一个成员。
调用运算符`()`：通过调用运算符来调用一个成员函数。


---

<br/>


<br/>


<br/>


<br/>


# 第2章  变量和基本类型
## 2.1 基本内置类型
### 2.1.1 基本内置类型
基本内置类型包括算术类型和空类型。

- 算术类型：包括整型（包括字符和布尔类型）和浮点型。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1673602332582-e7eba184-105b-4d21-9da4-84f8d3f38752.png" width="700" /> </div>



   - C++仅限定其最小尺寸
   - ==一般而言，类型 float 和 double 类型分别有7和16 个有效位。==
- 带符号类型和无符号类型：
   - 整型（字符除外）都是带符号类型
   - ==字符型被分为三种：char、signed char、unsigned char==，其中表现形式只有两种：带符号和无符号，==类型char会表现为两种标准形式其中一种，具体由编译器决定==。
- 类型选择建议：
   -  当数值不可能为负数的时候，选用无符号类型。
   - 实际应用中，long和int尺寸一般相同，一般使用int执行整数运算，当超出int时，使用long long。
   - 当使用 char 表示一个不大的整数时，必须明确指明类型是 signed char 或者 unsigned char。

---

<br/>


<br/>


### 2.1.2 类型转换

- 布尔类型和算术类型：布尔类型转化为算术类型，false转化为0，true转化为1
- 带符号和无符号 赋超出范围的值：
   - ==无符号数结果为初始值对范围长度取余的结果（高位被截断）==
   - ==带符号的结果未定义==
- 含无符号类型的表达式：==算术表达式含有无符号类型时，其中整型会自动转化为无符号类型（相当于给无符号数赋值整数初始值）==

---

<br/>


<br/>


### 2.1.3 字面值常量

- **整数字面值**：由数值和符号决定
   - 十进制：带符号数，类型为int、long、long long中能够容纳数值的尺寸最小的那个，十进制字面值不会是负数，负数的字面量不包括负号，负号标志对字面值取负。
   - 八进制和十六进制：是 int、long、long long 和 他们的无符号形式中能够容纳数值的尺寸最小的那个。
- **浮点数字面值**：默认为double。
- **字符和字符串字面值**：如果两个字符串字面值位置紧邻且仅仅由空格、缩进和换行符分隔，则实际上是一个整体。
- **转义序列**：\之后可以加多个十六进制数字，但只能跟3个及以内个八进制数。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1673746157333-fd8ee2fb-d43d-4556-adf9-8b03985838c1.png" width="600" /> </div>


> 注意以上的前缀部分，中文字符串是以字符数组方式存储的，所以在给字符数组赋值时需要在字符串常量前面加上修饰的前缀

---

<br/>


<br/>


<br/>


## 2.2 变量
### 2.2.1  变量定义

- 定义：提供一个具有名字的、可供程序操作的存储空间 ==（涉及内存操作 ）==。
- 初始值：在C++中，初始化和赋值是不同的操作，初始化时创建变量时赋予一个初始值，赋值含义为把对象当前的值擦除，用一个新的值来替代。
- ==列表初始化==：一种用花括号来初始化的方式，如下图。使用列表初始化时，==如果初始值存在丢失信息的风险，编译器会报错==（如，给整型赋一个浮点初始值）。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1673746888237-82189b7e-db42-42b8-88a0-bf6bf069721b.png#averageHue=%23fcfcfc&clientId=ucc85cb48-5064-4&from=ui&height=115&id=u02f4b55f&originHeight=162&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25184&status=done&style=none&taskId=u7d18743b-2bee-4fde-b2aa-3f067cbcfd6&title=&width=598" width="598" /> </div>



- 默认初始化：当内置类型的变量定义在函数体之外，作为全局变量，且未被显式初始化时，会被默认初始化为 0。

---

<br/>


<br/>



### 2.2.2  声明和定义
C++支持==分离式编译==，允许将程序分隔为若干个文件，每个文件可被独立编译，需要有在文件间共享代码的方式。

- 声明：使得名字被程序所知，如果要声明一个变量而不定义，在变量名前加上关键字 extern ，另外任何有显式初始化的声明就成了定义。
- 定义：创建与名字关联的实体，即申请内存。
- 静态类型：C++是静态类型语言，即在编译阶段检查类型。

---

<br/>


<br/>


<br/>




## 2.3 复合类型
复合类型是指==基于其他类型定义的类型==，主要包括引用和指针。
### 2.3.1  引用
引用就是为对象起了另一个名字，内部其实通过指针实现，但是简化了指针的操作，且与指针有所不同，引用不是一个对象，只是一个对象的别名。
- 定义引用时必须把引用和初始值绑定，一旦绑定，引用无法换绑到其他对象。
- ==引用只能定义在对象上==，不能与字面值或表达式计算结果绑定。

---

<br/>


<br/>


### 2.3.2  指针

- ==指针是一个对象==，允许赋值和拷贝，可以在声明周期内先后指向不同对象，无需在定义时就赋初值。
- 空指针：C++11引入一个新的字面值nullptr表示空指针，新标准下避免使用NULL（预处理变量，值为0）。
- `void*` 指针：一种特殊指针类型，==可以存放任意对象地址==，不能直接操作 void 所指对象，因为并不清楚对象是何类型，可以进行何种操作。

---

<br/>


<br/>


<br/>



## 2.4 `const`
const限定符本质上是对变量所能做的操作做出限制。
### 2.4.1  const 对象文件内有效
当用初始化方法定义一个const对象时，编译器在编译过程中把用到该变量的地方替换为对应的值。
默认状态下，const对象仅仅在文件内有效，多个文件出现同名的const值时，相当于在不问文件定义了独立变量（不同于普通变量，对于普通全局变量，在另一个文件用关键字extern声明后即可使用）。
若要不同文件使用同一个const对象，必须将该对象设置为全局变量，且在加关键字extern，以表明非本文件独有，如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1673764377043-dcfd2d50-cea7-4823-afe8-1a86db696ce5.png#averageHue=%23f9f9f9&clientId=uf91d60cf-14bd-4&from=ui&height=76&id=ud128337d&originHeight=197&originWidth=1454&originalType=binary&ratio=1&rotation=0&showTitle=false&size=78732&status=done&style=none&taskId=u7482c472-9df8-4d26-afbd-7190199b3c1&title=&width=562" width="562" /> </div>

---

<br/>


<br/>



### 2.4.2  const 的引用
可以把引用绑定到const对象上，称为对常量的引用；==一般而言，引用类型必须与其所引用的对象类型一致==，但也有例外的情况：

- 初始化常量引用允许用任意表达式作为初始值，只要表达式结果能够转化为引用的类型：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1673768971070-67227cef-ce1b-4b80-a8a5-53b383bb590f.png#averageHue=%23fdfdfd&clientId=uf91d60cf-14bd-4&from=ui&height=46&id=u6603e73d&originHeight=69&originWidth=380&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2995&status=done&style=none&taskId=uf195e0f6-c71d-4db0-812c-01c44b3c869&title=&width=252" width="252" /> </div>


以上情况不会报错，具体实现过程==相当于申请了一个临时量const int，然后把 i 的值类型转换后存储到临时量里面，ri 绑定的对象为临时量==，这是因为有const限定，引用ri，无法对临时量进行操作，所以操作合法。
当引用不是常量时，相当于通过引用对临时量进行操作，而不是 i ，C++把这种行为归为非法，如下图：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1673769190649-e19a7412-7d0f-49ef-a36d-63094705e41a.png#averageHue=%23fdfdfd&clientId=uf91d60cf-14bd-4&from=ui&height=48&id=ua654ceb1&originHeight=84&originWidth=378&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2722&status=done&style=none&taskId=ud8f76963-c656-44f8-a98d-d210050ebad&title=&width=216" width="216" /> </div>



- const引用可以引用一个非const对象：常量引用相当于把引用所能做的操作做出了限制。

---

<br/>


<br/>


### 2.4.3  const 和指针

- **指向常量的指针**：一般而言，指针类型必须和所指内容对应，也是指向const对象的指针必须为const，但是const指针却可以指向非const对象，此时只是能够通过指针对 对象的操作有了限制。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1673770224459-5ff1bfac-723a-4e17-a08c-4b0ea5eb9a0e.png#averageHue=%23f3f3f3&clientId=uf91d60cf-14bd-4&from=ui&height=72&id=udfec648f&originHeight=183&originWidth=1367&originalType=binary&ratio=1&rotation=0&showTitle=false&size=94157&status=done&style=none&taskId=u7f227832-0f7f-4eab-be02-be9ee5afc68&title=&width=538" width="538" /> </div>



- **常量指针**：const 指针，指针本身为常量，即不能换绑所指对象，但所指对象内容可以更改

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1673770446996-125c1179-63cf-4184-a5d9-e27e61bcf9ff.png#averageHue=%23fefdfc&clientId=uf91d60cf-14bd-4&from=ui&height=63&id=udf9d8bf6&originHeight=107&originWidth=637&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9608&status=done&style=none&taskId=u25f56944-d4a2-46d4-b173-cc0128392ab&title=&width=378" width="378" /> </div>

---

<br/>


<br/>


### 2.4.4  顶层 const 和底层 const

- **顶层const**：指针本身是一个常量，更一般的顶层const能推广到任意对象，表示==对象本身为常量==；特别指出，指针可以同时是顶层const和底层const。
- **底层const**：指针==所指对象是一个常量==，同样，底层const也能推广到引用。
- 顶层 const 和底层 const 对操作影响：当进行对象拷贝复制时，顶层 const 不受影响，拷入和拷出的对象必须用相同的低层 const，或者能够进行类型转换（非 const 可以转化为 const，反之则不行）。

---

<br/>


<br/>



### 2.4.5  常量表达式和 constexpr

- **常量表达式**：值不会改变，并且在编译过程（还没运行）就能得到计算结果的表达式
- **constexpr 变量**：即**变量本身为常量**，且使用常量表达式初始化，由于常量表达式结果必须在编译时就能扣获取，所以一般使用字面值进行初始化；==当使用 constexpr 修饰指针时，仅表示指针本身为常量，（**即 constexper 修饰的是顶层 const**）==。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1676856948814-d5209e6d-444b-401c-badf-6c267397c791.png" width="463" /> </div>


---

<br/>


<br/>


<br/>



## 2.5 处理类型
### 2.5.1  类型别名
类型别名（type alias）是某种类型的同义词，定义类型别名有以下两种方法：

- typedef：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1673834677336-1c54c43a-8090-42b6-a569-b65178f08841.png#averageHue=%23f2f2f2&clientId=u06356861-4d70-4&from=ui&height=45&id=u4648dd9b&originHeight=93&originWidth=1436&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50830&status=done&style=none&taskId=u0407abae-9614-41c2-8ce9-878849bb04b&title=&width=689" width="689" /> </div>

- 别名声明：C++11规定的新方法 
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1673834825421-0cef22ec-892a-4cab-84d2-2ef8213da7b4.png#averageHue=%23f6f6f6&clientId=u06356861-4d70-4&from=ui&height=34&id=ub218379e&originHeight=67&originWidth=1097&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20639&status=done&style=none&taskId=u697c580e-38bd-4da4-af78-1e4b16c805d&title=&width=550" width="550" /> </div>


==**typedef 和 const 一起用时，要注意 const 修饰的对象**==
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1676867881151-87925af5-3d7d-4c09-a4c8-f23ff7dd565d.png" width="641" /> </div>

==**const 修饰的是类型别名之后的那部分**==，如上图中的 cstr 和 *ps 。

---

<br/>


<br/>


### 2.5.2  auto 类型说明符

- auto在同一行声明多个变量时，多个变量类型应当一致。
- ==auto 会忽略引用==，当引用作为初始值时，真正参加初始化的其实是的引用的对象，如果需要 atuo 推导出来的类型为引用，需要明确指出，如下图：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1676872758377-5e5ca1b9-e375-4688-b89c-21ff0605cfc2.png" width="500" /> </div>



- ==auto 会忽略顶层 const==，如果需要 auto 推导出来的类型是顶层 const，需要明确指出，如下图：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1676872816982-70fd60ab-bc5e-4b59-bd6c-b5b6fb6bc792.png" width="500" /> </div>

 

- ==设置一个类型为 auto 的引用时，初始值顶层 const属性保留==，如下：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1688611388636-b2a41466-e5f7-40cb-a926-7c8da83f8394.jpeg" width="600" /> </div>

---

<br/>


<br/>



### 2.5.3  decltype 类型指示符
decltype负责获得操作数的数据类型，编译器分析表达式的值，并不会计算表达式的值，当操作数为一个函数时，编译器不调用函数。
当 decltype 使用的表达式为一个**变量**：返回变量类型，包括顶层 const 和引用。

操作数为**表达式**：
- ==表达式内容为解引用时（即，`*p`），得到解引用的结果的引用类型==。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1676889637592-b3b57083-83fa-4bb4-9bef-6b9f703a080f.png" width="600" /> </div>

> 在 C++中，==`*p ` 表达式返回的是指针  p  所指向的对象的引用，而不是对象的值==。因此， `decltype (*p)  `推导出的类型是指向该对象的引用类型。 

- decltype的结果和形式密切相关，==**给变量加括号得到的结果和不加括号的结果不同**==。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1676889690700-2478cdcc-998a-429a-ada3-4aef4a7c82e8.png" width="500" /> </div>

> 在 C++中，decltype 的工作方式是通过分析表达式的类型来推导结果类型。当给变量加上括号时，编译器会将其视为一个表达式，并根据该表达式的求值结果来推导类型。
> 在 C++中，当使用 `decltype ((x))`时，括号中的表达式会被视为一个左值，因此推导结果会是引用类型。 
> 括号中的表达式 ` (x)`  被视为对变量  x  的引用，而不是对其值的拷贝。因此，`decltype ((x)) `推导出的类型是  x  的引用类型。 


---

<br/>


<br/>


<br/>



## 2.6 自定义数据结构
### 2.6.1  自定义结构体

- C++11规定，可以为数据成员提供一个类内初始值，没有提供初始值的成员被默认初始化。
> 没有定义构造函数时，必须显式声明定义类对象，才会调用默认构造函数
> 内置类型的默认初始化就是不初始化。


### 2.6.2  编写头文件

- 文投件保护符依赖于预处理变量，可用预处理变量编写防卫式声明，如下：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1676944863925-f52d4f44-6c02-4719-9533-24860fedba19.png" width="500" /> </div>

- ==预处理变量无视作用域规则==
> 预处理变量是在预处理阶段处理的，它们的==作用范围是整个编译单元==（通常是一个源文件），编译单元也就是一个源文件和该源文件引用的所有头文件。


---

<br/>


<br/>


<br/>


<br/>



# 第3章  字符串、向量和数组
## 3.1 命名空间声明

- C++库函数基本都属于命名空间std。
- ==头文件不应该使用using声明==，头文件内容会拷贝到所有引用它的文件里面去，对于某些文件包含一些额外的名字可能会造成冲突。

---

<br/>


<br/>


<br/>



## 3.2 `string`
string 表示可变长的字符序列，包含在头文件 string 中，定义在命名空间 std 里面。

### 3.2.1 定义和初始化 string 对象

- C++的string对象不同于C的字符数组，==string对象可以直接相互赋值和初始化==，string也有一些特殊的初始化方法，如下图：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1676946317653-35487c15-2d98-4ecb-bb17-a46817c2c3fb.png" width="578" /> </div>

- 利用字符串字面值初始化和给 string 赋值，string 中并不会包含空字符。

---

<br/>


<br/>



### 3.2.2 string对象的操作
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1676946464875-860db96a-3ddf-4428-bd23-b23a1e3988a4.png" width="600" /> </div>

- 直接从输入流输入`>>string` 中，==string 只读取到当个词（跳过前面空白，后面遇到空白就停止）==。
- 读取一行用 `getline（is，s）`函数。
- ==**以上两种方法读入string时，会把string原有内容覆盖**==，并非拼接在后面。
- ==`getline（）`返回的换行符会被丢弃==，string不包含换行符。
- size（）函数返回的是在string中定义的size_type类型，是一个无符号数，避免和有符号数做运算，可以使用auto和decltype推断类型。
- 字面值和string对象相加时，需要确保“+”两边至少有一个string对象。

---

<br/>


<br/>


### 3.2.3 处理string对象中单个字符

- 头文件`cctype`中定义了一系列库函数用于处理string的当个字符

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1676947619991-8b928b69-27b8-4ad1-882c-a84014f68da5.png" width="700" /> </div>



- 当使用范围for语句想要改变string对象的字符时，需要把循环变量定义为引用类型。
- 下标运算符（ [ ] ）接收的参数为string :: size_type类型的值。

---

<br/>


<br/>


<br/>



## 3.3 `vector`
vector 包含在同名头文件内，定义在命名空间 std 中，vector 表示对象的集合，其中所有对象类型相同，vector 是类模板，使用时需要指定其中对象类型。

### 3.3.1 定义和初始化vector对象
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677026922187-16ba4ad4-8448-4882-8eb7-a9d5a581835f.png" width="600" /> </div>

- 如果使用的时圆括号，提供的值是用来构造对象的，使用的是花括号时，提供的值一般是用来列表初始化对象的，但是也有例外：当提供的值不能用来给对象赋初值时，考虑是否可以构造对象，如下图：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677027147213-efa6a8a7-dee8-4814-9438-3acb9d40732e.png" width="610" /> </div>

---

<br/>


<br/>



### 3.3.2 向vector对象中添加元素

- 一般利用成员函数 push_back 向尾部添加元素。
- 范围for语句内不能含有改变其遍历序列的大小的语句。

---

<br/>


<br/>



### 3.3.3 其他vector操作
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677027631701-7006dd83-6739-4259-b0b9-bd696e271aa1.png" width="700" /> </div>

- size函数返回的是vector具体类型定义的size_type类型，例如： `vector<int>::size_type`。

---

<br/>


<br/>


<br/>


## 3.4 迭代器介绍
所有库容器都支持迭代器，但是只有少数支持下标运算，string 不属于容器，也支持迭代器。

### 3.4.1 迭代器的使用

- 有迭代器的类型都有 返回迭代器的成员函数——begin和end，begin返回指向第一个元素的迭代器，end返回最后一个元素下一个位置的迭代器。
- 迭代器的使用和指针类型，如下图：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677028221110-d7f713f7-d356-4a3b-a708-8640213d0140.png#averageHue=%23f0f0f0&clientId=u259cda99-b642-4&from=ui&height=139&id=u4545cf6d&originHeight=269&originWidth=1262&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=153677&status=done&style=none&taskId=u3142b136-b2eb-42a3-ae39-dda03384174&title=&width=652" width="700" /> </div>



- 用 iterator 和 const_iterator 表示迭代器类型，其中const_iterator只能读，不能写。
- ==begin 和 end 返回的迭代器类型由对象是否为常量决定（常量对象返回 const 的迭代器）==，C++11新标准定义了 cbegin 和 cend 函数来返回 const_iterator 类型。
- 改变vector对象容量的操作会使得迭代器失效。

---

<br/>


<br/>



### 3.4.2 迭代器运算
string和vector的迭代器提供了更多额外的运算符，显示string和vector的迭代器支持的运算符
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677029166392-4e59d1b4-7777-419b-975e-57e6e8962823.png" width="648" /> </div>



- 两个迭代器相减得到的是类型为difference_type的带符号整数。

---

<br/>


<br/>


<br/>



## 3.5 数组
### 3.5.1 定义和初始化数组

- 数组大小属于数组类型一部分，编译时应该知道维度，故==维度必须为一个常量表达式constexpr==。
- ==不允许使用auto关键字根据初始值推断数组类型==。
- 当用字符串字面值初始化字符数组时，空字符也会被拷贝进去。

---

<br/>


<br/>


### 3.5.2 指针和数组

- 指针和数组是不同的类型，但很多用到数组名字的时候，编译器会自动将其转换为指针类型，比如当用数组给一个指针赋值时，会自动转换类型，但是不能用指针类型给数组类型赋值。
- 用数组作为auto变量的推断出来的结果为指针类型，而decltype推断出数组类型。
- 数组不是类，但是可以用 iterator 头文件中的 begin（）和 end（）函数获得指针。==不能用于变长数组（即，数组在定义时，长度不是 constexper）==。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1688625903357-d14591b1-fe14-4b22-98eb-f4c00d162a59.jpeg" width="600" /> </div>

- 使用数组下标时，通常定义为 size_t 类型， size_t 是一种机器相关无符号类型，可以表示内存中任意对象的大小，定义在cstddef头文件中；两个指针相减结果为 ptrdiff_t 的标准库类型。
- 标准库类型限定使用的下标必须是无符号类型，而内置的类型无此要求。
- 当对 C 风格字符串使用类似 ` strlen（）` 的函数时，必须以空字符结尾；string 提供了一个 `c_str` 成员函数，返回字符数组，==但不保证其一直有效，当 string 变化时，之前的字符数组可能会失效==。

> ==strlen 函数不会把空字符统计在内，c_str 函数返回的字符串中带有空字符==。

- 可以使用数组初始化vector对象，如下图：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677198519101-755d7d0e-1366-4310-b137-7ac9a7af0513.png" width="450" /> </div>

---

<br/>


<br/>



### 3.5.3 多维数组

- 使用范围for语句处理多维数组时，外层控制变量要声明为引用类型，避免数组被识别为指针，==指针是不能用范围for语句遍历的==。


---

<br/>


<br/>


<br/>


<br/>



# 第4章  表达式
## 4.1 基础

- C++语言的左值和右值并不像 C 语言那么简单，在 C++语言中，一个左值表达式的求值结果是一个对象或者一个函数，（然而以常量对象为代表的左值并不能作为赋值语句左侧运算对象，即使某些表达式求值结果为对象，也不一定是左值）。当一个对象被用作右值时，用的是对象的值（内容）；被用作左值时，用的是对象的身份（在内存的位置）。


---

<br/>


<br/>


<br/>


## 4.2 运算符
### 4.2.1 逻辑与关系运算符

- 条件运算符优先级非常低，通常在与其他运算符一起使用时需要加上括号。

---

<br/>


<br/>



### 4.2.2 递增与递减运算符

- 递增与递减运算符有前置和后置版本，如果不是必须，不用后置版本，后置版本需要把原始值存储下来，对于不需要修改前的值的工作是一种浪费。
- ==后置递增运算符优先级高于解引用运算符==，`* ptr ++` 等价于 `*( ptr ++)`。
- 如果子表达式改变了某个运算符的值，另一个子表达式要使用该值，运算对象求值顺序很关键，而大多数运算符并没有规定运算对象的求值顺序，故该结果未定义，需要避免出现该情况。

---

<br/>


<br/>



### 4.2.3 `sizeof`运算符

- 对一个数组执行`sizeof（）`得到的是这个数组所占空间大小。
- 对string或vector对象使用sizeof运算符，只会返回该类型固定大小，而不包括对象的元素占用了多少空间。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677898700046-0f807119-37b8-4ff9-8f0a-730221dd7ddd.png" width="646" /> </div>

> vector 和 String 内部有一个指针，指向存放的数据，sizeof 并不能获取指针指向内存的大小。

---

<br/>


<br/>




### 4.2.4 逗号运算符
==先对左侧表达式求值==，然后将求值结果丢弃。

---

<br/>


<br/>



### 4.2.5 运算符优先级
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677921706887-edb7e422-8a2d-4fcb-bb13-330e5c1129d0.png" width="700" /> </div>

---

<br/>


<br/>


<br/>




## 4.3 类型转换
### 4.3.1 算术转换

- **整型提升**：把小整数类型转换成较大整数类型，例如：
	- 对于 bool、char、signed char、unsigned char、short、unsigned short 等，只要能把原类型所有可能的值存入 int，就提升为 int 类型，否则就提升为 unsigned int；
	- 对于较大的 char 类型，提升为 int、unsigned int、long、unsigned long、long long、unsigned long long 中能够容纳原类型所有可能的值的最小的类型。
	
> ==**整型提升发生在较小的类型（比 int 小）上面**==。

- **表达式中含有无符号数**：
   - **首先进行整型提升**，如果类型匹配就无序继续转换，如果不匹配，执行一下操作：
   - 都是有符号，或者都是无符号：小类型转换为大类型
   - 一个有符号，一个无符号：
      - 无符号类型 `>=` 带符号类型：带符号类型转化为无符号类型.
      - 无符号类型 `<` 带符号类型：
         - 无符号类型所有值都能存入带符号类型中，无符号转化为有符号类型。
         - 否则，有符号类型转换为无符号类型。

> 总而言之，自动类型转换的目的是，用一个合适的较大的类型保存变量，来使得运行可以正常进行，都是往大的方向转换。

---

<br/>


<br/>



### 4.3.2 显式转换
一个命名的强制类型转换具有以下格式：
`cast-name  <type> ( expression )`，其中`cast-name`有以下类型：
- `static_cast`：
不包含底层const可以使用。和C风格的强制类型转换一样，主要用在基本类型之间，类指针之间，的相互转换，没有运行时的检查来检验转换的安全性。

- `const_cast`：
只能改变运算对象的底层const，也就是“去const性质”。一般用于指针和引用，仍指向或引用原来的对象，但是改为非常量。

- `reinterpret_cast`：
在对象位模式提供较低层次的重新解释，在转换前后，没有数位损失（例如把`int*`转换为`char*`对象内容没有改变，只是对于对象的操作方式变了）。

- `dynamic_cast`：以上三种都是编译时完成，`dynamic_cast`是处理时才完成的。
不能用于处理基本类型的转换，其转换目标必须是指针或者引用。在进行上行转换时，和`static_cast`一样，在进行下行转换时，`dynamic_cast`具有类型检查功能，基类中必须有虚函数。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1688709193791-8b3816c8-28c2-497e-8ab1-b0ae4e123304.png" width="700" /> </div>



---

<br/>


<br/>


<br/>


<br/>




# 第5章  语句
## 5.1 跳转语句
### 5.1.1 goto语句

- ==标签标示符独立于变量或其他标识符的名字==，可==以和程序中其他实体标识符同名==。
- goto语句和控制权转向的标签==必须位于同一个函数内==。
- 向后跳过一个已经执行的定义，意味着系统将销毁该变量然后重新创建。

---

<br/>


<br/>


<br/>


## 5.2 异常处理语句
### 5.2.1 throw表达式
程序的异常检测部分采用throw表达式引发一个异常。

### 5.2.2 try语句块
和Java不同之处在于，C++try语句块没有final语句。

### 5.2.3 标准异常
C++标准库定义类一个组类型，分别定义在4个头文件中

- `exception`：定义类最通用异常类 exception，只报告异常的发生。
- `stdexcep`t：定义类几种常用异常类。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677921736542-9d9581e0-573b-47c5-bb7b-35d6d8e91d54.png" width="700" /> </div>



- `new`：定义了`bad_alloc`异常类型
- `type_info`：定义了`bad_cast`异常类型

==异常类型只定义了一个名为what的成员函数==，该函数没有参数，返回值为一个==C风格字符串，提供了一些关于异常的信息==。

```cpp
#include <iostream>
#include <exception>

int divide(int numerator, int denominator) {
    if (denominator == 0) {
        throw std::invalid_argument("Divide by zero error"); // 抛出异常
    }
    return numerator / denominator;
}

int main() {
    try {
        int result = divide(10, 0);  // 调用可能抛出异常的函数
        std::cout << "Result: " << result << std::endl;
    }
    catch (const std::exception& e) {  // 捕获异常
        std::cout << "Exception caught: " << e.what() << std::endl;
    }

    return 0;
}
```

---

<br/>


<br/>


<br/>


<br/>




# 第6章  函数
## 6.1 参数传递
### 6.1.1 const形参和实参

- 当用实参去初始化形参时，会忽略顶层cosnt，也就是说，函数参数表里面的是const形参，可以传入一个非const的实参。
- ==当进行函数重载时，要注意实参的顶层const会被忽略==。

---

<br/>


<br/>



### 6.1.2 数组形参

- ==**当参数列表的参数类型为数组时，实际传入的参数类型为指针，指针不能使用范围for语句**==。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677923251713-48986c26-3654-4668-9a92-213baa833d22.png" width="600" /> </div>



- 当传入一个数组时，通常会把数组的大小也作为参数传入，以便能够进行遍历；传入的是一个数组引用时，则不需要传入数组大小，但==此时需要在在参数列表指明了数组大小（维度是类型的一部分）==，==**传入的数组的大小必须与之对应**==。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677923582412-73748274-ab7a-4bcf-8b63-2927defef63b.png" width="600" /> </div>


<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1677923611153-f98bd10b-fe56-4ff5-a16c-d7d299a4b5f1.png" width="600" /> </div>



- 当传入一个多维数组时，第二维以及后面所有维度，都是数组类型的一部分，不能省略。

---

<br/>


<br/>



### 6.1.3 可变形参
如果函数的实参数量未知但是全部参数类型一样，可以使用`initializer_list`类型，其定义在同名头文件中，提供的操作如下： ^f0d54d
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678156292602-44fbcff3-f333-4faf-bebc-2bba2f5dc562.png" width="700" /> </div>



- `initializer_list`是类模板，需要指定类型。
- `initializer_list`中的元素是常量值，**只可读取**，不可修改。
- 调用此类函数时，**需要把所有参数用花括号括起来**。

---

<br/>


<br/>


<br/>



## 6.2 返回类型
### 6.2.1 尾置返回类型
当函数返回类型比较复杂时，可以使用尾置返回类型，使用方法如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678157052385-bda254ae-0eec-4ebb-8c14-f2a6cacd4bf1.png" width="600" /> </div>


---

<br/>


<br/>


<br/>



## 6.3 特殊用途语言特性
### 6.3.1 默认实参

- 使用默认实参函数调用：函数调用时按照位置解析，默认实参复杂填补函数调用缺少的尾部的实参（==默认实参只能集中在参数列表尾部==）。
- 默认实参声明：多次声明同一个函数也是合法的，在给定的作用域一个形参只能被赋予一次默认实参。
- 默认实参初始值：==局部变量不能作为默认实参==（当全局变量作为默认实参时，==全局变量发生改变会导致默认实参改变==；但是如果只是在函数作用域内有定义了一个和全局变量同名的局部变量，则默认实参不会发生改变）。

---

<br/>


<br/>


### 6.3.2 内联函数和constexpr函数

- 将函数定义为内联函数，相当于把函数体中的语句直接嵌入到调用函数的地方（递归函数不建议声明为内联函数），可以避免函数调用的开销。
- ==内联说明只是向编译器发出的一个请求==，并不一定就可以让函数称为内联函数。
- `constexpr`函数的返回类型必须为字面值类型，当一个函数被声明为`constexpr`函数时。它可以在编译时计算表达式的值，而不是在运行时计算，也就是编译器直接`constexpr`函数转化为其返回值。`constexpr`函数返回的并不一定为常量表达式，如下：
```cpp
constexper int func(int a){
	return a;
}
```

---

<br/>


<br/>



### 6.3.3 调试帮助

`assert`预处理宏：`assert`是一个预处理变量，定义在`cassert`头文件中，使用方法如下：
```cpp
assert(expr);
```
先对表达式求值:
- 如果 `expr` 为假，则输出信息并中止程序运行；
- `expr` 为真就什么也不做；

和预处理变量一样，宏名字在程序内必须唯一，含有头文件 `cassert` 头文件的源文件不能再定义名为 `assert` 的变量、函数或其他实体。

`NDEBUG` 预处理变量：如果定义了 `NDEBUG` 预处理变量，则 `assert` 什么也不做。

`__ _func___`是编译器定义的一个局部静态变量，存放函数名字，还有其他类似的变量，如下：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678257551888-b0e7f864-5bac-4db2-b3a3-1baa84286705.png" width="400" /> </div>


---

<br/>


<br/>


<br/>



## 6.4 函数匹配
### 6.4.1 确定候选函数和可行函数
函数匹配第一步就是选定调用对应的重载函数集，称为**候选函数**，具有两个特征:
- 与调用的函数同名
- 声明在调用点可见

第二步就是根据提供的实参，在候选函数中选出能被该组实参调用的函数，称为**可行函数**，具有两个特征：

- 形参数量与本次调用提供的实参数量相同（在函数有默认实参的情况下，实参可能偏少）。
- 每个实参类型与对应的形参类型相同，或者能转换成形参类型。

---

<br/>


<br/>



### 6.4.2 寻找最佳匹配
编译器在可行函数中，依次检测实参以确定哪个函数是**最佳匹配**，如果有且只有一个函数满足以下条件则匹配成功：

- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配
- 至少有一个实参的匹配优于其他可行函数提供的匹配

如果没有一个函数脱颖而出，则调用出错，报**二义性调用错误**。

---

<br/>


<br/>



### 6.4.3 实参类型转换
为了确定最佳匹配，编译器将实参类型到形参类型的转换划分几个等级：

- 精确匹配：
   - 类型完全相同。
   - 从数组类型或==函数类型==转换为对应==指针类型==。
   - 向实参添加或去除==顶层 const==。
- 通过 const 转换（底层 const）。
- 类型提升（例如，一些小类型会自动提升为 int）。
- 算术类型转换或指针转换。
- 类的类型转换。


---

<br/>


<br/>


<br/>


## 6.5 函数指针

- 想要声明一个函数指针，只需用指针替换函数名即可：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678259543717-5374ddbe-6ab9-42ec-b7c9-39d9504e8f2f.png" width="700" /> </div>



- 指向不同函数类型指针之间不存在转换规则。
- ==**使用typedef定义函数指针类型**==方法如下：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678259732274-92031db2-139e-47b9-acfd-0f2532e986e7.png" width="700" /> </div>




---

<br/>


<br/>


<br/>


<br/>



# 第7章  类
## 7.1 定义抽象数据类型

- `this`：成员函数通过名为this的额外隐式参数来访问调用它的那个对象，==`this`是一个常量指针==。
- `const`成员函数：==const类对象只能调用const成员函数==，当一个成员函数被声明为const时，此时隐式参数this为指向常量的指针。



### 7.1.1 构造函数

- 构造函数：构造函数不能被声明为const。
- 合成的默认构造函数：只有在没有声明任何构造函数时，编译器才会自动生成默认构造函数。默认构造函数使用默认初始化，所以类A中含有另一个类B的对象时，如果A要使用默认构造函数，该B对象必须含有默认构造函数。
- 某些类不能依赖于默认的构造函数（例如，类中包含一个其他类型的成员且这个成员没有默认构造函数，编译器无法初始化该成员）。
- 定义了其他构造函数，又想保留默认的构造函数，可以使用以下方法：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678261772432-1b7f5335-f534-4889-a4a4-623c96049613.png" width="293" /> </div>



- ==若函数在函数体内完成定义，便自动成为内联函数候选人==。
- 构造函数初始化列表：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678261976470-a4414814-a3b9-43c4-a7a9-dfc2584aa831.png" width="600" /> </div>


---

<br/>


<br/>


### 7.1.2 拷贝赋值析构

- 有些类不能使用默认的拷贝、赋值、析构函数，特别是需要分配类对象之外的资源。
- 包含 vector 或者 string 的类，拷贝、赋值和销毁的默认版本可以正常工作（因为标准库已经写好了，你也改不😂）。

---

<br/>


<br/>


<br/>



## 7.2 访问控制和封装
C++可以用 struct 或者 class 定义类，仅仅是形式上有所不同，唯一一点区别是两者的默认访问权限有所不同，当在第一个访问说明符前定义成员，成员访问权限依赖于类定义方式，==struct 默认为 public，而 class 默认为 private==。

### 7.2.1 友元
类可以允许其他类或者函数访问private成员，方法是令他们称为友元。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678262891084-e0323111-70f2-4f4d-b25f-0ba709862272.png" width="605" /> </div>


==友元声明只能出现在类的内部==，位置不限（最好在一开始或者最后集中定义），友元不受类内访问控制符的限定。

---

<br/>


<br/>


<br/>


## 7.3 类的其他特性
### 7.3.1 类成员再探

- 类可以类中自定义某种类型的别名，==用来定义类型别名的成员必须先定义后使用==（也就是在类里面，使用该类型别名的语句只能出现在 typedef 语句之后），在类外面使用类型别名需要使用作用域运算符 `::` 。
- 定义在类内部的成员函数时自动inline（成为inline候选人，具体决定权在编译器）。
- **可变数据成员**：有时需要修改一个数据成员的值，即使是在const成员函数里面，可以在该变量前面加上`mutable`关键字，表示==可以被const成员函数修改==。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678713986938-2e217bfd-7213-4e3e-8c3e-e40574e8306b.png" width="600" /> </div>


> const成员函数和普通函数的区别：
> - const成员函数是指在函数声明或定义时在函数名后加上const关键字，表示该函数不能修改类的成员变量，**也不能调用非const的成员函数**。
> - const成员函数可以被非const对象或指针调用，也可以被const对象或指针调用。而普通函数只能被非const对象或指针调用。
> - const成员函数可以重载普通函数，也就是说可以有两个同名的成员函数，一个是const的，一个不是。这样可以根据对象或指针的类型来选择合适的版本。

---

<br/>


<br/>



### 7.3.2 返回`*this`的成员函数
当函数的返回值为对象的引用时，可以将一类的对象的一系列操作连接在一条表达式中，如下
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678714933361-1e349ade-54fa-40f3-8608-6a1b6c2f6fa5.png" width="375" /> </div>


但是当返回值为对象而非引用时，情况就大不相同了，如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678715022539-e49e1cb5-784e-4ded-b923-c9dd1dc9cd7d.png" width="600" /> </div>

---

<br/>

<br/>



### 7.3.3 类类型

- 类可以像函数一样把声明和定义分开，当声明一个类但是并不定义时，这种声明成为**前向声明**，对于一个只声明但是没有定义的类，该类是一种**不完全类型**。
- 对于不完全类型，可以**定义**指向不完全类型的指针和引用，**声明**以不完全类型作为参数或返回值的函数（当然无法定义），所以一个类中的成员不能是该类自己，但是可以是指向他自己的指针或引用。

---

<br/>


<br/>



### 7.3.4 友元再探

- 除了可以定义函数作为友元，可以定义友元类：

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678715784602-c7936e71-1d87-4762-b262-b551b27f016d.png" width="564" /> </div>

- 也可以定义类中某些成员函数为友元，方法一样。
- 类之间的友元关系不存在传递性。
- 尽管重载函数名字一样，但是是不同函数，在指定一类重载函数为友元时，需要各自声明。
- 类和非成员函数的声明不是必须在他们的友元声明之前，就算在该类里面定义该函数，也需要在类外部提供相应声明才能使得函数可见，==友元声明仅仅是影响访问权限==。

---

<br/>


<br/>


<br/>



## 7.4 类的作用域

- 在类的作用域之外，普通的数据和函数成员只能拿有对象、引用或者指针使用访问运算符，对于类类型成员使用作用域运算符。
- 一个类就是一个作用域，在类的外部，成员的名字被隐藏了起来，所以在类的外部定义成员函数时，必须用类的名字和作用域运算符指明它所属的类，对于返回类型和参数也是同理。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678761528908-f196718a-cf57-43f8-b438-404b31b6c0ce.png" width="591" /> </div>


### 7.4.1 名字查找
一般的名字查找(name lookup)的过程如下：

- 在名字所在块作用域找声明语句，只考虑在名字使用之前出现的声明
- 没找到就继续查找外层作用域
- 如果在最外层用于依然没有结果，就报错

对于定义在类内部的成员函数，解析名字的方式如下：

- 首先，编译类中所有成员的**声明**。
- 直到类中所有成员可见在编译函数体。

---

<br/>


<br/>



### 7.4.2 类作用域

- ==如果在类中，成员使用了外层作用域中的代表类型的名字，则在类中不能重新定义该名字==。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678762031730-cd667149-2380-4b02-99e0-f29799836705.png" width="558" /> </div>

如果没有成员使用过则可以重新定义，==所以类型名的的定义通产放在类的开头处==。

- 成员函数定义的作用域中的名字查找：
   - 先在函数类查找名字声明
   - 然后再类中继续查找
   - 在成员函数定义之前的作用域继续查找（如果函数定义在类中，就在定义类之前的作用域查找，如果函数定义在类外面，还有考虑函数定义之前的作用域的声明）
- 当我们需要的是外层作用域中的名字，可以使用作用域运算符来指明；当用的类中的名字，可以使用this或者类型加作用域运算符指明

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678762540434-4057d604-800c-42c4-9855-3db7d98d42de.png" width="627" /> </div>

---

<br/>


<br/>


<br/>




## 7.5 构造函数再探
###  7.5.1 构造函数初始值列表

- 如果没有在构造函数的初始值列表中显式初始化成员，该成员将在构造函数体执行之前执行默认初始化。
> 以上默认初始化并不是给变量赋初值
> 内置类型的成员变量如果在全局作用域或者类外定义，会被初始化为0；如果在局部作用域或者类内定义，会被初始化为未定义的值。类类型的成员变量会调用其默认构造函数进行初始化

- 有些时候必须设置初始化列表，为成员执行初始化，例如，成员为const或者引用，成员是类类型且没有默认构造函数。
- ==构造函数初始化列表的初始化顺序，和他们在类定义的出现顺序一致==。

---

<br/>


<br/>



### 7.5.2 委托构造函数
委托构造函数就是使用其他构造函数执行初始化过程，使用方式如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678864617110-5e84ce7e-6ce9-42c6-b587-fd76a9d8e8ca.png" width="600" /> </div>


先执行被委托函数的函数体，之后再将控制权交回委托者的函数体。

---

<br/>


<br/>



### 7.5.3 默认构造函数作用
==合成构造函数[参考文章](https://www.cnblogs.com/QG-whz/p/4676481.html)。==（文章写得很好，👍）

合成的默认构造函数只有在被需要时才会被合成，而且不会初始化基本类型的变量。

---

<br/>


<br/>



### 7.5.4 隐式类类型转换

- ==如果构造函数只接受**一个实参**，那么就定义了此类类型的隐式转换规则==，例如，Sales_data类中有接受一个string参数的构造函数，那么在需要用到Sales_data类就可用string进行替代。
- 只允许一步的类型转换。
- 可以在构造函数声明时，使用`explict`关键字抑制隐式类型转换，`explict`只对**只有一个参数的构造函数**有效，只能在类声明构造函数时使用`explict`。
- 在使用`explict`关键字后，可以使用该构造函数进行显式转换。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1678868897616-7d7c8e00-a89b-46d2-b74a-9221b96323c5.png" width="700" /> </div>

---

<br/>


<br/>



### 7.5.5 聚合类
> 聚合类的意义在于简化数据结构的定义和初始化，提高代码可读性和效率

聚合类使得用户可以直接访问其成员，具有特殊初始化语法，聚合类需要满足以下条件：

- 所有成员都是public的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类、virtual函数

可以用花括号括起来的成员初始值列表，并用它初始化聚合类数据成员，==初始值的顺序必须和声明的顺序一致==，如果提供的初始值少于数据成员，==靠后的成员被值初始化==。

```cpp
// 聚合类
struct  MyClass {
    int a;
    int b;
    int c;
};
int main() {
    
    MyClass myClass{1, 2};
    cout<<myClass.a<<endl;  //1
    cout<<myClass.b<<endl;  //2
    cout<<myClass.c<<endl;  //0，值初始化
    return 0;
}
```

---

<br/>


<br/>



### 7.5.6 字面值常量类
> 字面值类型：
> - 可以用字面值常量表示，例如int, double, bool等
> - 特点是它们的值在编译时就确定，不会在运行时改变
> - 可以用于定义常量表达式，constexpr函数，用户自定义字面量等
> 
非字面值类型：
> - 一种不能用字面值常量表示的类型，例如类(class)类型，动态数组，std::string等
> - 特点是它们的值在运行时才确定，可能会在运行时改变
> - 不能用于定义常量表达式，constexpr函数，用户自定义字面量等

数据成员都是字面值类型的聚合类是字面值常量类；如果不是聚合类，但是满足以下条件也是一个字面值常量类

- 数据成员都是字面值类型
- 至少含有一个constexper构造函数
- 如果数据成员有类内初始值，其必须是常量表达式；如果成员属于某种类型，初始值必须使用成员自己的constexper构造函数
- 必须使用默认的析构函数

---

<br/>


<br/>


<br/>



## 7.6 类的静态成员
用关键字static声明静态成员，静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据
静态成员函数不和任何对象绑定，不包含this指针，不能声明为const
> C++类的静态成员函数为什么不能是const的原因是：
> - const修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针的类成员函数，函数调用方式为thiscall。
> - 而类中的static函数本质上是全局函数，调用规约是cdecl或stdcall，它们不需要this指针，也不访问非静态数据成员。

使用作用域运算符直接访问静态成员，虽然静态成员不属于任何一个对象，但是也可以通过类的对象、引用、指针访问静态成员。

==当在类的外部定义静态成员是不能使用 static 关键字（只在类内部声明时使用）。==

---

<br/>


<br/>


<br/>


<br/>




# 第8章   IO 库

C++语言不直接处理输入、输出流，而是通过一族定义在标准库中的类型来处理 IO。

## 8.1   IO 类
IO类型分别定义在三个头文件里面——`iostream`定义用于读写流的基本类型，`fstram`定义读写命令文件的类型，`sstream`定义读写内存string对象的类型；具体类型如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679119381728-20cd0201-1bdb-45b2-bbbb-80fc1633f440.png" width="600" /> </div>


标准库定义了一组操纵wchar_t类型的类型，宽字符版本类型和函数以w开头。
设备类型和字符大小都不会影响要执行的IO操作，标准库使得我们能够忽略不同类型的流之间的关系。

### 8.1.1 IO对象无拷贝或赋值
==IO 类型对象之间不能拷贝或者赋值==，因此不能将函数形参或者返回类型设置为流类型，进行 IO 操作的函数通常以引用的方式传递和返回流。
> C++的IO对象不能拷贝和赋值的原因是：
> - C++的IO对象包含了一些不可共享的资源，例如缓冲区、文件描述符等，如果允许拷贝和赋值，就会导致资源的重复释放或者状态的不一致。
> - C++的IO对象设计为支持继承和多态，如果允许拷贝和赋值，就会破坏对象的动态类型信息，造成运行时错误。例如，如果一个基类指针指向一个派生类对象，然后将这个指针赋值给另一个基类指针（C++支持多继承），那么原来的派生类对象就会被切割（slicing），只保留基类部分，从而丢失了多态性。

==读写一个IO对象会改变其状态==，传递和返回的IO对象引用引用不能是const。
> 读写一个IO对象时，如果发生错误或异常，就会置位相应的状态位，从而影响流对象的条件。

---

<br/>


<br/>



### 8.1.2 条件状态
IO操作一个不能避免的问题是可能会发生错误，IO类定义了一些函数和标识来访问和操纵流的条件状态：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679121841764-96af25a3-b9a4-4682-a844-00fe66d7a7c8.png" width="700" /> </div>


一个流一旦发生错误，后续的所有IO操作都会失败。

- 查询流的状态：`iostate`是机器无关类型，作为位集合来使用（其中某些二进制位标识某种状态），==**IO库定义了4个`iostate`类型的`constexpr`值，如上图，可以用使用位运算来检测或设置多个标识位。**==
- 管理流的状态：用`rdestate`读出条件状态，然后和几个常量进行位运算得到所需的状态，利用`clear`来复位，或`setstate`来置位。

---

<br/>


<br/>



### 8.1.3 管理输出缓冲
**每个输出流都管理一个缓冲区**，用来保存程序读写的数据，有了缓冲区，操作系统可以将程序多个输出组合成单一的系统级写操作。
**导致缓冲刷新（数据真正写出输出设备或文件）的原因**：

- 程序正常结束
- 缓存区满
- `endl`等操纵符显式刷新缓冲区
- 用操纵符`unitbuf`设置流内部状态
- 一个流被关联到其他流

除了`endl`以外还有两个类似操纵符`flush`和`ends`，区别在于是否在缓冲区插入字符：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679307142225-33ea040c-782d-4a45-a2d2-69d584af3fff.png" width="600" /> </div>


==应当注意空字符是`'\0'`，而不是空格。==


==`unitbuf`操纵符设置流每次写操作都进行一次`flush`，用`nounitbuf`重置：==
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679307311478-69b78cfb-a3b8-4024-8bb7-573d44df1f4a.png" width="600" /> </div>


> 如果程序崩溃，输出缓冲区不会被刷新，输出的数据很可能停留在输出缓冲区中。
> 
> ==当一个输入流关联到输出流时，从输入流读取数据 会导致输出流缓冲区先刷新。==
> 
> cin、cerr和cout默认关联，也就是当读取cin或写入cerr时，会先刷新cout。



使用函数tie来关联流，tie有两个重载版本：

- ` tie（）`：返回关联到的输出流的指针，否则返回空指针
- `tie（ostream* ）`：关联到该**输出流**

每个流最多可以同时关联到一个流，但能被多个流同时关联。

---

<br/>


<br/>


<br/>



## 8.2 文件输入输出
头文件fstream中定义了三个类型支持文件IO：`ifstream`从文件中读取数据，`ofstream`向文件写入数据，`fstream`可写可读。
以下是`fstream`中对象特有的操作：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679484684730-94679792-c942-44cc-915c-f3c47a4e4653.png" width="700" /> </div>



### 8.2.1 使用文件流对象
在要求使用基类对象的地方，可以使用继承对象来进行替代，也就是在接受`iostream`引用或指针的地方可以用`fstream`或`sstream`引用或指针代替。

当一个`fstream`对象离开作用域时，与之相联的文件会自动关闭，当一个`fstream`对象被销毁时，自动调用`close`。

---

<br/>


<br/>



### 8.2.2 文件模式
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679484970765-bc7ff062-937a-4837-804d-28e4a9e678f4.png" width="700" /> </div>


指定的文件模式有以下限制：

- 只可以对 `ifstream` `fstream` 设定 `in`。
- 只可以对 `ofstream` `fstream` 设定 `out`。
- 只有当`out`可以被设置时，才可以设置`trunc`。
- 只有在`trunc`没被设置时，才可以设置`app`。
- 默认模式下，即使没有设置 `trunc`，`out` 模式也会把文件截断，为了保留文件内容，可以设置为 `app`。

> 截断模式（trunc）是指在打开文件时，如果文件已经存在，则将其内容截断为空。也就是说，如果文件已经存在，打开时会清空文件的内容，==将其大小截断为0字节==。

`ifstream`默认以`in`模式打开，`ofstream`默认以`out`模式打开，`fstream`默认以`in`和`out`模式打开。

每次打开新的文件，都要设置新的文件模式（之前设置的模式不能延续）。

---

<br/>


<br/>


<br/>



## 8.3 string流
头文件`sstream`中定义了三个类型支持文件IO：`istringstream`从string中读取数据，`ostringstream`向`string`写入数据，`stringstream`可写可读。
以下为`stringstream`特有的操作：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679486144838-ffa15e3d-f716-46c7-a539-b33cc6e5f864.png" width="700" /> </div>

`stringstream` 可以将不同类型的数据转换为字符串，并将字符串转换为不同类型的数据。它非常有用，特别是在需要将数据从字符串形式解析为特定类型的值，或者将值以字符串形式存储时。

```cpp
#include <iostream>
#include <sstream>
#include <string>

int main() {
    std::stringstream ss;

    int num = 42;
    double pi = 3.14159;
    std::string name = "John Doe";

    ss << num << ", " << pi << ", " << name;

    std::string output = ss.str();
    std::cout << output << std::endl;

    int parsedNum;
    double parsedPi;
    std::string parsedName;

    // 使用逗号作为分隔符解析数据
    ss >> parsedNum;
    ss.ignore(); // 忽略逗号
    ss >> parsedPi;
    ss.ignore(); // 忽略逗号
    ss >> parsedName;

    std::cout << "Parsed Number: " << parsedNum << ", Parsed Pi: " << parsedPi << ", Parsed Name: " << parsedName << std::endl;

    return 0;
}
```

---

<br/>



<br/>


<br/>


<br/>



# 第9章  顺序容器
## 9.1 概述
### 9.1.1 不同的容器特点
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681888683372-7e80ad32-e57e-497e-94b1-4d5d32b39772.png" width="700" /> </div>

---

<br/>


<br/>


### 9.1.2 forward_list和array
是C++11新增的类型

- 与内置数组相比，`array`更安全，并且==可以拷贝赋值==。
- ==`forward_list`的设计目标是达到与最好的手写单链表结构性能相当，故没有`size`==。

新标准库的容器比旧版本块很多，现代C++应该使用标准库容器。

---

<br/>


<br/>



### 9.1.3 选择容器的基本准则

- 除非有其他理由，尽量选用`vector`。
- 要保存很多较小的元素，不要使用`list`等容器。
- 只在头尾增删元素，用`deque`。
- 既要随机插入又要随机访问，根据情况权衡。


---

<br/>


<br/>


<br/>



## 9.2 容器库概览
### 9.2.1 迭代器
==`forward_list`的迭代不能执行递减操作。==
`list`类的容器的迭代器都不能进行大小`>，<`比较。

---

<br/>


<br/>



### 9.2.2 容器类型成员
每个==容器都定义几种类型（类型别名）这些类型别名在泛型编程中非常有用==：

- `size_type`：容器大小的类型。
- `interator`和`const_interator`
- `value_type`：元素类型。
- `reference` 和 `const_reference`：元素类型引用。

---

<br/>


<br/>



### 9.2.3 `begin`和`end`成员
`begin`和`end`有重载版本，`c`开头表示是`const`迭代器，带`r`表示反向迭代器。

不以 `c` 开头的函数都是被重载过的。也就是有两个版本——一个 `非const` 用于非常量对象的调用，一个 `const` 用于常量对象的调用。故调用这些有重载的函数时，返回值和对象的类型有关。

---

<br/>


<br/>



### 9.2.4 容器定义和初始化
每个容器都定义了一个默认构造函数，（array除外）默认构造函数创建一个空容器。
**容器初始化为另一个容器的拷贝**

- 直接拷贝整个容器：两个容器的类型及其元素必须一样。
`C c1(c2) ;`或者` C c1=c2;`

- 使用迭代器指定拷贝一个范围：==此时无须容器类型相同，元素类型可以进行转化即可==。
`C c(c1.begin(),c1.end());`

**列表初始化**
当使用列表初始化时，对于除了array之外的容器类型，其隐含指定了容器大小（即列表的长度）。

**与顺序容器大小相关的构造函数**
顺序容器（array除外）还提供了另一个构造函数——接受一个容器大小和可选的元素初始值。
当元素类型是内置类型或者具有默认构造函数的类类型时，可不提供元素初始值，否则必须显示提供元素初始值。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679657774156-ef6d3520-8e3f-4f35-918f-f80ef33de226.png" width="600" /> </div>



**固定长度的**`array`
大小是`array`类型的一部分，定义一个`array`是需要指定元素类型和容器大小，如下：
``` cpp
array<int,42>
```
array使用默认初始化时是非空的，大小就是指定的大小，元素被默认初始化（如果是类类型，必须具有默认构造函数）。
当使用列表对array初始化时，列表大小必须小于等于array的大小，剩余元素进行值初始化。`array`可以进行拷贝或对象赋值操作。

---

<br/>


<br/>



### 9.2.5 赋值和swap
`array`**的特殊情况**
`array`允许赋值，`=`两边必须具有相同的类型。
由于右侧运算对象大小可能与左侧运算对象的大小不一样，`array`不支持`assign`，也不允许使用列表进行赋值（只能初始化时使用）。

**`=` 和 `assign`**
==两种方式都是赋值，都是将用右边的值的拷贝替换掉左边容器中**所有元素**==。可以看作是重新初始化。
`=` 要求左右两边的运算对象类型相同，==`assign` 则可用不同但是相容的类型，不能用于关联容器和 `array`==。使用方法如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679655001342-d7ac54e7-3e3a-48d3-8485-43284e2f9e32.png" width="600" /> </div>



`swap`**操作**
`swap`用于==交换两个**相同类型容器**的内容==。（array除外）==`swap`只是交换容器内部数据结构==，元素本身并没有被交换。
元素本身没有被移动，所以指向容器的迭代器、引用和指针在swap操作之后不会失效，但是所指元素所属的对象已经不同。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679655386924-ec355dec-0c1f-44de-aaec-443be868fd54.png" width="600" /> </div>


> 其他顺序容器使用的是迭代器来访问元素，而迭代器本质上是一个指针，指向容器中的某个元素。当两个容器进行swap时，它们所存储的指针并没有发生改变，只是指向了另一个容器中的元素。
> array使用的是数组来存储元素，数组名本身就代表了数组首地址，所以在swap时可以直接交换两个数组名所代表的内存空间。

---

<br/>


<br/>



### 9.2.6 容器大小操作

- `size`：容器中元素的数量。
- `empty`
- `max_size`：返回一个大于或等于该类型容器所能容纳的最大元素数量。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1679656763836-2a9e1f76-a509-4c2f-b071-871b9e139d1e.png" width="600" /> </div>

---

<br/>


<br/>



### 9.2.7 关系运算符
对于容器类型而言，关系运算符左右两边必须是相同类型的容器。比较两个容器实际上按字典序比较。

- 两个容器大小相等，对应元素也相等，则容器相等。
- 容器大小不同，且较小容器每一个元素都等于对应元素，则较小容器小于较大容器。
- 否则，比价结果取决于第一个不相等元素比较结果。

---

<br/>


<br/>


<br/>



## 9.3 顺序容器操作
### 9.3.1 添加元素
**以下操作皆不适用于array**
`push_bac`
除了forward_list，其他顺序容器（包括string）都支持push_back。

`push_front`
list、forward_list、deque支持push_front操作。

`insert`
用于在特定位置插入元素，除了forward_list有特殊版本的插入函数，其他顺序容器都支持insert。
- 第一个参数——是指定插入位置的迭代器，元素将插入==指定迭代器之前==。
- 其他参数——可以是一个元素；也可以是数字+元素，表示插入多个同样的原始；还可以是用迭代器表示范围元素插入（迭代器不能是执行插入元素的）。
- 返回值——返回==第一个新加入元素的迭代器==。

`emplace`
新标准引入了三个新成员——emplace_front  emplace  emplace_back分别对应push和insert版本的函数。
emplace的不同之处在于——其接受的参数传递给元素的构造函数，然后将构造出来的元素插入容器。

---

<br/>


<br/>



### 9.3.2 访问元素
所有顺序容器（还有string）都支持 front 成员，除了 forward_list 的所有顺序容器也支持 back 成员，两个成员分别返回第一个和最后一个元素的引用。

**随机访问操作**
除了list类的容器，其他顺序容器（包括string）支持随机访问；如果希望确保下标是合法的，可以使用at成员函数，==at成员类似下标运算符，但是如果下标越界会抛出out_of_range异常。==

上述的访问元素的方式返回的都是引用，当使用 auto 且希望修改元素时，需要将变量标记为引用类型。

---

<br/>


<br/>




### 9.3.3 删除元素
`pop_front`**和**`pop_back`
vector和string不支持pop_front，forward_list不支持pop_back；两个函数都是返回void，如果需要被删除元素的值，在需要提前访问。

**删除内部元素**
使用`erase`函数：

- 第一个版本是接受一个迭代器指向被删除元素，然后返回被删除元素之后那个元素的迭代器
- 第二个版本接受两个迭代器，删除范围元素（被删元素不包括第二个迭代器指向的元素）

两个重载版本的==返回值都是最后删除元素之后那一个元素迭代器==。

==删除所有元素使用`clear`成员函数。==

---

<br/>


<br/>



### 9.3.4 特殊的`forward_list`操作
`forward_list` 用单链表实现，单链表特点是寻找后继容易，寻找前驱难，而之前的有些插入和删除操作（`insert emplace erase`），是在指定迭代器之前插入或返回值是被删除元素之前那个迭代器，所以 `forward_list` 不支持这些操作。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680000469298-413a4009-564b-417f-9f6a-d8617f8142df.png" width="600" /> </div>


`forward_list`定义了`insert_after`、`emplace_after`、`erase_after`以及一些特殊返回迭代器的函数，如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680000853385-30cf8ab9-3573-4200-aba1-1291d9eb7d90.png" width="700" /> </div>

---

<br/>


<br/>



### 9.3.5 改变容器大小
除了`array`以外的容器可以使用`resize`改变大小：

- 要求的`size`小于当前的`size`，==后面多余的元素会被删除==，当要求的`size`大于当前的`size`，把新元素添加到容器后面。
- 如果要求的 `size` 大于当前的 `size`，且没有提供初始值，则元素 值初始化，类类型必须有默认构造函数。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680050252677-58afaf30-7d5b-4ed9-8117-4847688e537a.png" width="700" /> </div>


`string`**执行**`resize`**的特殊情况：**
> 在C++中，当string执行resize操作且要求的大小大于原来的大小时，string会将新的空间填充为未定义的字符，而不是空字符。
> 如果想要将新的空间填充为空字符，可以使用以下代码：`str.resize(n, ' ')`。这将把新的空间填充为空字符。

---

<br/>


<br/>



### 9.3.6 容器操作使迭代器失效
向容器添加、删除元素可能会使指向容器元素的指针、引用和迭代器失效。

向容器添加元素时：

- vector和string：当存储空间背重新分配时，指向容器的迭代器、指针和引用都失效；存储空间没有重新分配时，插入元素之前的迭代器、引用和指针仍有效。
- deque：插入首尾位置，迭代器会失效，但引用和指针仍有效，插入其他位置皆失效。
- list和forward_list：全部都有效。

在容器删除元素时：

- list和forward_list：全部都有效
- vector和string：被删元素之前的迭代器、引用和指针仍有效
- deque：删除尾元素，尾后迭代器失效；删除除了首尾以外其他位置，全部失效

不要保存end返回的迭代器
当对vector、string和deque某些位置增删元素时，end返回的迭代器会失效，此时需要不断更新获取尾后迭代器


---

<br/>


<br/>


<br/>



## 9.4 容器如何增长
vector和string为了支持快速随机访问，元素紧挨在在一起存放，为了避免空间增长频繁复制元素，标准库采取的策略是——当不得不分配空间时，通常会分配比行的空间需求更大的内存空间。

**管理容量的成员函数**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680052021117-20c40510-a47d-4699-b7c1-e69ef1e3bb4b.png" width="700" /> </div>


`reserve`
- 当要求的空间需求小于等于当前容量，在什么也不做。
- 当大于当前容量时，至少分配和需求一样大的内存空间（可能会更大），`reserve`用于改变容器的`capacity`而不是`size`。


`shrink_to_fit`
- 函数用于退回多余的内存空间，具体的实现可以忽略此请求。

`capacity`

- 用于查询当前容器内存空间能容纳多少元素，与size函数关系如下。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680052243796-2928cd27-25ad-4486-99e3-56a9eef95f65.png" width="500" /> </div>

---


<br/>


<br/>


<br/>




## 9.5 额外的string操作
string 定义了大量操作，本章节不需要精读，仅仅需要浏览一遍，清楚 string 支持哪些操作在，需用用到时，再进行查阅。

### 9.5.1 构造string其他方法
**从`const char*`创建`string`**
如果是完全拷贝（即没有指定拷贝长度），字符序列需要以空字符结尾，当指定了拷贝长度（小于等于序列长度），则不需要以空字符结尾。
当字符存放在vector<char>中时，可以使用vector的data（）函数返回指向内存中数组第一个元素的指针，这样就跟字符数组一样了。

**从string创建string**
需要定义要拷贝的string，和开始拷贝的起始位置，和一个可选的参数——拷贝长度，如果不指定拷贝长度，就从指定位置开始拷贝直到结束。

**substr操作**
string调用substr返回一个string，该函数包括可选的开始位置和拷贝长度。

---

<br/>


<br/>



### 9.5.2 改变 string 其他方法
**接受下标的insert和erase**
string中额外提供了insert和erase接受下标的版本。

**接受C风格字符串的insert和assign**
把一个以空字符结尾的C风格字符串insert或assign给string。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680577637194-3252aa83-ad75-472a-be08-30fcaa21a958.png" width="600" /> </div>


要求赋值的字符数小于等于cp指向数组的字符数（不包括结尾空字符，否则会把空字符也赋值进去string，cout 对 string 输出时，会过滤掉空字符，但是空字符依然占据string空间，string和C风格字符串不一样不需要空字符标记结尾）。

**append和replace函数**
string额外提供了两个函数，append是在string末尾进行插入操作的简写形式。
replace 是 erase 和 insert 合操作的简写，需要指定开始位置（下标）或起始值迭代器，要删除的长度（或终止迭代器），要插入的字符串。

---

<br/>


<br/>



### 9.5.3 string搜索操作
==**npos成员**==
对于搜索操作，成功则返回匹配位置下标，失败则放回 npos，npos 为 static 成员，初始化为值-1。

**find函数**
完成最简单搜索，查找指定字符串，找到则返回第一个匹配位置下标；该函数内部是朴素算法实现的
可以传递一个可选的位置参数，表示从哪里开始进行查找。

**find_first_not_of**
用于搜索string中第一个不在参数指定范围字符集合的字符的位置，可以接受一个可选的参数指出从什位置开始搜索。
类似的函数还有find_first_of、find_last_of、find_last_not_of。

**逆向搜索**
标准库还提供了从右往左搜索的函数——rfind。

---

<br/>


<br/>



### 9.5.4 compare函数
除了关系运算符，string还提供了一组compare函数，根据s是等于、大于还是小于指定的字符串，返回0、正数还是负数
调用方式为 `s.compare( 参数 `)，==参数可以指定用于比较的 string 或字符数组，还可以指定从哪个位置开始比较。==
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680586440658-a382ccdd-ef09-4e64-ae2c-8d91e092b48e.png" width="700" /> </div>

---

<br/>


<br/>



### 9.5.5 数值转换
**数值——>字符串**
使用`to_string`函数

**字符串——>数值**
string转换为数值时，使用目标特定数值类型的函数
- string 参数的第一个非空白字符必须是符号`+ -`或者数字
- 可以`0x`或`0X`开头表示16进制，此时必须将参数b设置为16。
- 对于转化成浮点数的string，可以以` . `开头，也包含`e`或`E`表示指数部分。
- 对于转化成整型的函数可以根据基数的不同包含字母字符（用来表示大于9的数字），需要设置好对应基数。

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680587305632-c501c59d-44fa-46d8-a957-cf3bcb8061b5.png" width="700" /> </div>


---

<br/>


<br/>


<br/>



## 9.6 容器适配器
适配器（adaptor）是一种机制，能够使得某种事物的行为看起来像另一种事物一样；容器适配器接受一个顺序容器，并使其行为看起来像另一种类型。
标准库定义了三个容器适配器——`stack`、`queue`、`priority_queue`，其内部使用之前介绍过的顺序容器实现的，此时对于一个容器适配器对象，只能使用适配器支持的操作，不能使用内部实现的顺序容器类型的操作。

### 9.6.1 所有容器适配器都支持的操作和类型
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680678872674-0786fc3b-4776-483a-a748-c36f7517e222.png" width="700" /> </div>



### 9.6.2 定义适配器

- 直接定义，此时使用适配器的默认实现类型，stcak和queue默认基于deque，priority_queue基于vector
- 规定内部实现类型，需要额外的参数

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680679136499-cc42b859-bf75-46bf-80a4-d9c1f3fac769.png" width="600" /> </div>


---

<br/>


<br/>



### 9.6.3 适配器内部实现类型
对于给定的适配器，可以使用哪些容器实现是有限制的：

- 首先不能使用array和forward_list，所有适配器都要求容器具有添加、删除以及访问尾元素的能力。
- stack只要求push_back和pop_back，可使用任一顺序容器实现，除了以上两个容器。
- queue要求back、push_back、front、push_front，可使用list或deque。
- priority_queue要求front、push_back、pop_back，随机访问，可使用deque和vector。

---

<br/>


<br/>



### 9.6.4 栈适配器的操作
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680679731017-7e81805b-fa2b-4ab8-a3e9-167c6d25e124.png" width="700" /> </div>

---

<br/>


<br/>



### 9.6.5 队列适配器操作
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1680679914887-7f15ec9e-6dca-4265-b756-8089b8721e1d.png" width="700" /> </div>


---

<br/>


<br/>


<br/>


<br/>




# 第10章 泛型算法
C++提供了一组算法，适用于大多数独立于任何特定的容器，是通用的，所以是泛型 generic 的。

## 10.1 概述
大多数算法定义在头文件`algorithm`中，标准库还在头文件`numeric`中定义了一组数值泛型算法。一般情况这些算法并不是直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。

迭代器让算法不依赖于容器，直接对迭代器解引用即可访问元素，但是依赖于元素类型的操作，大多数算法都使用了在元素类型上的操作（比如重载的比较运算符），同时大多数算法允许使用自定义的操作来代替默认运算符。

算法运行与迭代器之上而不会执行容器操作，所以算法不会改变底层容器大小，只会改变容器中元素保存的值，也可能在容器内移动元素，但是不会直接添加或删除元素。

---

<br/>


<br/>


<br/>



## 10.2 初识泛型算法

### 10.2.1 只读算法

`accumulate`
定义在头文件`numeric`中，使用方法：
```cpp
accumulate (vec.begin (), vec.end (), 0);
```
`0`表示初始值，也指明了返回值的类型。
函数在迭代器或者指针指定的范围内，对其中元素进行`+`运算，==所以元素类型必须定义了或重载了`+`运算符==。

<br/>


`equal`
用于确定两个序列保存的值是否相同，使用方法：
```cpp
equal (roster 1.cbegin (), roster 2.cend (), roster 2.begin ());
```
由于利用迭代器进行操作，函数可以比较两个不同类型的容器的元素，==元素类型也不必相同，只要能利用`==`运算符进行比较==。
> 可以用 `==` 比较`string`和`const char*`，因为`string`重载了 `==` 运算符，但是对两个`char*`用`==`进行比较，比较的是指针的值。


---

<br/>


<br/>



### 10.2.2 写容器元素算法

`fill`
`fill(vec.begin(),vec.end(),0)`相当于给容器元素赋某个特定的值，并不会改变容器大小。

<br/>


`fill_n`
`fill_n(vec.begin(),vec.size(),0)`用法和`fill`有些许不同。算法不会对写操作进行检查，当对写的范围超出容器，结果未定义。

<br/>


`back_inserter`
==插入迭代器是向容器中添加元素的迭代器==，通过向迭代器赋值，容器被插入一个元素。
```cpp
vector<int> vec;
auto it=back_inserter(vec);
*it=1;
*it=2;
//vec中被插入了两个元素，分别是1和2
```
`fill_n(back_inserter(vec),10,0)`此时是向容器插入10个元素。

> ==对一个插入迭代器赋值，相当于在容器末尾插入一个元素==。

<br/>


`copy`
向目标迭代器之后写入，指定源迭代器范围内的元素，因此目标序列至少要和原序列含有一样多的元素，`copy(begin(a1),end(a1),a2)`，函数返回的是目标序列的迭代器，指向插入序列的后一个位置。


<br/>


**算法的copy版本**
有些算法原本是会改变原序列的，用这些算法的拷贝版本就可以保存原序列不变，结果保存到别处，如下：

- `replace(list.begin(),list.end(),0,1)`将原序列中的0改成1
- `replace_copy(list.begin(),list.end(),vector.begin(),0,1)`第3个参数是序列保存的目标位置，可以是一个插入迭代器（此时在容器之后插入处理之后的序列）

---

<br/>


<br/>



### 10.2.3 重排元素的算法

`sort`
STL 中的快排函数，默认利用元素类型的`<`运算符实现比较。

`unique`
用于消除相连之间的重复项，并不是删除元素，而言用后面的元素覆盖重复元素，返回值是处理之后的序列（也就是没有相邻重复项）的尾迭代器。

---

<br/>


<br/>


<br/>



## 10.3 定制操作

### 10.3.1 向算法传递函数

`sort`函数的重载版本接受第三个参数——一个谓词（predicate）。

<br/>


**谓词**
==谓词是一个可以调用的表达式，其返回结果是一个能用作条件的值==。分为一元谓词（接受一个参数）、二元谓词（接受两个参数），接受谓词的算法对输入序列的元素调用谓词，所以元素类型必须能转换成谓词的参数类型。


<br/>


**稳定排序算法**
`stable_sort`稳定排序算法，内部用归并排序实现。

---

<br/>


<br/>



### 10.3.2 lambda表达式
**lambda简介**
我们可以向一个算法传递任何类别的可调用对象（可以对其使用调用运算符`()`，如函数和函数指针）。

lambda表达式时一个可调用的代码单元，可以认为是一个位命名的内联函数，具有如下形式：
```cpp
[capture list] (parameter list) -> return type { function body }
```
- 捕获列表是在 lambda 所在函数中定义的局部变量的列表，
- ambda必须使用尾置返回，可以忽略参数列表和返回类型，如果忽略返回类型，且函数体中不止一条语句，返回`void`，如果只有一条`return`语句，则返回类型从该语句的类型推断而来（超过一条语句，且返回类型不为`void`，不能忽略返回类型）。


<br/>


**向lambda传递参数**
lambda不能有默认参数。

<br/>



**使用捕获列表**
只有在捕获列表中捕获所在函数的变量才能访问，此时在捕获列表中的参数相当于作为形参在lambda中，因此修改捕获类中的变量不会改变lambda所在函数的变量的值。
但是当捕获列表中传入的时`&`时，表示将所有参数的引用传入lambda，此时可以修改值。

<br/>


`find_if`
`find_if(vec.begin(),vec.end(),/*lambda*/)`前两个参数指定了查找的范围，第三个参数是一个可调用对象，接受一个元素类型的参数，返回bool。

`for_each`
`for_each(v.begin(),v.end(),/*lambda*/)`前两个参数指定范围，第三个参数接受一个元素类型的引用参数，用来对范围内元素进行操作。

---

<br/>


<br/>



### 10.3.3 lambda捕获和返回
当定义lambda时，编译器生成一个与lambda对应的新的类类型，并创建一个对象，类中都包含一个对应该lambda捕获的变量的数据成员，该数据成员在有默认初始值。

**值捕获**
与普通函数的形参不同的是，被捕获的变量是在lambda创建时拷贝，而不是调用时拷贝。

<br/>


**引用捕获**
需要确保被引用的对象在lambda执行时是存在的。

<br/>


**隐式捕获**
在捕获列表中，用`=`表示值捕获，`&`表示引用捕获。
混用隐式捕获和显式捕获可以实现一部分用值捕获，其余用引用捕获，如`[=, &a](){ }`或者`[&, a](){ }`，==此时捕获列表第一个元素必须是`=`或`&`，剩下元素必须和第一个元素捕获类型不一样==。

<br/>


**可变lambda**
==值捕获变量，lambda 时不能改变其值，只能使用其值==。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字 `mutable`，==此时可以修改的是**拷贝**的值==。mutable 关键字修饰类的数据成员用法参考[前面](#oedr4)。
```cpp
int a = 1;
auto f = [a]() mutable{
        return ++a;
};
```
对捕获的引用，是否可以进行修改取决于指向的是一个const类型还是非const类型对象。

<br/>


**指定返回类型**
lambda的函数体是一个单一的`return`语句时，无需指定返回类型，可以进行类型推断；但是函数体不是单一`return`语句时，且返回类型不是`void`必须指定返回类型。

<br/>

`tramsform`
函数用于将指定序列元素处理后，放入一个新的位置，lambda 是对元素进行的处理。`transform(v.begin(),v.end(),v1.begin(),/*lambda*/)`。

---

<br/>


<br/>


### 10.3.4 参数绑定
如果需要在很多地方使用相同的操作，通常定义一个函数。当lambda的捕获列表为空时，通常可以用函数进行代替。

**标准库**`bind`**函数**
定义在头文件`functional`中，作用可以看作是一个函数适配器。<span style="background:#fff88f">接受一个可调用对象，生成一个新的可调用对象</span>。使用方法：
```cpp
auto newCallable = bind (Callable , arg_list) ;
```
`arg_list`是一个参数列表，对应`Callable`（即，原函数）的参数表。

<br/>


`placeholders`**名字**
占位符`_n`定义在`placeholders`的命名空间中，而其又定义在`std`中。
> 命名空间的嵌套
> 当一个命名空间b属于命名空间a，当using namespace a之后，如果需要使用b中的变量x，直接b : : x即可，但是不能直接使用 x 。

<span style="background:#fff88f">`_n`代表该参数来自**新生产的可调用对象**的参数列表的第`n`个参数</span>。
```cpp
auto g = bind ( f, a, b, _2, c, _1 ) ;
```
调用`g(_1, _2)`，实际调用为`f(a, b, _2, c, _1)`
==可以看出这种方式可以重排参数的顺序==。
```cpp
auto f = [](int e1, int e2, int e3, int e4) {return e1 + e2 + e3 + e4;};
    int a = 1, b = 2;
    auto g = bind(f, a, b, _2, _1);
    cout << g(0, 0) << endl;    //3
    a = 10; b = 20;
    cout << g(0, 0) << endl;    //3
```
以上代码可以看出，bind和lambda类似，也是==创建时就传入变量的拷贝==。

<br/>


**绑定引用参数**
`bind`会拷贝非占位符的参数，并保存到其返回的可调用对象中，如果参数是引用就拷贝引用指向的值，所以会出现以下结果：
```cpp
auto f = [](int &e1, int &e2, int e3, int e4) {return e1 + e2 + e3 + e4;};
    int a = 1, b = 2;
    auto g = bind(f, a, b, _2, _1);
    cout << g(0, 0) << endl;    //3
    a = 10; b = 20;
    cout << g(0, 0) << endl;    //3
```
如果希望传递给`bind`一个对象而不是拷贝它，必须使用==标准库函数`ref`。该函数返回一个对象，包含给定的引用，此对象可以被拷贝。==`cref`返回`const`的引用，两个函数定义在`functional`头文件中。
> `ref` 函数的返回值是一个**引用包装器对象**，它可以将传入的对象包装成引用类型。这个引用包装器对象==可以像引用一样使用==。

```cpp
auto f = [](int &e1, int &e2, int e3, int e4) {return e1 + e2 + e3 + e4;};
    int a = 1, b = 2;
    auto g = bind(f, ref(a), ref(b), _2, _1);
    cout << g(0, 0) << endl;    //3
    a = 10; b = 20;
    cout << g(0, 0) << endl;    //30
```

---

<br/>


<br/>


<br/>


## 10.4 再探迭代器
除了为每种容器定义的迭代器以外，标准库还在头文件`iterator`中定义了额外几种迭代器。

### 10.4.1 插入迭代器

插入迭代器是一种迭代器适配器，接受一个容器，生成能够向特定容器特定位置插入元素的迭代器。

**插入迭代器的操作**

- `*it=t`：在指定位置插入元素。
- `it ++it it++`：不做任何事情，每次返回迭代器本身。

**插入迭代器的类型**

- `back_inserter`：使用`push_back`。
- `front_inserte`：使用`push_front`。
- `inserter`：使用`insert`，创建时接受第二个参数，表示插入的位置。==在一次插入操作之后，迭代器还会指向原来指向的元素==。

---

<br/>


<br/>


### 10.4.2 iostream迭代器
`istream_interator`读取输入流，`ostream_iterator`向输出流写数据，通过使用流迭代器，可以使用泛型算法对流进行操作。

`istream_iterator`**操作**
输入流将数据从外部输入内存，可以使用`istream_iterator`对输入的数据进行读取，`istream_iterator`是模板而不是类型，必须用`<>`指定读取的数据类型。

- `istream_iterator<int> it(cin);`：将迭代器绑定到`cin`
- `istream_iterator<int> eof;`：==默认初始化，相当于尾后迭代器==

==`istream_iterator`最有用的地方就是，可以将流看作是一个含有特定类型数据的容器来进行处理==，一个例子如下：
```cpp
    istream_iterator<int> in(cin), eof;
    vector<int> vec(in, eof);
```

<br/>


**使用算法操作流迭代器**
有了流迭代器可以将流当作容器处理，因此可以使用泛型算法进行操纵，如：
`accmulate(int_iter,eof,0);`


<br/>


`istream_iterator`**允许懒惰求值**
当流迭代器绑定到流上面后，标准库并不保证立即从流读取数据，==具体实现可以推迟直到使用流迭代器才真正读取。==
> 也就是说，直到需要使用流迭代器时，才会从流上面读取数据

<br/>


`ostream_iterator`**操作**

- `ostream_iterator<T> out(os);`：将赋给迭代器的值写到输出流中。
- `ostream_iterator<T> out(os,s);`：在上面的基础上会在每个值后面都输出一个`s`，为空字符结尾的字符数组。

解引用、自增等运算符对流迭代器不起作用，但是推荐这样书写，可以和其他类型迭代器保持使用一致。
将循环修改为操作其迭代器类型，修改起来更容易：
`copy(v.begin(),v.end(),out_iter);`

<br/>


**流迭代器处理类类型**
任何定义了`>>`的类型可以创建`istream_iterator`，任何定义了`<<`的类型可以创建`ostream_iterator`。

---

<br/>


<br/>



### 10.4.3 反向迭代器
反向迭代器和正向迭代器的操作含义相反，递增一个反向迭代器`++it`会让迭代器指向前一个元素。
`forward_list`不能反向移动，流迭代器不支持递减运算，所以这两类对象不能创建反向迭代器。

---

<br/>


<br/>


<br/>



## 10.5 泛型算法结构
算法的最基本特征是要求的迭代器能提供哪些操作。另外的分类方式是按照是否读、写、重排元素进行分类。

### 10.5.1 迭代器分类

高层类型迭代器支持底层类型迭代器的所有操作。

**输入迭代器 input iterator**
只读不写，单遍扫描，只能递增。支持的操作：
- 比较迭代器的`==`和`！=`。
- 推进迭代器的前置和后置`++`。推进一个迭代器可能会使其他指向流的迭代器失效，只支持单遍扫描。
- 读取元素的`*`。解引用只能出现在`=`右边。
- 读取元素的`->`。

**输出迭代器 output iterator**
只写不读，单遍扫描，只能递增。除了只写不读，基本和输入迭代器一样。

**前向迭代器 forward iterator**
可读写，多遍扫描，只能递增。只能在序列中沿着一个方向移动，并不一定是向前。

**双向迭代器 bidirectional iterator**
可读写，多遍扫描，双向移动。

**随机访问迭代器**
在常量时间内访问序列任意元素的能力。需要额外提供的操作：

- 比较迭代器的关系运算符`<`、`<=`、`>`、`>=`。
- 迭代器和整数加减得到迭代器在序列中前进或后退给定整数个位置元素的位置。
- 用于两个迭代器的`-`运算，得到之间的距离（类似数组的下标之间相减）。

---

<br/>


<br/>



### 10.5.2 算法形参模式
大多数算法的形参具有以下四种形式之一：

- `alg(beg,end,other);`
- `alg(beg,end,dst,other);`
- `alg(beg,end,beg2,other);`
- `alg(beg,end,beg2,end2,other);`

### 10.5.3 算法命名规范
**重载版本传递谓词**
默认版本使用默认的运算符，重载版本接受一个谓词，例如：

- `unique(beg,end);`——默认使用`==`运算符。
- `unique(beg,end,comp);`——使用`comp`进行比较。

**算法的_if版本**
接受一个元素值的算法通常具有另一个名字加上`_if`后缀的版本，例如：

- `find(beg,end,val);`——查找`val`第一次出现的位置。
- `find_if(beg,end,pred);`——查找第一个零`pred`为真的位置。

**算法的_copy版本**
有`_copy`的版本不会改变原序列，而是拷贝到`dest`中，例如：

- `reverse(beg,end);`——反转序列元素。
- `reverse(beg,end,dest);`——拷贝到目标序列进行反转（逆序拷贝到`dest`）。

---

<br/>


<br/>


<br/>


## 10.6 特定容器算法
链表类型`list`和`forward_list`定义了成员函数形式的算法——`sort``merge``remove``reverse``unique`。
有些算法的通用版本不能处理链表，如`sort`要求随机访问迭代器。有些算法的通用版本对于链表操作代价过高，算法需要交换元素，而链表可以改变元素之前的链接而不是交换值来快速交换元素，链表版本的算法那回避通用版本好很多。

`splice`**成员**
链表类型还定义了特有的`splice`算法，用于在链表的特定位置插入另一个链表的特定序列。

**链表特有操作改变容器**
链表的特有版本函数会改变容器。`remove`会删除指定元素，`unique`会删除重复元素，`merge` `splice`会销毁参数，以上结果都在链表在算法操作过程改变元素链接关系导致的。

---

<br/>


<br/>


<br/>


<br/>




# 第11章 关联容器

## 11.1 使用关联容器

**使用**`map`
进行下标操作时，如果对应的`key`不存在就会创建一个新的`key-value`对，对`value`执行默认初始化。用迭代器从`map`提取元素是得到的是一个`pair`。

**使用**`set`
主要用于查询元素是否在集合中，`find`函数返回一个迭代器，如果元素存在就迭代器执行该元素，否则返回地址是尾后迭代器。

---

<br/>


<br/>


<br/>


## 11.2 关联容器概述
关联容器的迭代器是双向的。
### 11.2.1 定义关联容器
**关联容器定义方式**

- 默认初始化：关联容器定义的默认构造函数，可以创建一个空容器，如`map<int,int> m;`。
- 初始化为另一个同类型容器的拷贝
- 从一个值范围初始化关联容器：要求值可以转化为容器所需类型，如：

```cpp
vector<string> v{ "ab","cd","ef","gh" };
set<string> s (v.begin (), v.end ());
```

<br/>


`multimap`**和**`multiset`
关键字不唯一。

---

<br/>


<br/>


### 11.2.2 关键字类型
默认情况下标准库使用关键字类型的`<`运算符来比较两个关键字。
**有序容器的关键字类型**
可以用自己定义的操作替换关键字的`<`运算符，要求定义的操作在关键字类型上定义一个严格弱序：

- 两个`key`不能同时`<=`对方。
- 具有传递性。
- 两个`key`都不`<=`对方，两个`key`等价。


<br/>


**使用自定义比较函数**
用来组织元素的操作也是容器类型一部分，必须在`<>`中紧跟着元素类型给出，如下：
```cpp
set<string ,decltype(cmp)*> s (cmp);
```
给出的是函数的指针类型，需要在`decltype`之后加`*`，同时在创建对象时，需要把函数指针传进来。

---

<br/>


<br/>


### 11.2.3 `pair`类型
定义在头文件`utility`中，类似容器，保存两个数据成员。
`pair`的默认构造函数对数据成员使用值初始化。
`pair`的数据成员是`public`的，为`first`和`second`，直接用成员访问符号`.`访问。

`pair`**的操作**

- `make_pair(v1,v2)`：返回一个用`v1`和`v2`初始化的`pair`对象，`pair`类型用这两个值的类型推断出来。
- 使用比较运算符，按字典序进行比较。

---

<br/>


<br/>


<br/>




## 11.3 关联容器操作
关联容器定义的类型别名：

- `key_type`：关键字类型。
- `mapped_type`：只适用于`map`类的类型，`value`的类型。
- `value_type`：对于`set`，其和`key_type`相同，对于`map`为一个`pair`类型。

### 11.3.1 关联容器迭代器
解引用关联容器的迭代器是，得到一个类型为容器的`value_type`的值的引用。
==`key`**为**`const`==

- 对于`map`：`value_type`是一个`pair`类型，`first`保存的是`const`的关键字。
- 对于`set`：`value_type`为关键字的`const`类型。

<br/>


**遍历关联容器**
对于有序的容器，使用迭代器遍历时，迭代器按照关键字升序遍历元素。

<br/>


**关联容器和泛型算法**
关键字为`const`，所以关联容器只适用于只读取元素的算法，这类算法一般都是搜索序列，如`find`按照关键字升序查找不能进行快速查找，一般不用泛型的函数，而是用关联容器自定的函数成员。
实际编程中，运用泛型算法一般是把关联容器看作是一个源序列或者目的位置，例如：

- 用`copy`将一个关联容器拷贝到另一个序列。
- 通过插入迭代器，将关联容器看作是一个目标位置。

---

<br/>


<br/>


### 11.3.2 添加元素
`insert`**操作**
有多个重载的函数，可以插入单个值、列表或者用迭代器指定范围的元素。
返回值是一个`pair`，`first`是指向插入的关键字的元素，`second`为`bool`指明是否插入成功。
---

<br/>


<br/>



### 11.3.3 删除元素
用`erase`删除元素，可用迭代器指定要删除的元素、迭代器范围指定删除范围元素，或者删除指定关键字的所有元素。

---

<br/>


<br/>


### 11.3.4 `map`下标操作
`map`和`unordered_map`容器提供了下标运算符`[]`和一个`at`函数。

下标操作返回的是`mapped_type`，同时也是一个左值，==如果容器不存在该关键字，会插入该关键字，无论取下标操作时间位于`=`左边还有右边。如果处于`=`右边，对`mapped_type`进行默认初始化。==


---

<br/>


<br/>


### 11.3.5 访问元素
容器访问元素主要有以下方式：

- `find`：返回第一个匹配的迭代器，找不到则返回尾后迭代器。若只需要查找元素是否存在容器中，推荐使用`find`，而不是`count`。
- `count`：返回匹配的元素数量，对于不允许重复的关键字容器，返回值只能是0或1。
- `lower_bound`：返回第一个关键字不小于目的关键字的元素的迭代器。不适用于无序容器。
- `upper_bound`：返回第一个关键字大于目的关键字元素的迭代器。不适用于无序容器。
- `equal_range`：返回一个`pair`，起始迭代器和尾后迭代器，表示关键字等于目的关键字的元素范围。

---

<br/>


<br/>


## 11.4 无序容器
无序容器定在`unordered_map`和`unordered_set`头文件中，无序容器不是使用比较运算符组织元素，而是哈希函数。
**无序容器操作**
无序容器提供了与有序容器相同的操作（除了部分需用用到有序性质的操作，如`lower_bound`）。

**管理桶**
无序容器使用桶管理元素，利用哈希函数，将零个或多个元素映射到桶里面。相同的关键字的元素映射到同一个桶。当桶中有多个元素时，在桶中进行顺序查找。无序容器提供了桶的相关操作：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681791226739-06ead932-e915-4093-84dd-db8af65745dd.png" width="700" /> </div>



---

<br/>


<br/>


<br/>


<br/>



# 第12章 动态内存

## 12.1 动态内存和智能指针

在C++中，用`new`分配程序堆空间，用`delete`释放申请的内存。为了安全使用动态内存，新标准库提供了两种智能指针——`shared_ptr`和`unique_ptr`，可自动释放指向的对象。还定义了一种若引用`weak_ptr`，==三者定义在头文件`memory`中。==
### 12.1.1 `shared_ptr`类
智能指针是模板，需要指定指针指向的类型，如：`shared_ptr<int> p;`。默认初始化的智能指针保存空指针。
**智能指针操作**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681887499382-21452f0e-5306-4280-8deb-83dcf89dbea8.png" width="700" /> </div>



`make_shared`**函数**
最安全的分配和使用动态内存的方法就是使用标准库函数`make_shared`。该函数使用方法如下：
```cpp
share_ptr<int> p=make_shared<int>();
// auto p=make_shared<int>();
cout<<*p<<endl; //输出 0
```
必须指定指针指向的元素的类型，可以向括号传递参数进行初始化，如果没传递参数则进行==值初始化==。由于在`make_shared`指定了指针指向元素的类型，所以可以用`auto`进行类型推断：
`auto p=make_shared<int>();`

<br/>


`shared_ptr`**的拷贝和赋值**
每个指向同一个对象的`shared_ptr`都有一个关联的计数器，表明有多少个`shared_ptr`指向同一个对象，当一个`shared_ptr`被销毁时，计数器递减，当减到0时，自动释放管理的对象。

<br/>


**使用动态生成期资源的类**
程序使用动态内存的原因有：

- 不清楚将要使用多少对象。
- 不清楚所需对象的准确类型。
- 需要在多个对象之间共享数据。

容器就是出于第一个原因使用动态内存，容器的分配的资源和对象的生存期一致，当用一个拷贝一个容器时，原容器和副本容器的元素是分离的（不是共享内存）。

---

<br/>


<br/>


### 12.1.2 直接管理内存

`new`**动态分配和初始化对象**
默认情况下，==动态分配的对象是默认初始化==的。可以使用==直接初始化`()`或者列表初始化`{}`==，加空括号表示进行值初始化。
> **直接初始化和拷贝初始化**
> - 直接初始化，如`int i(42);`，编译器会尝试执行**窄化转换**，即将高精度类型的值转换为低精度类型的值，如`int i(4.2);`。
> - 拷贝初始化，如`int i=42;`，拷贝初始化要求赋值两边的类型相同。

如果使用了`()`包围的初始化器，可以使用`auto`。

<br/>


**动态分配**`const`**对象**
动态分配的`const`对象，除了定义了默认构造函数的类类型，==必须进行显示的初始化（由于对象是`const`的，创建对象时不初始化，之后就不可能初始化了）==。

<br/>


**内存耗尽**
如果`new`不能分配所需空间，就会抛出一个类型为`bad_alloc`的异常。
可以使用定位`new`来阻止抛出异常，允许给`new`提供额外参数，如下：
```cpp
int *p=new (nothrow) int (42);
```
`bad_alloc`和`nothrow`定义在头文件`new`中。
> 头文件`new`被包含在`iostream`中。

<br/>



**指针值和**`delete`
不能`delete`一个静态动态变量的指针。
不能对同一块内存`delete`两次，这样可能会让破坏自由空间。

---

<br/>


<br/>


### 12.1.3 `share_ptr`和`new`结合使用
除了`make_shared`还可以用`new`返回的指针初始化智能指针，由于智能指针的构造函数是`explicit`的，所以不能将一个内置指针隐式转化为一个智能指针，必须使用直接初始化形式`()`。

```cpp
class MyClass {
public:
    MyClass () {
        std:: cout << "MyClass constructor called!" << std:: endl;
    }
};

int main () {
    MyClass* obj = new MyClass (); // 创建一个内置指针

    // std::shared_ptr<MyClass> ptr = obj; // 错误，不能隐式转换为智能指针
    std::shared_ptr<MyClass> ptr (obj); // 正确，使用直接初始化形式

    delete obj;
    return 0;
}
```

可以将智能指针绑定到一个指向其他类型资源的指针上，此时必须提供自己的操作来代替`delete`：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29674612/1681975644995-dd3e3d27-4ba5-4d4a-8689-26c16ff4850c.png" width="700" /> </div>

---

<br/>


<br/>



### 12.1.4 智能指针和异常
使用智能指针，即使程序发生异常过早结束，智能指针类也能确保资源被正确释放。


---

<br/>


<br/>


### 12.1.5 `unique_ptr`
`unique_ptr`不共享其管理的对象，==**不支持普通拷贝和赋值**==，初始化`unique_ptr`时必须使用直接初始化。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1689072839484-445b058e-3549-47ae-a2ed-7d2e1b7c0a84.jpeg" width="700" /> </div>


`unique_pt`**指针管理权的转移**
可以使用`release`和`reset`函数实现对于指针的管理权在两个`unique_ptr`之间转移。

<br/>


**返回**`unique_ptr`
==不能拷贝`unique_ptr`的规则有一个例外：可以拷贝或赋值一个将要被销毁的`unique_ptr`==。例如，可以从函数返回一个`unique_ptr`。

---

<br/>


<br/>


### 12.1.6 `weak_ptr`
`weak_ptr`不控制所指向对象的生存期，指向一个`share_ptr`管理的对象。`weak_ptr`操作如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1689073248477-5372e965-0c47-4e65-9646-f0d54e022cb0.jpeg" width="700" /> </div>


`weak_ptr`管理的对象可能不存在，因此需要使用`lock`函数，获得一个`share_ptr`访问对象。

<br/>

> ==`weak_ptr` 的存在是为了解决 `shared_ptr` 可能导致的**循环引用问题**==。
> 
>  shared_ptr 是通过引用计数来管理资源的智能指针，它会在每个 shared_ptr 指向的资源上增加一个引用计数。当引用计数变为 0 时，资源会被释放。然而，当存在循环引用时，由于每个对象都持有对方的 shared_ptr ，它们的引用计数永远不会变为 0，资源也不会被释放，从而导致内存泄漏。 
> ```cpp
> class B;  // 前向声明
> 
> class A {
> public:
>     std::shared_ptr<B> bPtr;
> };
> 
> class B {
> public:
>     std::shared_ptr<A> aPtr;
> };
> 
> // ....
> 
> std::shared_ptr<A> a = std::make_shared<A>();
> std::shared_ptr<B> b = std::make_shared<B>();
> a->bPtr = b;
> b->aPtr = a;
> ```
> 在这个例子中，a 和 b 相互持有对方的引用，导致它们的引用计数永远不会变为 0。即使我们不再使用 a 和 b，它们也无法被正确释放，从而造成内存泄漏。 
> 
>  weak_ptr 是一种**弱引用**，它可以观测 shared_ptr 所管理的资源，但并不拥有资源的所有权。 **weak_ptr 不会增加引用计数**，当其所观测的资源被释放时， weak_ptr 会自动失效。
---

<br/>


<br/>


<br/>


## 12.2 动态数组

### 12.2.1 new 和数组

**初始化动态数组**
默认情况下，动态分配的对象都是默认初始化。对元素进行值初始化的方法：加一对空括号。

<br/>


**动态分配空数组**
不能创建大小为0的静态数组。==允许创建动态分配的空数组==，但是不能解引用。

<br/>


**智能指针和动态数组**
标准库提供了一个可以管理动态数组的`unique_ptr`，销毁时自动调用`delete []`。当`unique_ptr`管理动态数组时，可以使用下标运算符来访问元素。

`share_ptr`管理动态数组时，需要自定义删除器。另外由于`share_ptr`没有提供下标运算符，而且智能指针不支持算术运算，必须使用`get`获得内置指针，才能访问数组元素。

<br/>

---

<br/>


<br/>



### 12.2.2 `allocator`类

^6667a0

==`new`将**内存分配**和**对象构建**组合在一起==，==在申请了内存但是没有使用对象的情况下，构建对象增加了时间消耗==。`allocator`是模板，将内存分配和对象构建 分离，使用方式如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1689079507724-8b7321d2-f692-427a-aef3-8ce51f13e692.jpeg" width="700" /> </div>



**拷贝和填充未初始化内存的算法**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1689079661822-6d6a19ce-9990-499d-bfc3-36ea9bfbfd4c.jpeg" width="700" /> </div>


---

<br/>


<br/>


<br/>


<br/>





# 第13章 拷贝控制

## 13.1  拷贝、赋值、销毁

### 13.1.1 拷贝构造函数

拷贝构造函数用于用一个对象来拷贝构造出另一个新的对象。拷贝构造函数：
- 是一个构造函数；
- ==第一个参数是一个引用类型==（一般设置为`const`），==其他额外参数有默认值==。


**合成拷贝构造函数**
即使定义了其他构造函数，但是如果没有定义拷贝构造函数，编译器也会定义一个合成的拷贝构造函数。
一般情况下，编译器会从给定个对象中一次将每个非`static`成员（`static`成员是所有对象共享的，所以不必进行拷贝）拷贝到正在创建的对象中。

对于数组成员（并非指针），合成拷贝构造函数，会逐个元素拷贝数组。

<br/>


**拷贝初始化**
直接初始化使用函数匹配调用对应的构造函数，而拷==贝初始化通常使用拷贝构造函数来完成==（也可能使用移动构造函数实现）。
拷贝初始化发生的情况：

- 使用`=`定义变量。
- 将一个对象作为实参传递给一个非引用类型的形参。
- 返回类型为一个非引用类型的函数返回一个对象。
- ==使用花括号列表初始化一个数组或者一个聚类==。

<br/>


**参数和返回值**
==由于将一个对象作为实参传递给一个非引用类型的形参需要使用拷贝初始化，所以拷贝构造函数的第一个参数必须是引用类型，否则自己调用自己，无限循环。==

<br/>


**编译器优化**
编译器可以跳过拷贝/移动构造函数，直接创建对象，如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1689601630173-2705339a-8a5c-45c0-97d9-2cc1e2fb2940.jpeg" width="700" /> </div>

- 在行 1， 中由于 string 的构造函数不是一个`explicit`的，所以说 string 类型允许从`const char* `到 string 的隐式转换。，首先将`"999"`隐式转化为一个 string 的临时对象，然后应该调用 string 的拷贝构造函数对 null_book 初始化。

- 在行2中，编译器进行了优化，==直接使临时对象成为所创建出来的对象==。

---


<br/>


<br/>



### 13.1.2 拷贝赋值运算符
**重载运算符**
如果运算符是一个==成员函数，左侧对象绑定到隐式的`this`参数，右侧运算对象作为显式参数传递。==
为了与内置类型的复制保持一致，通常返回一个指向其左侧运算对象的引用。
> 标准库通常要求保存在容器中的类型具有赋值运算符，返回值是左侧对象的引用。


<br/>


**合成拷贝赋值运算符**
将右侧运算对象的每个非`static`成员赋予左侧对象的对应成员。

---

<br/>


<br/>



### 13.1.3 析构函数
**析构函数完成的工作**
释放对象使用的资源，销毁对象的非`static`数据成员。
在一个析构函数中，首先执行函数体，然后销毁成员，==**成员按照初始化顺序的逆序销毁**==。

<br/>


**合成析构函数**
合成析构函数的函数体为空。

---


<br/>


<br/>


### 13.1.4 三/五法则
**需要析构函数的类也需要拷贝和赋值操作**
一个类需要析构函数，通常是申请了资源，靠进行拷贝和赋值操作时需要进行==**深拷贝**==。

<br/>


**需要拷贝操作的类也需要赋值操作，反之亦然**
有些类需要拷贝或赋值操作却不需要析构函数，例如，一个类需要为每个对象分配一个独有的、唯一的序号。

---



<br/>


<br/>


### 13.1.5 使用`=default`
可以使用`=default`来显式要求编译器生成合成版本。只能对具有合成版本的函数使用`=default`。

---


<br/>


<br/>



### 13.1.6 阻止拷贝
对于某些类来说，拷贝赋值没有合理的意义，例如IO类，需要采取机制阻止拷贝或者赋值。

==**删除的函数**==
删除的函数可以进行声明，但是不能以任何方式使用他们。可以在参数列表之后加上`=delete`表示希望将其定义为删除的函数。
`=delete`和`=default`的不同之处：

- ==`=delete`只能在函数第一次声明时使用==。
- 可以对任何函数指定`=delete`。

<br/>


**析构函数不能是删除的成员**
对于一个删除了析构函数的类，编译器不允许定义该类型的变量或者临时变量，如果一个类 A 的某个类类型 B 的成员删除了析构函数，这个类 A 将也不能定义变量或者临时变量。

可以动态分配这种类型的对象，但是同样不能释放。

<br/>


**合成的拷贝控制成员可能是删除的**

- 类的**某个成员的析构函数**是删除或者不可访问的，类的**合成析构函数**和**合成拷贝构造函数**（不可定义变量）是删除的。
- 类的**某个成员的拷贝构造函数**是删除或者不可访问的，类的**合成拷贝构造函数**定义为删除。
- 类的**某个成员的拷贝赋值运算符**是删除，类有一个`**const**`**成员**，或者**引用成员**，类的**合成拷贝赋值函数**定义为删除。
- 类的某个成员的析构函数是删除的或者不可访问的，或者类有一个引用成员且没有类内初始化器，或者是有一个`const`成员，没有类内初始化器且类型未定义显示默认构造函数，则该类的默认构造函数定义为删除（需要自己定义）。

<br/>


`parvate`**拷贝控制**
在新标准之前，类通过将拷贝构造函数和拷贝赋值运算符声明为`private`来阻止拷贝。

同时为了阻止友元和成员函数进行拷贝，将拷贝控制成员声明为`private`且不进行定义。

---

<br/>


<br/>


<br/>




## 13.2 拷贝控制和资源管理

### 13.2.1 行为像值的类
进行拷贝时需要进行深拷贝，如果申请了动态分配的资源，需要定义析构函数释放。

**赋值运算符**

- 将一个对象赋予自身，赋值运算符必须能够正确工作。
- 大多数赋值运算符组合了析构函数（被赋值的对象原来的资源需要释放）和拷贝构造函数的工作。

---


<br/>


<br/>



### 13.2.2 定义行为像指针的类

定义的类类似智能指针。

**引用计数**
将计数器保存保存在动态内存中，创建时将计数器置为1，进行拷贝时将计数器递增，如下，==为了避免自身赋值拷贝时出错，先新增赋值对象的计数器，在递减被赋值对象的计数器并进行判断==：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1689641536208-a2d5672b-bfd6-4501-9060-4ae589dd3cb8.jpeg" width="700" /> </div>



---


<br/>


<br/>


<br/>



## 13.3 交换操作
对于一个申请了动态内存的类来说，进行交换操作时，交换指针效率更高。

**自定义**`swap`**函数**
首先将`swap`声明为`friend`，以便能够访问类中数据成员。如果函数中需要调用（可能存在）的其他自定义的`swap`，需要==加上`using  std:: swap;`此时如果有其他特定类型版本的`swap`函数，会优先调用，而不是调用标准库的函数。==

<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1689642795408-373ae2c6-7d8a-4dcf-8589-312f1ccf951d.jpeg" width="700" /> </div>


<br/>

**在赋值运算符中使用**`swap`
==定义了`swap`的类通常会使用`swap`和拷贝构造函数 来定义赋值运算符。自动处理了自赋值的情况且异常安全的。==
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1689643042933-af460e93-8489-4551-8fe6-fb209471c7a4.jpeg" width="700" /> </div>



---

<br/>


<br/>


<br/>





## 13.6 对象移动 

###  13.6.1 右值引用

通过`&&`获得右值引用，只能绑定到即将销毁的对象（因此可以将一个右值引用的资源“移动”另一个对象）。

**标准库**`move`**函数**
`move`函数可以显式将一个左值转换成一个右值引用类型。

调用`move`意味着承诺：除了对被移动的左值进行赋值或销毁，不进行其他任何操作。

==使用`move`函数的代码应该使用`std::move`来避免名字冲突。==

---

<br/>


<br/>



### 13.6.2 移动构造函数和移动赋值运算符
移动构造函数与拷贝构造函数类似，但==第一个参数是一个右值引用==。移动构造函数除了完成资源的移动之外，还==需要保证移后源对象处于无害的状态（进行销毁时，不会释放被移动的资源）==。


**移动操作、标准库容器和异常**
当编写一个不抛出异常的移动操作时，应该事先通知标准库。标准库容器除非事先知道移动构造函数不会抛出异常，否则会使用拷贝构造函数，而非所期望的移动函数。

使用`noexcept`来表明函数不会抛出异常：

> - 在函数的参数列表之后指定`noexcept`，如果有==初始化列表，就在初始化列表和参数列表之间==指定。
> - ==声明和定义都指定`noexcept`==。

<br/>

**移动赋值运算符**
如果不会抛出异常，也应该将其标志为`noexcept`。需要检查自赋值：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1689645554041-83bddb08-c8da-4ee6-acb5-28f503e68161.jpeg" width="700" /> </div>


<br/>


**移后源对象可析构**
从一个对象移动数据并不会销毁此对象。

<br/>


**合成移动操作**
==合成移动操作的条件：==
类没有定义任何拷贝控制成员；类的每个非static数据都可以移动。 ^5d8983

<br/>


**拷贝/移动 并交换 实现赋值运算符**
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1689646058596-a2a5cb56-6006-4615-830e-1b8fb8a6e2cb.jpeg" width="700" /> </div>


临时对象是拷贝还是移动构造的对象，取决于传入的参数类型，传入左值引用就调用拷贝构造函数创建对象，传入右值引用就调用移动构造函数创建临时对象。

<br/>


**移动迭代器**
==移动迭代器解引用得到的是右值引用==，标准库`make_move_iterator`函数将一个普通迭代器转化为移动迭代器。
> 普通迭代器解引用得到左值引用

---


<br/>


<br/>



### 13.6.3 右值引用和成员函数
定义了`push_back`的标准库容器提供两个版本：

- 参数是接受`const`的左值引用：可绑定到任意类型的对象。
-  右值引用：只能绑定到右值。

**左值和右值引用成员函数**
为了向后兼容性，有时可能会出现对临时对象（右值）赋值的情况如下：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1689647041512-75dc3810-e20c-4856-b322-eea20b0a44e9.jpeg" width="700" /> </div>


为了阻止这种用法，可以采用**引用限定符**，==如果同时用`const`和引用限定，引用限定符跟在`const`之后。==

<br/>


**重载和引用函数**
当定义两个或多个具有相同名字和参数列表的重载函数时，要么所有同名函数都加上应用限定符，要么所有都不加。

---

<br/>


<br/>


<br/>


<br/>



# 第14章 重载运算与类型转换
## 14.1 基本概念
重载的运算符是特殊的函数，名字由关键字`operator`和要重载的符号构成。重载几元运算符就需要多少个参数输入，但是如果运算符函数是类的成员函数，第一个参数绑定到隐式的`this`指针，参数数量会少一个。
以下几点需要注意：

- ==对于一个（非成员函数）的运算符函数，至少含有一个类类型的参数。==
- 只能重载已有的运算符。
- 有些运算符`+,-,*,&`，既是一元运算符也是二元运算符，需要从参数的数量上进行推断。
- 对于重载的运算符，优先级和结合律 与对应内置的运算符保持一致。
- 并不是所有运算符都能被重载，如`::``.``? :`

<br/>


**直接调用重载的运算符函数**
对于非成员运算符函数，除了间接通过运算符调用运算符函数，还可以直接调用运算符函数。
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1690280194707-630937d8-cc47-46e8-a823-e566be1c0ba5.jpeg" width="600" /> </div>


<br/>



**某些运算符不应该被重载**
虽然优先级和结合律与内置运算符一致，==但是其他运算符规则无法保留下来==，如果`&&`和`||`的短路求值属性，`,`的从左到右的运算顺序也无法保留，==因此不建议进行重载==。
另外，由于某些运算符，如`&`，`,`，有特殊含义，如果重载将异于常态，不建议重载。


<br/>


**选择作为成员或者非成员**
具有对称性的运算符可能转换任意一端的运算符对象，例如算术、相等性、关系和位运算符，==如果两个运算对象类型不同（即，不具有对称性），则应该设置为普通的非成员函数==，例如下面的例子：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1690281270779-2b6ec522-14cc-4356-8607-b6c912de3a95.jpeg" width="700" /> </div>


---

<br/>


<br/>


<br/>



## 14.2 输入和输出运算符

###  14.2.1  重载`<<`

重载输出运算符时需要注意：

- 重载运算符`<<`必须是非成员函数，因为无法修改标准库的类。
- 第一个参数是输出流对象的引用，返回也是输出流的引用。

---


<br/>


<br/>


### 14.2.2 重载`>>`
重载输入运算符`>>`时需要注意的点和输出运算符`<<`类似。另外，在使用读入的值前，首先检查输入流的合法性，如果输入流不合法应该有对应的处理措施。

---


<br/>


<br/>


<br/>




## 14.3 算术与关系运算符
### 14.3.1 相等运算符
重载相等运算符`==`时需要注意：

- 相等运算符具有传递性。
- 重载了`==`时，一般也应该重载`!=`，`==`和`!=`中的一个把工作委托给另一个。

---

<br/>


<br/>



### 14.3.2 关系运算符

- 定义顺序关系。
- 和`==`保持一致。

---

<br/>


<br/>


<br/>



## 14.6 递增和递减运算符

为了和内置版本保持一致，应该返回递增或者递减之后的对象的引用。

**区分前置和后置运算符**
前置和后置的重载运算符的形参列表完全一样，为了进行区分，==**后置版本**接受一个额外的（不被使用）的int类型的形参==，如图所示：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1691051027198-5646e012-c170-48d5-8b4c-03137f35e5ee.jpeg" width="700" /> </div>

<br/>


**显示调用后置运算符**
当显式调用后置运算符时，必须为其int类型的形参提供一个值（任意一个int），如图：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1691051343272-d6ed46ef-c304-49be-ad2f-01b6af6b449e.jpeg" width="700" /> </div>



---


<br/>


<br/>


<br/>



## 14.7 成员访问运算符

解引用`*`可以完成所有我们需要的操作，例如返回一个常量。

==`->`必须返回一个指针==，重载箭头运算符时，可以改变的是从哪一个成员（指针）中获取对象，如下：
```cpp
class A{
public:
    string str="hello world";

    string* operator->(){
        return &str;
    }

};

int main (){
    A a;
    cout<<a->size ()<<endl;
   //相当于 &str ->size ()
```

---


<br/>


<br/>


<br/>



## 14.8 函数调用运算符
如果类定义了函数调用运算符`()`，该类的对象称为函数对象。可以对这种对象进行调用，行为像函数一样。函数对象可以存储状态，lambda 表示式可以进行值或引用捕获，保存在其中。

### 14.8.1 lambda是函数对象
编写一个 lambda 之后，编译器将该表达式翻译成一个**未命名类的未命名对象**（所以一个 lambda 表达式只能用`auto`修饰其类型）。在 lambda 表达式产生的类中含有一个重载的函数调用运算符。

lambda表达式产生的类不含有默认构造函数、赋值运算符以及默认的析构函数。是否含有默认的拷贝/移动构造函数则要视捕获的数据成员而定。

---

<br/>


<br/>



### 14.8.2 标准库定义的函数对象
标准库定义了一组表示算术、关系、逻辑运算的类，每个类分别重载了表示进行对应操作的函数调用运算符`()`，可以像是使用函数一样使用这些类的对象。
以下均为模板：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1691054376645-52c6a102-0910-400b-ae7c-8367fafc3705.jpeg" width="700" /> </div>


可以直接使用标准库定义的函数对象，不用自定义lambda。

---

<br/>


<br/>



### 14.8.3 可调用对象与function
C++中的可调用对象：函数、函数指针、lambda 表达式、bind 创建的对象（本书第十章内容，相当于一个函数的适配器）、函数对象。

不同的可调用对象可能具有相同的调用形式，但是由于是不同类型，不能统一处理（比如普通函数，和lambda表达式）。标准库提供了function类型解决这个问题：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1691135193208-611e4ed5-6753-411e-aca5-086ea1e92149.jpeg" width="700" /> </div>


可以将可调用的对象存储进function进行统一处理，但是实际使用过程中，发现function调用的额外时间消耗很高，==需要频繁调用函数的情况下，避免使用function==。

---


<br/>


<br/>


<br/>



## 14.9 重载、类型转换与运算符
### 14.9.1 类型转换运算符
类型转换运算符是一种特殊的成员函数，用于将类的对象转换成别的类型的对象，可以转换成任何其他类型（不包括void），只要其能够作为函数的返回类型，使用方式：
```cpp
operation type () const {  ... }
```


**定义含有类型转换运算符的类**
定义了类型转换运算符的类，在进行函数匹配 是 会进行隐式类型转换。
但是有可能出现出乎预料的结果，如下图：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1691137061559-8e70ad3a-bd2a-41af-9f71-a17533a6393f.jpeg" width="700" /> </div>

cin转化成bool类型，bool类型再提升为int类型，到时预料之外的结果。

<br/>


**显式的类型转换运算符**
为了避免上图那样预料之外的结果，可以==加上`explicit`关键字，表明不允许进行隐式的转换==，如下图：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1691137266117-9fe9e284-7905-486f-a8ab-55eabb31d546.jpeg" width="700" /> </div>


只有进行强制的类型转换才可以进行转换，但是有一个==例外是：如果表达式被用于条件，编译器会将显式的类型转换自动应用==。

---

<br/>


<br/>



### 14.9.2 避免有二义性的类型转换
必须保证类类型和目标类型之间只存在唯一一种转换方式，否则代码很可能具有二义性。会出现多重转换途径：

- 两个类提供相同的类型转换方式：A可以转换成B，B可以转换成A。
- 类定义了多个转换规则，可以通过其他类型转换联系在一起，特别是算术类型。

<br/>


**实参匹配和相同的类型转换**
在进行函数匹配时，如果需要进行类型转换，将 A 转换成类型 B，如果 A 类型多有多种转化成类型 B 的方式，编译器无法判断应该运行哪个类型转换，函数调用存在二义性。

当调用重载函数时，如果两个（或多个）**用户定义的类型转换**都提供了可行匹配，则认为这些类型转换一样好（二义性）。

---

<br/>


<br/>


<br/>



# 第15章 面向对象程序设计
## 15.1 OOP概述
**继承**
C++语言中，基类将类型相关的函数和派生类不做改变直接继承的函数区别对待。

虚函数：基类希望派生类自定义合适自身的版本。

派生类通过**类派生列表**，之前出从哪些类继承过来，派生列表中对基类的修饰的关键字表明了基类成员在派生类中对于对象用于的可见性。

<br/>


**动态绑定**
运行时才能确定类的指针或者引用实际上的类型，并根据实际类型，调用合适的函数。

---

<br/>


<br/>


<br/>




## 15.2 定义基类和派生类

### 15.2.1 定义基类

基类通常都应该定义一个虚析构函数。

**成员函数与继承**
派生类可以继承基类的成员，==派生类可以提供自己的定义来覆盖继承而来的定义（**是覆盖，继承而来的成员还是存在的**）==。

<br/>


==关键字`virtual`**只能出现在类内部**的声明语句之前==，而不用用于类外部的函数定义。
如果一个函数被定义为虚函数，其调用的解析过程，发生在运行时，否则发生在编译时。

<br/>


**访问控制与继承**
==`protected`表明派生类有权访问该成员==（基类对象本身及其友元也可以访问），禁止其他成员访问（用户可见但是不能使用，private是完全不可见）。

---


<br/>


<br/>


### 15.2.2 定义派生类
类派生列表中，对基类的修饰符：public，private，protected，==用于表示派生类的**用户**对于继承的成员的访问性。==
可将公有派生类型对象绑定到基类的引用或指针上面。

**派生类中的虚函数**
如果派生类没有覆盖基类中某个虚函数，则该虚函数行为类似其他普通成员。

如果需要覆盖虚函数需要在 ==const关键字或者引用限定符之后 加上关键字 `override`====，或者在函数之前加上`virtual`==。（如果不这样做，这样只是新定义了一个普通函数，在进行动态绑定时，并不会调用这个函数）。

<br/>


**派生类构造函数**
派生类使用基类的构造函数类初始化基类部分，使用方法如下图：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1691142668973-5e9613e1-c36d-47fb-aebe-0ce7d04bb0f9.jpeg" width="700" /> </div>


如果在初始化列表中，使用基类的构造函数初始化基类的成员，则会进行默认初始化。

<br/>


**继承与静态成员**
不论基类中派生出多少个派生类，每个静态成员都只存在唯一的实例。

> ==基类中的 static 成员不会被派生类继承==。 static 成员是属于类本身而不是类的实例的成员，==它们在内存中只有一份副本==。当派生类从基类派生时，
> ```cpp
> #include <iostream>
> 
> class Base {
> public:
>     static int staticMember;
> };
> 
> int Base:: staticMember = 10;
> 
> class Derived : public Base {
> };
> 
> int main () {
>     std:: cout << Base:: staticMember << std:: endl;    // 输出 10
>     std:: cout << Derived:: staticMember << std:: endl; // 输出 10
> 
>     Derived:: staticMember = 20;
> 
>     std:: cout << Base:: staticMember << std:: endl;    // 输出 20
>     std:: cout << Derived:: staticMember << std:: endl; // 输出 20
> 
>     return 0;
> }
> ``` 
> 
> **static 成员必须在类外面进行赋值。**

<br/>

**被用作基类的类**
如果想将一个类作为基类，该类必须已经定义而非仅仅声明。所以，一个类不能派生他自己。

<br/>

**防止继承的发生**
可以使用`final`关键字来表明一个类不能进行派生，使用方式如下图：
<div align="center"> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29674612/1691143036528-58f6a051-623c-40ee-8c22-2cee03b2c37b.jpeg" width="700" /> </div>



---

<br/>


<br/>



### 15.2.3 类型转换与继承
**静态类型与动态类型**
对于存在继承关系的类型，静态类型是变量声明时的类型，动态类型是变量表示的内存中的类型。如果表达式不是引用或者指针，动态类型和静态类型保持一致。

---


<br/>


<br/>


<br/>



## 15.3 虚函数

在进行动态绑定时，由于不知道到底是调用哪个函数，所以所有的虚函数都必须有定义。

**派生类中的虚函数**
一旦某个函数被声明为虚函数，则在所有的派生类中它都是虚函数。==虚函数继承自直接基类==，而不是继承链最顶上的基类。

如果一个派生类覆盖了虚函数，则形参列表必须和基类中的对应虚函数完全一致。一般返回类型也一致，但是如果返回类型是类本身的指针或者引用时，返回类型可以不一致（但是返回类型也只能改为派生类的引用或者指针）。

<br/>


**回避虚函数的机制**
在进行动态绑定时，可以使用 ==作用域运算符`::` 来指定要调用的虚函数的版本。==

---

<br/>


<br/>




## 15.4 抽象基类
**纯虚函数**
纯虚函数无需进行定义，在函数的声明语句之后加上`=0`即可，==**`=0`只能出现在类的内部**==。==**如果需要为纯虚函数提供定义，函数体必须定义在类的外面。**==

<br/>


**抽象基类**
含有（继承而未覆盖）纯虚函数的类是抽象基类。
抽象基类不允许创建对象。

---


<br/>


<br/>


<br/>



## 15.5 访问控制与继承

**公有、私有和受保护继承**

==派生访问说明符目的是控制**派生类用户**对一基类成员的访问权限==，而对于派生类成员（及其友元）没有影响。

<br/>


**派生类向基类转换的可访问性**
- 只有D public 继承B时，**用户代码**才能使用派生类向基类的转换。
- 无论D如何继承B，D的成员和友元都可使用派生类向基类的转换。
- ==如果 D是public或者 protected继承B，**D的派生类**的成员和友元可以使用D向B的类型转换==。

<br/>


**友元与继承**

==友元关系不能被继承==。

<br/>


**改变个别类的可访问性**

可以使用using声明来改变 派生类**继承的某个名字**的访问级别。如下图：
<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-10_100953.jpg" width = 700 /> </div>

<br/>



**默认的继承保护级别**

如果在继承时没有使用访问限定说明，class默认使用private继承，struct默认使用public继承。

---

<br/>


<br/>

<br/>



## 15.6 继承中的类作用域

**编译时进行名字查找**

由于名字查找发生在编译阶段，所以在进行动态绑定时，能使用哪些成员是由静态类型决定的。

<br/>


**名字冲突和继承**

名字查找是在继承链中往上进行查找，派生类可以重定义基类中的名字，此时基类中的名字将被进行隐藏。
==如果需要访问被隐藏的成员，可以使用类作用域运算符来指明使用被隐藏的成员==。

<br/>


**名字查找先于类型检查**

声明在==内层作用域的函数并不会重载外层作用域的函数，只是进行了名字的隐藏，即使形参列表并不一样==。
==一旦查找到同名函数，就停止查找，进行类型检查。==


<br/>


**虚函数与作用域**

为什么基类中的虚函数和派生类的虚函数必须有相同的形参列表？
在进行动态绑定时，现在静态类型（基类）进行名字查找，然后根据动态类型来确定调用的版本。如果形参列表不一样，那相当于派生类定义了一个新的虚函数，在动态绑定时并不会调用这个新的虚函数（因为基类不可见）。

<br/>


**覆盖重载的函数**

之前说过：内层作用域重定义外层作用的成员函数的名字，会将其隐藏。
如果想要达到重载的效果，可以使用using声明，将基类同名函数加入内层作用域，使其在能作用于也可见。

---

<br/>

<br/>


<br/>



## 15.7 构造函数与拷贝控制

### 15.7.1 虚析构函数

基类通常定义一个虚析构函数，这样可以动态分配继承体系中的对象。虚析构函数可以保证相应对象执行正确的析构版本。

虚析构函数将阻止合成移动操作。[[#^5d8983|如果一个类定义了析构函数，即使是=default的合成版本，编译器也不会为该类合成移动操作]]。

---

<br/>


<br/>


### 15.7.2 合成拷贝控制与继承

合成的拷贝控制函数除了对自身成员进行操作，还负责使用直接基类的对应操作对于直接基类部分进行操作，直接基类也会重复这样的过程，直到达到继承链的顶端。

**派生类中删除的拷贝控制和基类的关系**

某些定义基类的方式可能导致派生类合成成员成为删除的函数：
- 基类中的某个拷贝控制函数是删除的或者不可访问的，则派生类中的对应操作的==合成版本==也是删除的，因为编译器无法使用基类的成员对基类部分进行操作。
- 如果基类中有一个不可访问或者删除的析构函数，那么派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象的基类部分。
- 编译器不会合成一个删除的操作，即使使用了 =default 进行声明。

可以看出，影响到都是合成的拷贝控制操作，编译器能力有限，此时需要自己定义拷贝控制操作。

---

<br/>


<br/>


### 15.7.3 派生类的拷贝控制成员

派生类的构造函数和赋值函数不仅要处理自有成员，也要处理基类部分成员。而析构函数只需要处理派生类自己分配的资源。

**定义派生类的拷贝或移动构造函数**

派生类定义拷贝或者移动构造函数时，通常使用基类构造函数初始化对象基类部分。如果想要使用基类的拷贝或者移动构造函数，需要在构造函数初始值列表中显式调用该构造函数，如下图：
<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-10_195941.jpg" width = 700 /> </div>

如果没有使用基类的拷贝/移动构造函数，基类部分成员将被默认初始化。

<br/>


**派生类赋值运算符**

同样的，也必须显示为基类部分赋值，如下图：
<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-10_200357.jpg" width = 700 /> </div>

**派生类析构函数**

派生类析构函数只负责销毁派生类自己分配的资源。
==对象的销毁过程和创建过程刚好相反==：创建对象时，继承链最顶端的部分首先进行创建；销毁对象时，派生类的析构函数首先执行。


<br/>


**在构造函数和析构函数中调用虚函数**

由于在创建对象时，基类部分首先创建，此时对象处于未被初始化完成的状态，此时如果调用虚函数，执行对应派生类的版本可能会出错。

为了正确处理这种状态：==编译器认为在构造或析构的过程中，对象的类型 为构造函数或者析构函数所属的类型==。

---

<br/>


<br/>


### 15.7.4 继承的构造函数

类不==能继承默认、拷贝和移动构造函数==，==对于其他构造函数，通过非常规的方式继承——提供一条注明了直接基类名的 using 声明语句。==

通常using只是改变名字的可见性，但是==对于构造函数，使用using会使编译器**产生代码**==。对于基类的每个构造函数，编译器都会在派生类中生成一个形参列表完全一样的构造函数：
<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-10_205134.jpg" width = 700 /> </div>

如果派生类使用继承而来的构造函数，派生类自己的成员被默认初始化。

<br/>


**继承的构造函数的特点**

==构造函数的using声明并不会改变构造函数的访问级别==，构造函数的访问级别和其在基类的访问级别一样。

一个using声明语句不能指定 explicit 和 constexpr ，继承的构造函数的属性和其在基类时一样。 

==**如果一个基类的构造函数有默认实参，默认实参并不会被继承，而是生成多个构造函数**==。例如：如果基类有一个二参数的构造函数，其中一个有默认实参，将生产两个构造函数，一个含有一个参数，一个含有两个参数。

构造函数不会被继承的情况：
- ==**默认、拷贝和移动构造函数不会被继承**==。
- ==派生类定义的构造函数与基类的构造函数具有相同的参数列表时，不会被继承==（与继承构造函数的方式有关，编译器会生成代码，形式如上图）。

> ```cpp
> class Base {
> public:
>     int baseValue;
>     Base ()=default;
>     Base (int value) : baseValue (value) {
>         std:: cout << "Base constructor called!" << std:: endl;
>     }
> };
> 
> class Derived : public Base {
> public:
>     int derivedValue;
>     using Base:: Base; // 继承构造函数
> 
>     Derived (int value) : derivedValue (value) {
>         std:: cout << "Derived constructor called!" << std:: endl;
>     }
> };
> 
> int main () {
>     Derived derived (10);    //此时调用的不是继承构造函数, 因为没有被继承
>     return 0;
> }
> ```

---

<br/>


<br/>

<br/>


<br/>



# 第16章 模板与泛型编程

## 16.1 定义模板

当多个函数功能高度相似，只是参数的类似不同时，可以将其定义为模板。

### 16.1.1 函数模板

以关键字 template 开始，后跟一个模板参数列表，含有一个或多个用逗号分隔开的的模板参数。

**实例化函数模板**
在进行使用时，可以用明确指出模板参数类型，也可以靠==编译器用函数实参来推断模板实参==，从而实例化出一个函数。

<br/>


**模板类型参数**
模板类型参数可以看做是类型说明符。可以用 typename 或者 class 进行修饰。两个关键字一样，可以进行互换，可以在同一个参数列表中同时进行使用。

<br/>


**非类型模板参数**
==非类型模板参数表示一个值==而非类型，用特定类型的关键字进行修饰而非之前那两个关键字。非类型模板参数被用户提供的或者编译器推断出的值（常量表达式）进行替代。
这相当于给函数提供一个宏定义或者 const 常量，使用例子如下图：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-11_164544.jpg" width = 700 /> </div>

==绑定到指针或者引用非类型参数的实参必须具有静态生存期==。

<br/>


**inline 和 constexper 的函数模板**
和普通函数一样，inline 和 constexper 放在模板参数列表之后，返回类型之前。

<br/>


**模板编译**
当使用（而不是定义）模板时，编译器才会生成代码。在实例化时，编译器需要掌握函数模板和类模板成员函数的定义，所以模板一般放入头文件中。
当使用模板时，所有不依赖于模板参数的名字都必须是可见的。

---

<br/>


<br/>


### 16.1.2 类的模板

编译器不能为类模板推断模板参数类型，显示填写模板实参列表。

**在模板作用域中引用模板类型**
在一个类模板中如果使用了另一个模板，通常不将模板的实际类型的名字作为其模板实参，而是将模板自己的参数作为被使用的模板实参（可移植性更好）。

<br/>


**类模板的成员函数**
可以在类内或者类外定义类模板的成员函数，同理，定义在类内部的成员函数隐式声明为 inline 函数。
在类外进行定义时，方法如下：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-11_171048.jpg" width = 700 /> </div>


<br/>


**类模板成员函数实例化**
==**如果一个成员函数没有被使用，则将不会被实例化**==。这样可以使得即使某种类型不是完全符合模板操作要求，依然可以使用该类型实例化类。 ^0aec96

<br/>


**简化模板类型的使用**
在类模板作用域内，可以直接使用模板名而不同提供实参，如下图：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-11_171606.jpg" width = 700 /> </div>

在类模板之外定义成员时，需要注意：==**直到遇到类名才表示进入类的作用域**==，如下图：

<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-11_172100.jpg" width = 700 /> </div>


<br/>


**类模板和友元**
- **一对一**友好关系：只对于特定实例是友元。
- **通用**的模板友好关系：所有友元模板的实例都是友元。
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-11_172649.jpg" width = 700 /> </div>

上图展示两种模板友元的差别，需要注意：==**对于特定实例的友好关系需要前置声明**==。

<br/>


==**令模板类型参数成为友元**==
可以将模板类型参数声明为友元，如果参数为内置类型，这种友好关系也是允许的。

<br/>


==**模板类型别名**==
由于模板不是一个类型，所以不能使用 typedef 来声明模板别名。允许使用 using 给模板声明模板的别名：
```cpp
template<tyepname T> using twin = pair<T,T>;
twin<int> a;//相当于 pair<int,int>
```

<br/>

**类模板的 static 成员**
对于类模板，每种类都有一个独立 static 对象；对于模板类，所有对象共享一份 static。

---

<br/>


<br/>



### 16.1.3 模板参数
 
模板参数的名字没有特殊含义，通常命名为 T。

**模板参数与作用域**
模板参数名的可用范围是在其声明之后，在模板之内不能重用模板参数名字。

<br/>


**使用类的类型成员**
当在模板中，对于模板参数 T 使用作用域运算符 `::` 访问类型成员或者 static 时存在困难，因为编译器不知道`T::mem`访问的是类型成员还是 static 成员。
==默认情况下，C++假定作用作用域访问的名字**不是类型**==。==如果希望使用一个模板类型参数的类型成员，必须**使用 `typename `关键字显式告诉编译器该名字是一个类型**==，如下图： ^daac44
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-11_205852.jpg" width = 700 /> </div>


<br/>


**默认模板实参**
类似函数，也可以为模板提供默认实参，默认实参不仅可以是类型，如果 int 这样的内置类型或者自定类型，还可以是对象模板，如下图：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-11_210328.jpg" width = 700 /> </div>


---

<br/>


<br/>


### 16.1.4 成员模板

成员模板不能是虚函数。

**普通类的成员模板**
定义方式和普通的函数模板一样。

<br/>


**类模板的成员模板**
需要注意：在类模板之外定义一个成员模板，必须同时为类模板和成员模板提供模板参数列表，如下图：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-11_213901.jpg" width = 700 /> </div>

---

<br/>


<br/>


### 16.1.5 控制实例化

当两个或多个独立编译的源文件使用了相同的模板（提供了相同的模板参数），每个文件中都会生成一个该模板的实例（代码），在大型系统中，额外开销严重。

可以使用显式实例化来避免这种开销，如下图：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-11_214250.jpg" width = 700 /> </div>

==当编译器遇到 extern 模板声明时，将不会在本文件中产生实例化代码。==此时使用的是别的文件生成的实例（所以必须保证至少有一个非 extern 的声明，也就是定义）。

<br/>


**实例化定义会实例所有成员**
之前提过，[[#^0aec96|类模板的函数只有被使用时才会被实例化]]，但是一个==类模板的实例化定义会实例化所有该模板的成员==。

---


<br/>


<br/>


<br/>



## 16.2 模板实参推断

### 16.2.1 类型转换与模板类型参数

对于函数模板，编译器通常不进行类型转换（依然会忽略顶层 const），而是生成一个新的实例。两种类型转换除外： ^4d32fe
- 非 const 对象的引用（指针）传递给 const 对象的引用（指针）实参。
- 数组或者函数指针转换：注意只能是数组或者函数类型转换成对应的指针类型。

<br/>


**使用相同模板参数类型的函数形参**
在模板函数中，当多个形参使用了同一个模板参数 T，但是调用时推断出的类型不一样，将会出错。

<br/>


**正常类型转换应用于普通函数实参**
上文提到的类型转换的规则，是对应模板在进行参数匹配时而言的，如==果一个模板显式指定了模板参数，相当于一个普通函数==，在调用时可以进行普通函数的类型转换。

---

<br/>


<br/>



### 16.2.2 函数模板显式实参

当一个模板参数没有在参数列表中出现时，编译器无法进行类型推断，此时必须提供**显式模板实参**。
==显式模板实参按照左右到右的实现与对应的模板参数匹配==。

**正常类型转换应用于显式指定的实参**
如果某个模板参数被显示指定了，那么该模板类型的形参可以进行正常的类型转换（相当于普通函数）。

---

<br/>


<br/>


### 16.2.3 尾置返回类型与类型转换

==当模板函数的返回类型依赖于模板参数（但是不是模板参数本身）==，此时需要使用 decltype 进行类型推断。此时，问题在于前置返回类型无法找到一个可见的参数传递给 decltype 进行类型推断，所以需要使用尾置返回类型，如下图：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_110454.jpg" width = 700 /> </div>

<br/>


**进行类型转换的标准库模板类型**
由于 decltype 不会忽略引用，有时需要获得本身的类型，此时可以利用**标准类型转换模板**进行操作：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_111539.jpg" width = 700 /> </div>

需要注意：利用模板类型获得成员时，需要 [[#^daac44|使用 typename 明确指出成员是类型]]。

---

<br/>

### 16.2.4 函数指针和实参推断

当使用函数模板初始化一个函数指针或者为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。

如果不能从函数指针类型确定模板实参将产生错误：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_112158.jpg" width = 700 /> </div>

可以显示模板实参来消除歧义。

---

<br/>

<br/>


### 16.2.5 模板实参推断和引用

> **<font color="#c00000">右值</font>和<font color="#c00000">右值引用</font>的区别**
> 在 C++中，"右值"和"右值引用"是两个相关但不同的概念。
> 
> - 右值（Rvalue）是指表达式的值，该值可以出现在赋值语句的右边。通常，右值是临时创建的、无法取地址的、即将被销毁的值。例如，常量、临时对象、表达式的结果等都可以被视为右值。
> 
> - 右值引用（Rvalue reference）是一种引用类型，用于绑定到右值。它使用"&&"符号来声明，例如"int&&"。右值引用允许我们对右值进行引用绑定，并可以通过移动语义（move semantics）实现高效的资源管理和转移。
> 
> 右值引用的主要用途之一是实现移动语义。当我们有一个临时对象或将要被销毁的对象时，通过使用右值引用，我们可以将资源从该对象转移到另一个对象，而不需要进行深拷贝。这可以提高性能并避免不必要的内存开销。总结起来，右值是表达式的值的概念，而右值引用是一种特殊的引用类型，用于绑定到右值，并实现移动语义。
> 
> **<font color="#c00000">左值</font>和<font color="#c00000">左值引用</font>的区别**
> 
> - 左值（Lvalue）是指表达式的值，该值可以出现在赋值语句的左边或右边。左值可以被取地址，并且具有持久的身份。通常，变量、对象、函数返回的左值引用等都可以被视为左值。
> 
> - 左值引用（Lvalue reference）是一种引用类型，用于绑定到左值。它使用"&"符号来声明，例如"int&"。左值引用允许我们对左值进行引用绑定，可以修改其值或状态。
> 
> 左值引用的主要用途之一是作为函数参数，可以通过引用传递来避免进行不必要的拷贝。此外，左值引用还可以用于函数重载，以区分传入的参数是左值还是右值。总结起来，左值是表达式的值的概念，而左值引用是一种特殊的引用类型，用于绑定到左值，并允许修改其值或状态。
> 
> **函数模板如何根据参数进行推导**
> 相当于解方程，参数列表中带有 T 的类型为左式，传入的参数类型为右式，根据引用折叠规则，对 T 的类型进行推导。




<br/>



**从左值引用函数推断类型**
- 函数参数为 `T&` ，此时参数为 T 的引用类型，==如果传入的参数是 const 那么 T 是底层 const（不会被忽略）==。
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_123625.jpg" width = 700 /> </div>

- 函数参数为 `const T&` 类型，此时可以传入任意类型对象（const 或者非 const，左值或者右值）。
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_123827.jpg" width = 700 /> </div>

<br/>


**从右值引用函数参数推断类型**
==函数参数是右值引用 `T&& `时==，如果传入的是一个右值，和正常一样，但是如果==传入一个左值，将出现特殊的情况==。

<br/>


==**引用折叠和右值引用参数**==
C++在正常绑定规则之外定义了两个例外：
- 将一个左值传递给函数的右值引用参数（T&&）时，模板类型参数为实参的左值引用类型。
- 间接创建（类型别名或者模板）一个引用的引用时，会进行折叠：
	- ` X& &`，`X& &&`，`X&& &`都会折叠为 `X&`。
	- `X&& &&`折叠为` X&&`。

上面两个规则导致的结果：
- 函数参数为 T&& ，T 可以绑定到一个左值。
- 实参是一个左值，那么推断出来的模板实参类型一定是一个左值引用。

---


<br/>


<br/>

### 16.2.3 理解 `std::move`

**std:: move 的定义**
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_125635.jpg" width = 700 /> </div>

**左值 static_cast 到右值**
上图可以发现，将一个左值引用 static_cast 转化为右值，这就是截断左值（左值不再是左值）。

---

<br/>


<br/>


### 16.2.7 转发

某些情况下，函数需要把一个或者多个实参连通类型不变转发给其他函数，当其中用到左值引用时，==使用 T&& 能够很好保持原参数信息==，如下图：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_151200.jpg" width = 700 /> </div>

上述代码当参数是左值（变量）时，能够很好工作。

但是当 f 需要的参数时右值引用时，即使传入给 flip2 的参数是右值也会出错，原因在于==在进行类型推断和引用折叠之后，传入的右值变成了一个普通的变量 T2 不是 T2&&== ，此时传递给 f 函数将会出错。

> ==**在函数调用过程中，右值引用会被转换为左值**==
> 右值引用通常用于实现移动语义，即从一个对象转移资源到另一个对象。然而，当一个右值引用作为函数参数传递时，它的身份会发生改变。在函数调用过程中，右值引用会被视为一个具有持久身份的左值，而不是一个即将被销毁的右值。 这种转换是为了确保在函数内部可以对参数进行修改或操作，而不会因为参数是右值引用而受到限制。因为右值引用被视为左值，所以可以对其进行地址获取、修改值等操作。

<br/>


==**在调用中使用 `std:: forward` 保持类型信息**==
==forward< T >返回 T&&==，本质上就是给原来参数类型加上&& ，结合上引用折叠的性质，从而能保持和原来的参数性质一样。 ^c1b49c

[深入理解左值和右值](https://zhuanlan.zhihu.com/p/513628368)

---

<br/>


<br/>


<br/>



## 16.3 重载与模板

函数模板可以被另一个模板或者非模板函数重载。

**多个可行模板**
==当存在多个精确匹配的函数模板，编译器会调用最特例化的版本==，如下图：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_170424.jpg" width = 700 /> </div>


<br/>


**非模板和模板重载**
当存在非模板的可行函数时，==会优先调用非模板函数==。

<br/>


**重载函数与类型转换**
候选的模板函数都是精确匹配， [[#^4d32fe|因为函数模板只会进行优先的类型转换]]。==如果非模板函数不是精确匹配，那么即使他比模板函数更特例化，也不会调用他==，也就是在同样都是精确匹配的情况下，才有非模板函数更优。

---


<br/>


<br/>


<br/>


## 16.4 可变参数模板

可变参数模板包含两种参数包：
- 模板参数包
- 函数参数包

使用方式如下图：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_171319.jpg" width = 700 /> </div>

**`sizeof... `运算符**
`sizeof...` 返回常量表达式，表示包中有多少个元素。
```cpp
cout<<sizeof... (args)<<endl;
```


### 16.1.4 编写可变参数函数模板

可以用 [[#^f0d54d|initializer_list]] 来编写函数，对于参数类型和数量都未知的情况，使用可变参数模板更为方便。

可变参数函数通常是递归的，下图是一个例子：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_172138.jpg" width = 700 /> </div>

---

<br/>


<br/>


### 16.4.2 包拓展

对于一个参数包除了能够获取大小，剩下就是进行拓展：提供元素模式，将包按照模式分解为一个个元素，在模式右边方式省略号，触发拓展操作。

拓展结果是：一个由包中元素配合特定模式，构成的列表，例子如下：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_172811.jpg" width = 700 /> </div>

**模式操作**
除了向上面那样，增加类型修饰符作为模式，==可以把函数调用作为模式==，如下：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_173318.jpg" width = 700 /> </div>

---

<br/>


<br/>


### 16.4.3 转发参数包
当需要模板函数会把参数传递给另一个函数，并且需要参数的性质不变时，此时可以使用之前的 [[#^c1b49c|右值引用和 std:: forward]] 来保持参数的性质：
<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-12_173911.jpg" width = 700 /> </div>

---

<br/>


<br/>


<br/>



## 16.5 模板特例化

以下为 ChatGPT 的回答：
> 1. **特例化 vs 重载**：
>     
>     - 函数模板特例化是为函数模板提供特定类型的定制实现，特例化针对整个模板，通过在尖括号中指定类型来实现。
>     - 函数重载是在同一个作用域内为同名函数提供不同参数列表的实现，根据参数类型或数量来区分不同版本。
> 2. **适用对象**：
>     
>     - 函数模板特例化适用于模板函数，可以为特定类型提供特殊实现。
>     - 函数重载适用于普通函数，用于根据参数类型或数量实现不同版本。
> 3. **调用方式**：
>     
>     - 函数模板特例化调用时，编译器会根据传入的参数类型选择相应的特例化版本。
>     - 函数重载调用时，编译器会根据参数类型或数量选择匹配的重载版本。
> 
> 总的来说，函数模板特例化和函数重载都是为函数提供定制实现的方式，但==特例化针对整个模板==，而重载则针对不同的参数列表。选择哪种方法取决于你的需求和代码结构。


**定义函数模板特例化**
特例化一个模板时，必须为研模板每个模板参数提供实参，关键字 template 之后跟着空尖括号。
为了特例化一个模板，原模板声明必须在作用域，为了避免出错，通常将原模板和特例放在同一个头文件中。

**类模板特例化**
可以为类模板进行特例化，一个例子如下：
```cpp
namespace std {
    template<>
    struct hash<pair<int, int>> {
        std:: size_t operator ()(std::pair<int, int> const &pair) const {
            std:: size_t h 1 = std::hash<int>()(pair. first);
            std:: size_t h 2 = std::hash<int>()(pair. second);

            return h 1 ^ h 2;
        }
    };
}
```

---

<br/>


<br/>


<br/>


<br/>



# 第17章 标准库特殊设施


## 17.1 tuple 类型

类似于` pair `，但成员可以有多个，支持的操作的如下：

<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-28_150526.jpg" width = 700 /> </div>


由于 tuple 的成员数量是不固定的，所以每个成员都是未命名的（不想 pair 那样有 first 和 second），访问成员需要使用 `get<>( ) `函数 得到元素的==引用==。

如果需要得到 tuple 中的具体信息，可以使用两个辅助类模板：
- `tuple_size<t>::value`：得到 tuple 中成员的数量。
- `tuple_element<i , t>::type`：得到 tuple 对象 t 中第 i 个元素的类型。

---

<br/>


<br/>


<br/>



## 17.2 bitset 类型

### 17.2.1 定义和初始化 bitset

<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-28_151557.jpg" width = 700 /> </div>

利用 string 构造 biset 时可以利用 zero 和 one 的值进行额外操作（0 和 1 反转等）。

当时使用整型值来初始化 biset 时，此时值将被转化为 unsigned long long，然后使用位模式来初始化得到 bieset。

---

<br/>


<br/>



### 17.2.2 bitset 操作

<div align="center"> <img src=" https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-08-28_152839.jpg" width = 700 /> </div>

biset 的操作如上图，常用的操作已标出。

---

<br/>


<br/>


<br/>



## 17.3 正则表达式

由于 C++标准库中正则表达式效率极低并且存在 bug，建议使用 boost 库的正则表达式。

---

<br/>


<br/>


<br/>



## 17.4 随机数

随机数库的组成 ：
- 引擎：生成随机整数序列。
- 分布：使用引起返回服从特定概率分布的随机数。


### 17.4.1 随机数与随机数引擎

随机数引擎是函数对象类，默认引擎为 default_random_engine，标准库的随机数更多信息[参考资料](https://blog.csdn.net/weixin_43869898/article/details/114182656)。

对于大多数场合随机数引擎输出端随机数是不能直接使用的，一般使用随机数分布。

<br/>


**分布类型和引擎**
```cpp
uniform_int_distribution<unsigned> u (0,9);
default_random_engine e;
cout<<u (e)<<endl;
```
随机数分布是模板，需要指定输出类型，但是每个模板都有默认模板实参，例如 uniform_int_distribution 的默认输出类型为 int。

<br/>


**引擎生成数值序列**
==随机数在 默认使用种子的情况下，每次运行程序都会**输出相同的序列**。==

```cpp
void rand_demo () {
    default_random_engine e;
    uniform_real_distribution<> u (0, 9);
    for (int i = 0; i < 10; ++i)
        cout << u (e) << ' ';
    cout << '\n';
}

int main () {
    rand_demo ();
    rand_demo ();
    return 0;
}			
```

<br/>

上面代码两次调用输出的结果必然是一样的，解决方式有两种：
 - 将引擎设置为 `static`，对于两次调用，即使是同一段序列，但是起点不一样所以不会出现之前的情况。
 - 使用随机种子，一般的方法是使用时间作为种子，但是 time (0) 返回的是秒，只有两次调用间隔大于 1 秒才能保证生成 的序列不一样。
- 还可使用**真随机生成器**生成种子，demo 如下：

<br/>


```cpp
void rand_demo () {
    random_device seed;
    ranlux 48 engine (seed ());
    uniform_real_distribution<> u (0, 9);
    for (int i = 0; i < 10; ++i)
        cout << u (engine) << ' ';
    cout << '\n';
}

int main () {
    rand_demo ();
    rand_demo ();
    return 0;
}
```

---

<br/>


<br/>


<br/>



### 17.4.2 其他随机数分布

**生成非均匀分布的随机数**
```cpp
normal_distribution<> n (1,1);
```
生成服从均值为 1，标准差为 1 的正态分布的数。

<br/>


**`bernoulli_distribution `类**
`bernoulli_distribution` 类是是一个普通类，返回一个 bool，返回 true 概率为 0.5。

---


<br/>


<br/>


<br/>


## 17.5   `IO`库再探


### 17.5.1  格式化输入输出

操纵符很多定义在头文件`iomanip`中。

标准库定义了一组操纵符来修改流的状态，一个操纵符是一个函数或者对象，会影响流的状态。

当操纵符改变流的格式状态时，通常改变后的状态对于所有后续 IO 都有效。大硕书改变格式状态的操纵符都是 设置/恢复 成对的。

**控制布尔值格式**
默认情况下，`bool`打印为 0 或者 1。使用`boolalpha`打印 true 或者 false。
```cpp
cout<<boolalpha;                //设置状态
cout<<true<<' '<<false<<endl;
cout<<noboolalpha;              //恢复状态
```


<br/>

**指定整型数的进制**
默认情况下，整型数输入输出使用十进制，可以使用`hex`、`oct`、`dec`改为十六进制、八进制，改回十进制。
```cpp
cout<<20<<' '<<1024<<endl;   
cout<<hex<<20<<' '<<1024<<endl;
cout<<oct<<20<<' '<<1024<<endl;
```


<br/>

**输出指定进制**
使用`showbase`，会在输出结果中显示进制。
```cpp
cout<<showbase;
cout<<20<<' '<<1024<<endl;   
cout<<hex<<20<<' '<<1024<<endl;
cout<<oct<<20<<' '<<1024<<endl;
cout<<noshowbase;

//20 1024
//0x14 0x400
//024 02000
```


<br/>

**指定打印精度**
两种改变打印精度的方式：
- `cout`的`precision`成员
- `setprecision`操纵符

一般情况下，控制打印精度是控制输出的总位数（不包括小数点），但是==当和`fixed`一起使用时，`setprecision`的作用变为控制输出小数位的位数。==
==无论哪种情况下，输出结果不是截断，而是进行四舍五入。==
```cpp
double num = 30.14159265358979323846;
cout << fixed << setprecision (4) << num << endl;   //30.1416
```
` precision`的使用方式如下，和`fixed`使用时也有同样的效果。
```cpp
cout. precision (4);
```


<br/>

**指定浮点数记数法**
- `scientific`：使用科学记数法。
- `fixed`：使用定点十进制记数法，还可以配合`setprecision ()`使用。
- `hexfloat`：使用十六进制记数法。

> 在浮点数的十六进制记数法中，输出的形式可以分为三个部分：符号位、尾数部分和指数部分。 
>  
> 1. 符号位：在这个例子中，符号位是正号（+），表示这是一个正数。 
> 2. 尾数部分： 1.921 f 9 f 01 b 866 e 是尾数部分，它表示浮点数的有效数字部分。在十六进制记数法中，尾数部分是一个十六进制小数。 
> 3. 指数部分： +1 是指数部分，它表示浮点数的指数。在这个例子中，指数为 1，表示要将尾数部分乘以 2 的 1 次方。 
>  
> 综合起来， 0 x 1.921 f 9 f 01 b 866 ep+1 表示的是一个正的浮点数，尾数部分为 1.921 f 9 f 01 b 866 e ，指数为 1。

- `defaultfloat`：恢复到默认状态——根据要打印的值选择记数法。


<br/>

**打印小数点**
显示小数点和不显示小数点只是针对小数部分为 0 的数而言的。
- `showpoint`：显示小数点
- `noshowpoint`：不显示小数点
```cpp
    cout<<noshowpoint;
    cout<<10<<endl;     //10
    cout<<10.0<<endl;   //10
    cout<<10.1<<endl;   //10.1
```



<br/>

**输出补白**
- `setw`：指定**下一个**数字或者字符串的**最小空间**。
- `left`：左对齐。
- `right`：右对齐，默认是右对齐。
- `internal`：左对齐符号（`-`），右对齐数字。
- `setfill`：设置字符代替默认的空格来补白输出。


<br/>

**控制输入格式**
默认情况下会忽略空白符，`noskipws`会令输入运算符读取空白符，使用`skipws`进行恢复。

---

<br/>


<br/>

### 17.5.2  未格式化的输入输出操作

未格式化 IO 允许用户将一个流当作一无解释的字节序列来处理。

**单字节操作**
- `is. get (ch)`：读取下一个字节并存入字符 ch 中。
- `os. put (ch)`：ch 输出到 os 中。
- `is. get ()`：将下一个字节作为`int`返回。
- `is. putback (ch)`：将字符 ch 放回 is 中。
- `is. unget ()`：将 is 回退一个字节（只能回退一次）。
- `is. peek ()`：下一个字节作为`int`返回，不从流中删除它。

特别需要注意的是`is. get ()`返回的是一个`int`类型，如果用`char`去接收，当遇到 EOF 时，结果将不可预知。



<br/>

**多字节操作**
一个读取多个字节数据放到缓冲区中。
- `is. get (sink, size, delim)`：从`is`最多读取 size-1 个字节，最后一个字节，将填入`'\0'`。

---

<br/>


<br/>

### 17.5.3  随机流访问

主要是`seek`和`tell`函数。不再赘述。


---

<br/>


<br/>


<br/>


<br/>

# 第18 章  用于大型程序的 工具

大规模应用程序的特殊要求包括：
- 在独立开发的子系统之间协同处理错误的能力。
- 使用各种库进行协同开发的能力。
- 对复杂应用概念建模的能力。

正好分别对应三个 C++语言特性：异常处理、命令空间、多重继承。


## 18.1  异常处理


### 18.1.1  抛出异常

当执行一个`throw`时，其后面的语句不再执行，而将控制权交给第一个匹配的`catch`子句。

**栈展开**
当抛出异常之后，程序会从调用链，从里到外寻找匹配的 `catch`子句，沿着调用链创建的对象将会被摧毁。如果找不到匹配的`catch`语句，程序调用标准库函数`terminate`终止程序执行。


<br/>

**栈展开过程中对象的销毁**
在栈展开过程中，退出来某个块，编译器负责确保周期这个块重创建的对象能被正确的销毁。
> 如果异常发生在构造函数中，即使对象只被创建了一半，也需要保证已构造的成员被正确的销毁。


<br/>

**析构函数与异常**
如果析构函数需要执行某个可能抛出异常的操作，该操作应该至于`try`语句中，并且在析构函数内得到处理。


<br/>

**异常对象**
`throw`子句中的对象必须拥有完全类型（即，声明之后，而且有定义）。

当异常处理完毕之后，异常对象被销毁。

当抛出一条表达式时，该==表达式的静态解析类型决定了该异常包含的信息==。如果`throw`解引用基类指针，而该指针实际指向的是派生对象，那么抛出的对象将被切掉一部分。

---


<br/>


<br/>

### 18.1.2  捕获异常

`catch`子句中的异常声明类似于函数的参数声明。异常类型必须是完全类型，可以是左值引用，但不能是右值引用。

如果`catch`的参数类型是非引用类型，该参数是异常对象的一个副本，但是原异常对象也要等到异常处理接收之后再销毁。

**查找匹配的处理代码**
挑选出来的匹配的 catch 语句未必是最佳匹配，但是是第一个与异常匹配的 catch 语句。

除了一些极细小的差异之外，要求的异常类型和 catch 声明的类型是精确匹配的。
- 非常量相常量的类型转换。
- 派生类相基类的类型转换。
- 数值或者函数被转化为对应的指针。


<br/>

==**重新抛出**==
如果需要把异常再次抛出只需要一条不包含任何表达式的`throw`语句：
```cpp
throw;
```

此时会把之前捕获的异常再次抛出，需要注意异常对象是引用还是非引用的差异。

<br/>


**捕获所以异常处理的代码**
```cpp
try{
	//......
}catch (...){
	//......
}
```
使用省略号作为异常声明，能够捕获所有类型的异常。

---

<br/>


<br/>

### 18.1.3  构造函数中对的 try 语句

使用方式如下：
```cpp
class test{
    public:
    test (int i, int j, int k) try : i (i), j (j), k (k){
    }
    catch (...){
        cout << "catch" << endl;
    }
    
    int i, j, k;
};
```
即可以处理初始化列表抛出的异常，也可以处理函数体中抛出的异常。

---

<br/>


<br/>

### 18.1.4  `noexcept`异常说明

使用`noexcept`说明来保证某个**函数**不会抛出异常：
```cpp
void recoup (int)  noexcept;  //不会抛出任何异常
void alloc (int);             //可能会抛出异常
```

**违反异常说明**
当函数使用了`noexcept`说明符，但是实际上抛出了异常，程序就会调用`terminate`终止程序。上诉过程并未对是否执行栈展开作出约定。

<br/>

**异常说明实参**
`noexcept`说明符可以接收一个可选的实参，该实参必须能够转化为`bool`类型。
```cpp
void recoup (int)  noexcept (true);  //不会抛出任何异常
void alloc (int) noexcept (false);      //可能会抛出异常
```


<br/>

**`noexcept`运算符**
`noexcept`可以作为一元运算符，根据表示给定的表达式是否会可能抛出异常，来返回 true 或者 false。
```cpp
void f () noexcept;
void g ();

void h () noexcept ( noexcept (f ())) );  //不会抛出异常
void j () noexcept ( noexcept (g ())) );  //可能会抛出异常
```


<br/>

**异常说明与指针、虚函数和拷贝**
当函数指针被声明为不会抛出异常，给他赋值的函数必须`noexcept`.

当虚函数是`noexcept`时，其后续派生出来的虚函数也必须做出同样的承诺。


---

<br/>


<br/>

### 18.1.5  异常类层次

当需要自定义异常类时，根据情况来选择继承异常类：
<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-11-08_170427.jpg" width = 600 /> </div>

---

<br/>


<br/>


<br/>

## 18.2  命名空间

### 18.2.1  命名空间定义

```cpp
namespace cplusplus_perimer{
	//......
}
```

==命名空间作用域之后没有分号`;`，不能将命名空间定义 或者 打开一个命名空间 在函数或者类的内部。==

**每个命名空间都是一个作用域**
在命名空间中，其中规律和一个作用域一样。

<br/>

**命名空间可以不连续**
对于一个命名空间可以多次再次打开。可以把定义和接口分离，将命名空间定义在一个头文件中，然后再源文件（.cpp）中去定义接口。
> 在 C++中，如果在一个源文件（. cpp 文件）中定义了一个命名空间 nsp，其他源文件（. cpp 文件）是无法直接访问和打开该命名空间的。命名空间的作用范围仅限于定义它的源文件内部。如果你想在其他源文件中访问和使用该命名空间，可以通过头文件将其声明和定义导出，并在需要使用该命名空间的源文件中包含该头文件。 


<br/>

**定义命名空间成员**
在引入包含命名空间的头文件之后，定义其中成员的方法有两种：
- 打开命名空间，在命名空间中进行定义。
- 在命名空间之外，使用作用运算符，指明成员所属命名空间后进行定义。
```cpp
cplusplus_primer::Sales_data
cplusplus_primer:: operator + ( ){
	//......
}
```

<br/>

**模板特例化**
模板特例化必须定义在原式模板所属的命名空间中。

可以这样，开命名空间后在里面进行定义。
```cpp
namespace std {
    template<>
    struct  hash<std::pair<int, int>>{
        size_t operator ()(const std::pair<int, int>& p) const {
            return std::hash<int>()(p.first) ^ std::hash<int>()(p.second);
        }
    };      
}
```

和之前一样，==在命名空间中声明==了特例化，就可以==在命名空间之后进行定义==了。
```cpp
namespace std {
    template<>
    struct  hash<std::pair<int, int>>;
}
// 在命名空间外定义 std::hash<std::pair<int, int>> 的特化版本
template<>
struct  std::hash<std::pair<int, int>>{
    size_t operator ()(const std::pair<int, int>& p) const {
        return std::hash<int>()(p.first) ^ std::hash<int>()(p.second);
    }
};   
```


<br/>

**全局命名空间**
文件全局作用域中定义的名字，定义在 **全局命名空间** 中的。全局命名空间是隐式定义的，没有名字，表示其中一个成员的方式如下：
```cpp
:: nember_name
```


<br/>

**嵌套的命名空间**
即在命名空间中定义命名空间。


<br/>

**内联命名空间**
内联命名空间中的名字可以直接被外层命名空间直接使用。

定义内联命名空间需要在命名空间第一次出现时使用`inline`，后续再次打开命名空间时可以不加`inline`关键字。
```cpp
inline namespace FifthEd{
	//首次定义使用 inline 关键字
}
namespace FifthEd{
	//后续打开可以不加
}
```

当应用程序代码发生改动是，常常用到内联命名空间——将最新版代码放在内联命名空间，旧版代码放在普通命名空间中。
```cpp
namespace cpp_primer{
	inline namespace FifthEd{
			//最新版
	}
	namespace FourthEd{
			//旧版本
	}
}
```
此时，对于最先版本的成员可以直接访问，对于旧版本而需要加上完整命名空间名字。


<br/>

**未命名的 nsp**
未命名的 nsp 中定义的变量有静态生命周期。unname 的 nsp 可以在一个文件中不连续（同一文件多次打开未命名的 nsp，其实是同一个 nsp），但是不能跨文件。

不能对未命名的 nsp 的成员使用作用于运算符`::`。

==未命名的 nsp 的成员的作用于和该 nsp 所在的作用域相同。==
```cpp
int i;
namespace {
	int i;
}

i=10;    //错误，具有二义性
::i=10;    //错误，未命名 nsp 中的 i 的作用于和全局 i 一样
```

---

<br/>


<br/>

### 18.2.2  使用命名空间成员

**nsp 别名**
```cpp
namespace cplusplus_primer{  /*******/  }

namespace primer=cplusplus_primer; //取一个简洁的别名
```


<br/>

**`using`声明**
`using`声明一次值引入 nsp 的一个成员，引入的名字有效范围从声明地方开始到声明所在作用域结束，==即局部作用域有效==。==外层作用域的同名实体会被屏蔽==。

在类的作用域中，声明语句只能指向基类成员。

<br/>

**`using`指示**
引入命名空间的所有实体。


<br/>

**`using`指示和作用域**
==`using`指示将 nsp 成员 提升到 包含 nsp 本身和 using 指示的 **最近作用域**==。

以下例子中，在函数 f 看来，==**A 中的名字仿佛是出现在全局作用于 f 之前一样**==。
```cpp
namespace A{
	int i, j;
}
void f (){
	using namespace A;
	cout<<i*j<<endl;
}
```

这里是另一个例子：
```cpp
int i=0;

namespace A{
    int i=1;
}
int main () {
    int i=2;
    using namespace A;
    std::cout<<::i<<std:: endl;      // 0 ，全局变量 i
    std::cout<<i<<std:: endl;        // 2 ，被局部变量 i 屏蔽
    return 0;
}
```


---

<br/>


<br/>

### 18.2.3  类、命名空间与作用域

对于位于命名空间中的类来说，依然是常规的查找规则——先在成员中查找，然后是类中（包括基类），接着在外层作用域。

**实参相关查找和类类型形参** ^e3bd70
```cpp
std:: string s;
std::cin>>s;
```
在以上例子中，`>>`定义在命名空间 std 中，但是不用 using 声明就可以使用。这是因为——==**给函数传递一个类类型对象时，处理在常规的作用于查找外，还会查找实参所属的命名空间**==。



<br/>

**友元声明和实参相关查找**
当类声明了一个友元时，友元声明并没有使得友元本身可见。但是，==一个另外的**未声明**的**类或者函数**如果**第一次出现在友元声明中**，则认为是**该类所属 nsp 的成员**==。

==当这条规则和 [[#^e3bd70|实参相关查找规则]]结合时，可以根据函数的实参的命名空间查找函数，如果该函数是友元，并且在实参类中找不到，就会到实参所属 nsp  中进行查找。==
```cpp
namespace outer_nsp{
    namespace A {
        class MyClass {
        public:
            friend void f (A::MyClass) ;
        };

        void f (A:: MyClass ){
            std:: cout << "在 A 中找到 f 函数" << std:: endl;
        }
    }
    
    // 定义在此处将查找不到
    // void f (A:: MyClass ) {
    //     std:: cout << "在 A 的外层 nsp 找到 f 函数" << std:: endl;
    // }
}

int main () {
    outer_nsp::A:: MyClass obj;
    f (obj);
    return 0;
}
```
<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-11-10_225801.jpg" width = 700 /> </div>

---

<br/>


<br/>


### 18.2.4  重载和命名空间

**与实参相关的查找和重载**
与 函数的实参查找规则 结合之后，会在所有实参类所遇 nsp 中搜索候选函数，所有同名函数将会被添加到候选函数集中。


<br/>

**重载与`using`声明**
使用`using`声明引入一个函数时，所有同名函数都会被引入，当`using`声明坐在作用于存在和引入函数同名且形参列表相同的函数，将会报错。

---

<br/>


<br/>


<br/>

## 18.3  多重继承与虚继承

## 18.3.1  多重继承

**派生类构造函数初始化所有基类**
基类的构造顺序和**派生列表**中基类出现的顺序一致。而且是呈递归的形态进行，例如，类 A 派生列表一个类是 B，那么首先构造 B，如果 B 也是别的类派生而来的，需要先构造基类，进行和类 A 同样的过程。

析构的过程刚好相反。


<br/>

**继承的构造函数与多重继承**
如果从多个基类中继承了相同的构造函数（参数列表相同），则这个类必须为该构造函数定义自己的版本。
<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-11-11_141119.jpg" width = 700 /> </div>


**多重继承的派生类的拷贝和移动操作**
合成的移动拷贝赋值运算符和拷贝构造函数和 构造函数的构造顺序一样。

---

<br/>


<br/>

### 18.3.2  类型转换与多个基类

==编译器认为转换到任意的一种基类都一样好==。

<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-11-11_142024.jpg" width = 600 /> </div>


---

<br/>


<br/>

### 18.3.3  多重继承下的类作用域

只有一个基类时，查找过程沿着继承体系向上进行。多重继承的情况下，相同的查找过程会在所有直接基类中同时进行，如果找到多个名字，则出现二义性错误。

名字查找由于类型检查，所以派尔合适呢个基类继承的同个同名函数即使参数列表不同，也会存在二义性问题。最好的解决方式是——派生类提供一个自己定义的版本。


---

<br/>


<br/>

### 18.3.4   虚继承

<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-11-11_142605.jpg" width = 600 /> </div>

当出现这样菱形结构时，普通的继承方式会出现两份 zooAnimal 的拷贝，在进行使用时会出现二义性问题。

通过虚继承来解决问题，虚基类无论出现多少次，在派生类中都只有一份虚基类的拷贝。

**使用虚基类**
在进行继承时，使用`virtual`关键字。`public`等关键字和`virtual`的顺序可以任意。

<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-11-11_143402.jpg" width = 700 /> </div>

---

<br/>


<br/>

### 18.3.5  构造函数与虚继承

==虚基类是由最底层的派生类初始化的==——如果不这样，虚基类将会被重复初始化。

---

<br/>


<br/>


<br/>


<br/>

# 第 19 章  特殊工具和技术

一般很少用到本章内容，仅做基本的了解。

## 19.1  控制内存分配

### 19.1.1  重载 `new` 和 `delete`

**`new` 和 `delete` 表达式的工作过程**
当使用了一个 `new` 表示式时，实际上执行了三步操作：
```cpp
string *sp = new string("a value");
string  *arr = new string[10];
```

- 调用 `operator new` 或者 `operator new[]` 标准库函数，分配原始内存。
- 运行构造函数在原始内存构造对象。
- 返回指向对象的指针。

同理，当使用 `delete` 表达式删除一个动态分配的对象时，可以分为：
```cpp
delete sp;
delete [] arr;
```
- 对指针指向对象或者数组元素对象执行析构函数。
- 编译器调用 `operator delete` 或者 `operator delete []` 标准库函数释放内存。

我们可以根据需要自定义 `operator new` 和 `operator delete` 函数。

> **`new` 表达式和 `operator new` 函数**
> 这是两个不同的概念。<span style="background:#fff88f">`operator new` 并没有重载 `new`</span>。<span style="background:#fff88f">用户无法自定义 `new` 表达式的行为</span>。表达式的行为总是和上面所说的一样。
> 
> `delete` 表示式也是同理。

<br/>


**`operator new` 和 `operator delete` 接口**

标准库定义了一组 `operator new` 和 `operator delete` 的重载函数：

<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2023-11-11_161226.jpg" width = 700 /> </div>

当想调用 `operator new` 不抛出异常的版本时，使用 <span style="background:#fff88f">**new 的定位形式**</span>，提供额外的形参：
```cpp
MyClass obj_p* = new (std::nothrow) MyClass();
```

当自定义的 `operator new` 有多的实参时（<span style="background:#fff88f">多出的默认实参只能在上诉重载函数的参数列表之后追加，不能改动第一个（第二个）参数类型和返回类型</span>），也是通过这种方式传入参数。



<br/>

`operator delete` 的不抛出异常版本，一般是编译器自动调用的。<span style="background:#fff88f">如果 `nothrow` 的 new 版本失败了，将自动调用 `nothrow` 的 `operator delete`</span>：

```cpp

struct MyClass{
    MyClass() { throw "ERROR"; } //抛出异常，让new表达式失败
    ~MyClass() { cout<<"~MyClass"<<endl; }
};

// 自动调用nothrow 的delete操作符
void operator delete(void* p,const std::nothrow_t&) {
    cout<<"nothrow delete"<<endl;
    free(p);
}

int main() {
    try{
        MyClass* p = new (std::nothrow) MyClass();//new定位形式调用nothrow的operator new版本
    }catch(const char* e) {
        cout<<e<<endl;
    }
    return 0;
}
//nothrow delete
//ERROR
```


---

<br/>


<br/>

### 19.1.2  定位 `new` 表达式

C++早期版本中，[[#^6667a0|allocator类]]不是标准库的内容。如果想把对象的内存分配和初始化分类，需要调用 `operator new` 和 `operator delete` ——负责分配或释放空间，但是不构造或销毁对象。


<span style="background:#fff88f">对于 `operator new` 分配的内存</span>，无法使用构造函数构造对象，<span style="background:#fff88f">只能使用定位 new 来构造对象</span>。
```cpp
class Foo
{
private:
    int val;
public:
    Foo(int v) : val(v) {}
    void writeFoo() { cout << "val:" << val << "  address:" << this << endl; }
};

int main()
{
    // operator new 分配内存
	char *buff = (char*)operator new[](3 * sizeof(Foo));
    // 只能使用定位new构造
    Foo *pb = new (buff) Foo(1);
    Foo *pb1 = new (buff + sizeof(Foo)) Foo(2);
    Foo *pb2 = new (buff + 2 * sizeof(Foo)) Foo(3);

    pb->writeFoo();
    pb1->writeFoo();
    pb2->writeFoo();
    return 0;
}
/*
val:1  address:0x1da8ac02a80
val:2  address:0x1da8ac02a84
val:3  address:0x1da8ac02a88
*/
```

---

<br/>


<br/>


<br/>

## 19.2  运行时类型识别

当无法使用虚函数，或者不适合使用虚函数时，可以使用 RTTI （run-time type identification）运算符。

### 19.2.1  `dynamic_cast` 运算符

 `dynamic_cast` 运算符使用形式有以下三种：
 ```cpp
  dynamic_cast<type*>(e);    //e是指针
  dynamic_cast<type&>(e);    //e是左值
  dynamic_cast<type&&>(e);   //e不能是左值
```


<br/>

**指针类型的 `dynamic_cast`**
可是实现基类和派生类指针的转化，前提是 <span style="background:#fff88f">**Base 类中至少含有一个虚函数**</span>。

可以实现从<span style="background:#fff88f">派生类到基类</span>的转化：
```cpp
class Base{
public:
    int i;
    virtual void f(){}
};

class Derived: public Base{
public:
    int j;
};
int main()
{
    Derived *dp=new Derived;
    Base *bp;
    if (bp = dynamic_cast<Base*>(dp)) {
        cout << "works" << endl;
    } else {
        cout << "not works" << endl;
    }
    return 0;
}
// works
```

或者<span style="background:#fff88f">转化到**实际**或者在实际类型继承链之上</span>的类型：
```cpp
int main()
{
    Derived d;
    Base *bp = &d;
    Derived *dp;
    if (dp = dynamic_cast<Derived*>(bp)) {
        cout << "works" << endl;
    } else {
        cout << "not works" << endl;
    }
    return 0;
}
```

如果转换失败得到指针的值将会是 0。


<br/>

**引用类型的`dynamic_cast`**
因为没有所谓的空引用，所以引用类型转换失败 时，会抛出一个`std::bad_cast`的异常。

---

<br/>


<br/>

### 19.2.2  `typeid`运算符

可以作用于任意类型表达式，顶层`const`会被忽略，当作用于数组或者函数是，并不会执行向指针的转换。
```cpp
int a[10];
int *ap=a;
cout<<typeid (a). name ()<<endl;
cout<<typeid (ap). name ()<<endl;
// A 10_i  
// Pi
```

当运算对象是类类型或者并且包含虚函数时，才会指示对象的动态类型。<span style="background:#fff88f">如果运算对象是一个**指针**，运算结果永远是静态类型</span>。


---


<br/>


<br/>


<br/>

## 19.3  枚举类型

枚举类型 (enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。一个枚举对象只能表示其中一个枚举常量。

C++包含两种枚举类型：
```cpp
enum color {red, yellow, green};    //不限定作用于的枚举
enum class stoplight {red, yellow, green};    //限定作用域的枚举
```

<br/>


**枚举成员**
- 对于不限定作用域的枚举类型，枚举成员的作用域和枚举类型作用域一样。
- 对于限定作用域的枚举类型，枚举成员的访问需要作用域运算符，如`stoplight::red`

默认情况下，枚举值从 0 开始，依次加 1。也可以指定值，对于指定部分值的情况，没指定值的成员等于前面枚举成员的值加一。
```cpp
enum color{red=1, green=3, blue}
cout<<blue<<endl; //4
```


<br/>

**枚举类型对象**
对于一个枚举类型对象，只能用该类型的枚举成员来进行赋值。
```cpp
enum COLOR{red=1, green=2, blue};
COLOR color_1 =red; //正确
COLOR color_2 =1;   //错误
```
对于**不限定作用域**的枚举类型的对象可以自动转换为整形。
```cpp
enum COLOR{red=1, green=2, blue};
COLOR color_1 =red; 
int i=color_1;

enum class STOPLIGHT{red=1, green=2, blue};
STOPLIGHT stoplight_1=STOPLIGHT:: red;
int j=stoplight_1;                  //错误
int j=static_cast<int>(stoplight_1); //正确，强制类型转换
```


<br/>

**枚举类型的前置声明**
```cpp
enum intVallues: unsigned long long; //不限定作用域，前置声明必须指定成员类型
enum class open_modes;  //限定作用域可以不指定，默认为 int
```

---

<br/>


<br/>


<br/>

## 19.4   类成员指针

类成员指针是指向类的**非静态**成员的指针。


### 19.4.1  数据成员指针

```cpp
class Test
{
public:
    Test (string s): contents (s){}
    const string Test::*pdata=&Test:: contents;    //声明并初始化

private:
    string contents;
};

int main ()
{
    Test testclass=Test ("hello");
    auto p=testclass. pdata;
    cout<<testclass.*p;
    return 0;
}
```


<br/>

**使用数据成员指针**
当初始化成员指针之后并没有指向任何数据，只知道这个指针可以执行类的那个成员。

需要有一个类的对象实例，才可以使用指针。有两种使用方式：
```cpp
Test testclass=Test ("hello");
auto *ptestclass=&testclass;
auto p=testclass. pdata;
cout<<testclass.*p<<endl;
cout<<ptestclass->*p<<endl;
```


<br/>

**返回数据成员指针的函数**
数据成员一般是私有的，所以一般会设置一个函数来返回私有成员的指针。


---

<br/>


<br/>

### 19.4.2   成员函数指针

和指向普通成员的一样，需要注意的是，如果成员函数存在重载的情况，必须显式声明函数的类型：
```cpp
char (Sreen::*pmf2) (Screen:: pos, Screen::pos) const;
pmf2 =&Screen:: get;
```



<br/>

**使用成员函数指针**
```cpp
Screen myScreen, *pScreen=&myScreen;
char c1 = (pScreen->*pmf)();    //通过对象指针调用
char c2 =(myScreen.*pmf)();    //通过对象调用
```
<span style="background:#fff88f">需要加括号</span>。


<br/>

**成员函数指针表**
成员函数指针的用途之一就是存放如一个函数表中，然后根据情况来调用不同的函数。

---

<br/>


<br/>

### 19.4.3   将成员函数作为可调用对象

类成员函数指针需要绑定到一个特定对象身上才可以使用，成员指针不是可调用对象。

**使用`function`生成可调用对象**
```cpp
function<bool(const string&)> fcn=&string:: empty;
find_if (svec. begin (), svec. end (), fcn);
```

当一个 function 对象包含指向成员函数的指针时，会使用正确执行函数调用。


<br/>

**使用`mem_fn`生成可调用对象**
`mem_fn`可以通过成员指针的类型来推断可调用对象的类型。
```cpp
auto f=mem_fn (&string::empty);
```
当函数存在重载的情况时，无法进行推断，可以使用 function，或者进行类型转换，明确指出函数的类型。
```cpp
class MyClass {
public:
    void func () {
        std:: cout << "Non-overloaded member function" << std:: endl;
    }

    void func (int x) {
        std:: cout << "Overloaded member function with parameter: " << x << std:: endl;
    }
};

int main () {
    MyClass obj;
    
    auto fn 1 = std:: mem_fn (static_cast<void (MyClass::*)()>(&MyClass::func));
    fn 1 (obj); // 调用非重载的成员函数

    auto fn 2 = std:: mem_fn (static_cast<void (MyClass::*)(int)>(&MyClass::func));
    fn 2 (obj, 42); // 调用重载的成员函数

    return 0;
}
```


<br/>

**使用`bind`生成可调用对象**
[[#10.3.4 参数绑定|bind的使用方式]]。
```cpp
auto it =find_if (svec. begin (), svec. end (), bind (&string::empty,_1));
```

<span style="background:#fff88f">可以看出，这里和之前一样，只要把对象作为第一个参数传入，编译器会自动执行正确的函数调用。</span>

```cpp
class MyClass {
public:
    void func (int x) {
        std:: cout << "Output: "<<x << std:: endl;
    }
};

int main () {
    MyClass obj;
    auto f=std:: bind (&MyClass:: func, std::placeholders:: _1, std::placeholders::_2);
    f (obj, 2);

    return 0;
}
```


---
